(function() {
  window._satellite = window._satellite || {};
  window._satellite.container = {
  "buildInfo": {
    "buildDate": "2021-09-22T14:40:28Z",
    "turbineBuildDate": "2021-08-11T20:25:49Z",
    "turbineVersion": "27.2.0"
  },
  "environment": {
    "id": "EN919758db9a654a17bac7d184b99c4820",
    "stage": "production"
  },
  "dataElements": {
    "digitalData.search.filters": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
var
  searchFilterLogic;

searchFilterLogic = function (currentDL) {
// TEMP CODE for AEC
  if( _satellite.getVar('adobe_aec_pages')){
    if (digitalData._get('digitalData.filterInfo') && digitalData._get('digitalData.filterInfo.filterName')) {
      digitalData.search = {};
      digitalData.search.filter = [];
      digitalData._set('digitalData.search.searchInfo.sort',digitalData.filterInfo.sortType);
      var filter_maker = digitalData.filterInfo.filterName.split('|');
      for (var i = 0; i < filter_maker.length; i++) {
        var filter_make = filter_maker[i].split(':'),
          filter_cat = filter_make[0],
          filter_values = filter_make[1].split(',');
        for (var j = 0; j < filter_values.length; j++) {
          var filterInfos = {};
          filterInfos.filterInfo = {};
          filterInfos.filterInfo.category = filter_cat;
          filterInfos.filterInfo.keyword = filter_values[j];
          digitalData.search.filter.push(filterInfos);
        }
      }
    }
  }
  
  var filter = currentDL._get('digitalData.search.filter'),
    filter_res = '';
  if (filter && filter.length > 0) {
    for (var k = 0; k < filter.length; k++) {
      if (k == filter.length - 1) {
        filter_res += filter[k].filterInfo.category + ':' + filter[k].filterInfo.keyword;
      } else {
        filter_res += filter[k].filterInfo.category + ':' + filter[k].filterInfo.keyword + '|';
      }
    }
  }
    
  return filter_res += currentDL._get('digitalData.search.searchInfo.sort') ? '|sortType:' + currentDL._get('digitalData.search.searchInfo.sort') : '';
};

return searchFilterLogic;
}
      }
    },
    "isStudent": {
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var expires = new Date(),
  allow = true,
  st = _satellite,
  wl = window.location,
  href = wl.href,
  cookie = st.cookie,
  index = function (str, substr) {
    return str.indexOf(substr) !== -1;
  };

if (typeof st._isStudent !== "undefined") {
  return st._isStudent;
}

if (href.match(/(\?|\&)context\=nat_geo/) || href.match(/(\?|\&)lms/)) {
  if(_satellite._getDomain) {
    var consentChoiceCookieConfig = {
      domain: _satellite._getDomain(),
      path: '/',
      samesite: 'Lax',
      expires: (
        // one year from now
        expires.setFullYear(expires.getFullYear() + 1), expires)
    };
    cookie.set('K12', 1, consentChoiceCookieConfig);
    st._isStudent = false;
  }
  return false;
}

if (document.cookie.match(/\; K12=1;/)) {
  st._isStudent = false;
  return false;
}

st._isStudent = true;
return allow;
}
      }
    },
    "adobe_urlRegions": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return {
  'africa': 1,
  'ae_ar': 1,
  'ae_en': 1,
  'at': 1,
  'au': 1,
  'be': 1,
  'be_en': 1,
  'be_fr': 1,
  'be_nl': 1,
  'bg': 1,
  'br': 1,
  'ca': 1,
  'ca_es': 1,
  'ca_fr': 1,
  'ch': 1,
  'ch_de': 1,
  'ch_fr': 1,
  'ch_it': 1,
  'cin': 1,
  'cis_en': 1,
  'cis_ru': 1,
  'cn': 1,
  'cl': 1,
  'cs': 1,
  'cs_cz': 1,
  'cy': 1,
  'cy_en': 1,
  'cz': 1,
  'da': 1,
  'da_dk': 1,
  'de': 1,
  'de_de': 1,
  'dk': 1,
  'ee': 1,
  'eeurope': 1,
  'en':1,
  'en_gb': 1,
  'en_us': 1,
  'es': 1,
  'es_es': 1,
  'eu_es': 1,
  'fi': 1,
  'fi_fi': 1,
  'fr': 1,
  'fr_fr': 1,
  'gr': 1,
  'gr_en': 1,
  'hk': 1,
  'hk_en': 1,
  'hk_zh': 1,
  'hr': 1,
  'hr_hr': 1,
  'hu': 1,
  'hu_hu': 1,
  'ie': 1,
  'il': 1,
  'il_en': 1,
  'il_he': 1,
  'in': 1,
  'it': 1,
  'it_it': 1,
  'ja': 1,
  'ja_jp': 1,
  'jp': 1,
  'ko': 1,
  'ko_kr': 1,
  'kr': 1,
  'la': 1,
  'lt': 1,
  'lu': 1,
  'lu_de': 1,
  'lu_en': 1,
  'lu_fr': 1,
  'lv': 1,
  'mena': 1,
  'mena_ar': 1,
  'mena_en': 1,
  'mena_fr': 1,
  'mt': 1,
  'mx': 1,
  'na': 1,
  'nb': 1,
  'nb_no': 1,
  'nl': 1,
  'nl_nl': 1,
  'no': 1,
  'nz': 1,
  'pl': 1,
  'pl_pl': 1,
  'pt': 1,
  'pt_br': 1,
  'ro': 1,
  'ro_ro': 1,
  'rs': 1,
  'ru': 1,
  'ru_ru': 1,
  'sa_ar': 1,
  'sa_en': 1,
  'se': 1,
  'sea': 1,
  'si': 1,
  'sg' : 1,
  'sk': 1,
  'sk_sk': 1,
  'sl_si': 1,
  'sv': 1,
  'sv_se': 1,
  'th_en': 1,
  'tr': 1,
  'tr_tr': 1,
  'tw': 1,
  'tw_cn': 1,
  'ua': 1,
  'uk': 1,
  'uk_ua': 1,
  'us': 1,
  'za': 1,
  'zh_cn': 1,
  'zh_tw': 1,
  'zh-tw': 1,
  'zh-Hans': 1,
  'zh-Hant': 1
};
}
      }
    },
    "digitalData.app.appInfo.appCtxId": {
      "defaultValue": "No Value",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */

var appCtxId = 'No Value_No Value',
  ddAppCtxId;

// exclude on other pages except NGL and 
if (digitalData._get('page.pageInfo.siteSection') && (digitalData._get('page.pageInfo.siteSection') !== 'InApp:NGL' ||
  digitalData._get('page.pageInfo.siteSection') !== 'account.adobe.com')) {
  appCtxId = '';
}

if (digitalData._get('app.appInfo.appCtxId')) {
  ddAppCtxId = digitalData._get('app.appInfo.appCtxId');
} else if (_satellite._getQueryParam('appctxid') || _satellite._getQueryParam('appCtxId') || _satellite._getQueryParam('appctxId')) {
  ddAppCtxId = _satellite._getQueryParam('appctxid') || _satellite._getQueryParam('appCtxId') || _satellite._getQueryParam('appctxId');
}

if (ddAppCtxId) {
  var appCtxIdSplit = ddAppCtxId.indexOf('_') !== -1 ? ddAppCtxId.split('_') : '';
  if (appCtxIdSplit.length === 6 && appCtxIdSplit[5] === '0') {
    appCtxIdSplit[5] = 'zero';
  }
  // Replacing Session ID with NA value
  if (appCtxIdSplit[4]) {
    appCtxIdSplit[4] = 'NA';
  }
  appCtxId = appCtxIdSplit.length ? appCtxIdSplit.join('_') : ddAppCtxId;
}
if (digitalData._get('page.pageInfo.siteSection') === 'account.adobe.com' && appCtxId === 'No Value_No Value') {
  appCtxId = '';
}
return appCtxId;
}
      }
    },
    "aep_enable": {
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
    loc = w.location,
    href = loc.href,
    path = loc.pathname,
    host = loc.hostname,
    hrefContains,
    langContains;

hrefContains = function (string) {
    return href.indexOf(string) !== -1;
};



if (hrefContains('flashplayer/end-of-life')) {
    return false;
}

if (host === 'www.adobe.com' ||
    host === 'www.stage.adobe.com' ||
    host === 'business.adobe.com') {
    return true;
}
}
      }
    },
    "thirdParty_isAbort": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
  h = w.location.hostname,
  p = w.location.pathname,
  index = function(str, substr) {
    return str.indexOf(substr) !== -1;
  };


if (_satellite._getQueryParam('dtm_disable_dc') && _satellite._getQueryParam('dtm_disable_dc') == '1') {
  return 'no';
} else if (_satellite.cookie.get('ff_9911445534') == '0' || _satellite.cookie.get('ff_1559257598') == '1') {
  return 'no';
} else if (index(h, 'account.adobe.com') || index(h, 'accounts.adobe.com')) {
  return 'no';
} else if (index(p, '/unsubscribe.html')) {
  return 'no';
} else if (index(h, '.acrobat.com') || index(h, 'adminconsole.adobe.com')) {
  return 'no';
} else if (index(h, '.adobe.com') && index(p, '/mini-plans')) {
  return 'no';
} else if (index(h, 'workflow') || index(h, 'documentcloud.adobe.com') || index(h, 'dev.acrobat.adobe.com') || index(h, 'dc.dev.dexilab.acrobat.com')) {
  return 'no';
} else {
  return 'yes';
}
}
      }
    },
    "visitorService_idSyncDisableSyncs": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var 
  disabled = true,
  cookieConsent = _satellite.cookie.get('OptanonConsent'),
   q_search = window.location.search;

if(q_search.indexOf('lms')!==-1 ||q_search.indexOf('context=nat_geo')!==-1 || !_satellite.getVar('isStudent')){
  return true;
}

// if audienceManager is enabled, then we probably want to fire the syncs
if (_satellite.getVar('audienceManager_enable')) {
  
  // if consent is given
  if  (cookieConsent && cookieConsent.indexOf('C0004:1') !== -1) {
    disabled = false;
  // otherwise, wait until the PrivacyConsent event fires and consent is given
  }
  
  else {
    // leave disabled to true

    window.addEventListener('adobePrivacy:PrivacyConsent', function () {
      var
        visitor = _satellite.getVisitorId();

      // set the idsyncs to fire
      visitor.idSyncDisableSyncs = false;
      visitor.disableIdSyncs = false;
    });
  }

}

return disabled;
}
      }
    },
    "aep_demandbase": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var aep_demandbase = {},
  sid = '';

if (digitalData._get('digitalData.organization.demandbase.demandbaseInfo.demandbase_sid')) {
  sid = digitalData._get('digitalData.organization.demandbase.demandbaseInfo.demandbase_sid');
}
aep_demandbase = {

  'demandbaseInfo': {
    'demandbase_sid': sid.toString() || '',
    
    'company_name' : digitalData._get('digitalData.organization.demandbase.demandbaseInfo.company_name') || '',
    
    'revenue_range' : digitalData._get('digitalData.organization.demandbase.demandbaseInfo.revenue_range') || ''
  },

  'dimensions': digitalData._get('digitalData.organization.demandbase.dimensions') || '',

  'dimensionsCustom': digitalData._get('digitalData.organization.demandbase.dimensionsCustom') || ''

};

return aep_demandbase;
}
      }
    },
    "digitalData.organization.dnb": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* eslint-disable no-redeclare */
/* eslint-disable no-unused-vars */
/* eslint-disable no-undef */
var
  promise,
  unresolved = {},
  name = 'digitalData.organization.dnb';
// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];
  
// if the promise exists, return it...
if (promise) {
  return promise;
}

if (
 !_satellite.getVar('enable_performanceCookie')
  )
 {
  return Promise.resolve(unresolved);
}

promise = new Promise(function (resolve) {
  var cookieName = 'DnB';
  // do a thing, possibly async, thenâ€¦

  // eslint-disable-next-line no-console
  window.dnbvid = function () {
    return {
      ajax: function (B, A) {
        var stateChange = function () {
          if (request.readyState == 4) {
            callbackFunction(request.status, request.responseText);
          }
        };
        var getRequest = function () {
          if (navigator.userAgent.match(/MSIE 9.0/i)) {
            xdr = new XDomainRequest;
            xdr.onload = function () {
              callbackFunction(200, xdr.responseText);
            };
            return xdr;
          } else {
            if (window.XMLHttpRequest) {
              return new XMLHttpRequest;
            }
          }
          return false;
        };
        var postBody = arguments[2] || '';
        var callbackFunction = A;
        var url = B;
        var request = getRequest();
        try {
          if (request) {
            var C = request;
            C.onreadystatechange = stateChange;
            if (postBody !== '') {
              C.open('POST', B, true);
              C.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
              C.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
              C.setRequestHeader('Connection', 'close');
            } else {
              C.open('GET', B, true);
            }
            C.withCredentials = true;
            C.send(postBody);
          }
        } catch (e) {
          callbackFunction(200, '{"status": "404", "message":"not found"}');
        }
      },
      getData: function (api, type, resptype, callback) {
        var url = location.protocol + '//' + api + '.d41.co/api/?req=' + api + '&form=' + type;
        this.ajax(url, function (status, resp) {
          if (status == 200) {
            var response = JSON.parse(resp);
            if (response.status == 200 || response.status == 404 || response.status == 402 || response.status == 403) {
              if (resptype == 'raw') callback(resp);
              else callback(response);
              return;
            } else {
              //console.log('dnb_getData: ' + response.status + ' - ' + response.message);
              callback({});
              return;
            }
          } else {
            //console.log('dnb_getData: unexpected status:' + status);
            return;
          }
        });
      }
    };
  }();


  if (_satellite.cookie.get(cookieName) == '2') {
    resolve('');
  } else {
    dnbvid.getData('ade0164', 'json', 'T', function (dnb_Data) {
      if (_satellite.cookie.get(cookieName) == '1') {
        _satellite.cookie.set(cookieName, '2');
      } else {
        _satellite.cookie.set(cookieName, '1');
      }
      var handle = function () {
        //var dnb_data = {};
        dnb_Data.dimensionsCustom1 = dnb_Data.duns +
              ':' + dnb_Data.companyName +
              ':' + dnb_Data.companyMsa +
              ':' + dnb_Data.companyCountry +
              ':' + dnb_Data.parentDuns +
              ':' + dnb_Data.domesticUltimateDuns;
        dnb_Data.dimensionsCustom2 = dnb_Data.ultimateDuns +
              ':' + dnb_Data.industryNaics +
              ':' + dnb_Data.salesAnnual +
              ':' + dnb_Data.employeesInAllLocations +
              ':' + dnb_Data.jobFunction +
              ':' + dnb_Data.jobSeniority;

        resolve(dnb_Data);
      };
      if (dnb_Data.length) {
        handle();
      } else {
        _satellite._poll(handle(), [
          function () {
            return dnb_Data.length;
          }
        ], {
          timeout: 5000,
          interval: 1000
        });
      }
    });
  }
});

_satellite._promises[name] = promise;

promise.unresolved = unresolved;

return promise;
}
      }
    },
    "digitalData.previousPage.pageInfo.percentPageViewed": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  loc = window.location;

return _satellite._getPercentPageViewed(loc.hostname + loc.pathname)[1];
}
      }
    },
    "isDCWeb": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  is = false,
  h = w.location.hostname,
  hostnameContains;

// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

//------------------------------------------------------------------------------
// Virgo Web - Grp-dc-web-analytics <dc-web-analytics@adobe.com>
//------------------------------------------------------------------------------

if (
  hostnameContains('local-test.acrobat.com') ||
  hostnameContains('dc.dev.dexilab.acrobat.com') ||
  hostnameContains('dc.dev.dexilab.adobe.com') ||
  hostnameContains('dc.stage.acrobat.com') ||
  hostnameContains('dc.stage.adobe.com') ||
  hostnameContains('dc.acrobat.com') ||
  hostnameContains('dc.adobe.com') ||
  hostnameContains('documentcloud.adobe.com')
) {
  is = true;
}

return is;
}
      }
    },
    "digitalData.adobe.experienceCloud.target": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* eslint-disable no-undef */
var
  w = window,
  value = {},
  info = {};

// get library and version 

// mbox.js
if (w.mboxVersion) {

  info.library = 'mbox.js';
  info.version = w.mboxVersion;

  // at.js
} else if (
  w.adobe &&
  w.adobe.target
) {

  info.library = 'at.js';
  info.version = w.adobe.target.VERSION;

}

if (digitalData._get('digitalData.adobe.experienceCloud.target.info.tests')) {

  info.testDetails = digitalData._get('digitalData.adobe.experienceCloud.target.info.tests').map(function (elem) {
    if (elem.testInfo && elem.testInfo.campaignID && elem.testInfo.offerID) {
      return elem.testInfo.campaignID + '|' + elem.testInfo.offerID;
    }
  }).join(',');
}

// info
value.info = info;

return value;
}
      }
    },
    "digitalData.appLauncher": {
      "defaultValue": "no",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var
  w = window,
  l = w.location,
  h,

  hostnameContains,

  appLauncher = {};

appLauncher.appIcon = 'No';

// parameter or default to location.hostname
h = l.hostname;

// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};


if (

  //----------------------------------------------------------------------------
  // CC Home - Grp-CCHome-Eng <Grp-CCHome-Eng@adobe.com>
  //----------------------------------------------------------------------------
  // local
  hostnameContains('app-local.hollywoodstudios.corp.adobe.com') ||
  hostnameContains('dev.hollywoodstudios.corp.adobe.com') ||
  hostnameContains('dev2.hollywoodstudios.corp.adobe.com') ||
  // dev
  hostnameContains('cchome-dev.adobe.io') ||
  hostnameContains('dev.creativecloud.adobe.com') ||
  hostnameContains('dev.cc.adobe.com') ||
  hostnameContains('dev.cchome.adobe.com') ||
  hostnameContains('dev2.cchome.adobe.com') ||
  hostnameContains('dev3.cchome.adobe.com') ||
  // stage
  hostnameContains('cchome-stage.adobe.io') ||
  hostnameContains('stage.creativecloud.adobe.com') ||
  hostnameContains('stage.cc.adobe.com') ||
  hostnameContains('stage.cchome.adobe.com') ||
  hostnameContains('stage2.cchome.adobe.com') ||
  // prod
  hostnameContains('cchome.adobe.io') ||
  hostnameContains('creativecloud.adobe.com') ||
  hostnameContains('cc.adobe.com') ||
  hostnameContains('r.cchome.adobe.com') ||
  hostnameContains('cchome.adobe.com')||
  
  //AEC
  _satellite.getVar('adobe_aec_pages')
  
) {
  appLauncher.appIcon = 'AppLauncher';
}

return appLauncher;
}
      }
    },
    "mbox_parameter_entitlement_product": {
      "defaultValue": "",
      "forceLowerCase": true,
      "cleanText": true,
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  w = window,
  entitlement = '',
  products;

if (
  w.feds && 
  w.feds.data && 
  w.feds.data.isLoggedIn && 
  w.feds.data.entitlements
) {
  products = w.feds.data.entitlements.offer_families;
  if (typeof(products) === 'undefined') {
     entitlement = '';
  } else {
    for (var product in products) {
        entitlement += product + ',';
    }
  }
}
return entitlement;
}
      }
    },
    "aep_consent": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  if(_satellite.getVar('enable_performanceCookie'))
    return 'in';

else 
    return 'out'
}
      }
    },
    "digitalData.adobe.experienceCloud.libraryVersions": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  de_ExpCloud = 'digitalData.adobe.experienceCloud',
  NV = 'No Value',
  s_DEGET = function (deName) {
    return _satellite.getVar(deName);
  },
  analytics = s_DEGET(de_ExpCloud + '.analytics'),
  launchVersion = 'Launch' + _satellite.buildInfo.buildDate,
  aam = s_DEGET(de_ExpCloud + '.audienceManager'),
  visitorId = s_DEGET(de_ExpCloud + '.visitorService'),
  target = s_DEGET(de_ExpCloud + '.target'),
  verify_version = function (obj) {
    return (obj && obj.info && obj.info.version);
  };

var analyticsVersion = (verify_version(analytics)) ? (analytics.info.version + 'v') : NV,
  aamVersion = (verify_version(aam)) ? (aam.info.version + 'v') : NV,
  visitorIdVersion = (verify_version(visitorId)) ? (visitorId.info.version + 'v') : NV,
  targetVersion = (verify_version(target)) ? (target.info.version + 'v') : NV,


  libraryVersion = analyticsVersion + '|' + launchVersion + '|' + aamVersion + '|' + visitorIdVersion + '|' + targetVersion;

return libraryVersion;
}
      }
    },
    "adobe_digitalData": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  setDigitalData;

setDigitalData = function (digitalData) {
  var
    dataElementName,
    dataElements,
    i, il,

    w = window,
    loc = w.location,
    host = loc.hostname,
    path = loc.pathname,
    copyLocation,
    pageNameLogic;

  // copy location
  copyLocation = _satellite.getVar('adobe_copyLocation');

  //pagename/parseQueryParams logic
  pageNameLogic = _satellite.getVar('adobe_pageNameLogic');
  //parseQueryParams = _satellite.getVar('adobe_parseQueryParams');

  // mapping of data elements
  // Note: The order of this array is important because some data elements 
  // depend on   other data elements being set first.  Like 
  // digitalData.previousPage depends on digitalData.page being set first.
  dataElements = [

    // digitalData.page
    //--------------------------------------------------------------------------
    // 'digitalData.page.pageInfo.pageName',
    // 'digitalData.page.pageInfo.location',
    'digitalData.page.pageInfo.timeParting',
    // 'digitalData.page.pageInfo.queryParameters',
    // 'digitalData.page.topFrameInfo.pageName',
    'digitalData.diagnostic.page.aemImplementation',

    // digitalData.previousPage
    //--------------------------------------------------------------------------
    // 'digitalData.previousPage.pageInfo.pageName',
    'digitalData.previousPage.pageInfo.percentPageViewed',

    // digitalData.adobe
    //--------------------------------------------------------------------------
    'digitalData.adobe.experienceCloud.analytics',
    'digitalData.adobe.experienceCloud.audienceManager',
    'digitalData.adobe.experienceCloud.visitorService',
    'digitalData.adobe.experienceCloud.target',
    'digitalData.adobe.experienceCloud.libraryVersions',

    // digitalData.primaryUser
    //--------------------------------------------------------------------------
    'digitalData.primaryUser.primaryProfile.profileInfo',

    // digitalData.organization.ecid
    'digitalData.organization.ecid',

    // digitalData.campaign
    //--------------------------------------------------------------------------
    'digitalData.campaign.external.primary',
    'digitalData.campaign.onsite.salesforce',
    'digitalData.campaign.onsite.cgen',
    'digitalData.campaign.internal.salesforce',
    'digitalData.campaign.external.social',

    // digitalData.channel
    //--------------------------------------------------------------------------
    'digitalData.channel',

    // digitalData.organization.demandbase
    //--------------------------------------------------------------------------
    'digitalData.organization.demandbase',
    //    'digitalData.organization.ecp',

    // digitalData.appLauncher
    //--------------------------------------------------------------------------
    'digitalData.appLauncher',

    // digitalData.nglParams
    //--------------------------------------------------------------------------  
    'digitalData.nglParams',

    // digitalData.app.appInfo.appCtxId
    //--------------------------------------------------------------------------  
    //'digitalData.app.appInfo.appCtxId',

    // digitalData.app.appInfo.campaignId
    //--------------------------------------------------------------------------  
    'digitalData.app.appInfo.campaignId',

    // digitalData.organization.dnb
    //--------------------------------------------------------------------------  
    //'digitalData.organization.dnb',

    // digitalData.evidon.notice.consentIsGiven
    //--------------------------------------------------------------------------  
    'digitalData.evidon.notice.consentIsGiven',
    
    // digitalData.OptanonConsent
    //--------------------------------------------------------------------------  
    'digitalData.OptanonConsent'

  ];


  // loop through each of the data elements in the list and try to set them if we 
  // are supposed to
  for (i = 0, il = dataElements.length; i < il; i++) {

    // get the dataElement details
    dataElementName = dataElements[i];

    // set the data layer property
    // checks if values are already set so we catch any that are only set once.
    if (typeof window.digitalData._get(dataElementName) !== 'undefined') {
      digitalData._set(dataElementName, window.digitalData._get(dataElementName));
    } else {
      digitalData._set(dataElementName, _satellite.getVar(dataElementName));
    }
  }

  // digitalData.initialPage.pageInfo.location
  //-----------------------------------
  // default it if we haven't set anything yet
  if (!digitalData._get('initialPage.pageInfo.location')) {
    digitalData._set('initialPage.pageInfo.location', copyLocation(w));
  }

  // digitalData.page.pageInfo.location
  //-----------------------------------
  digitalData._set(
    'page.pageInfo.location',
    digitalData._get('initialPage.pageInfo.location')
  );

  // digitalData.page.pageInfo.pageName
  //-----------------------------------
  digitalData._set(
    'page.pageInfo.pageName',
    pageNameLogic(digitalData._get('page.pageInfo.location'))
  );

  w.s.pageName= pageNameLogic(digitalData._get('page.pageInfo.location'));

  // digitalData.page.topFrameInfo.location
  //---------------------------------------
  if (!digitalData._get('initialPage.topFrameInfo.location')) {
    digitalData._set('initialPage.topFrameInfo.location', copyLocation(w.top));
  }

  // digitalData.page.topFrameInfo.location
  //---------------------------------------
  // Note: We do this mainly because it is possible that the page location 
  // may have changed in the time that we started loading launch async and 
  // when it finishs loading.  initialPage is captured before launch loads.
  digitalData._set(
    'page.topFrameInfo.location',
    // can come from either snapshot or digitalData, it doesn't matter
    digitalData._get('initialPage.topFrameInfo.location')
  );
  // digitalData.page.topFrameInfo.pageName
  //---------------------------------------
  digitalData._set(
    'page.topFrameInfo.pageName',
    pageNameLogic(digitalData._get('page.topFrameInfo.location'))
  );

  // digitalData.previousPage.pageInfo.pageName
  //-------------------------------------------
  // if I am to top frame
  if (w === w.top) {
    // get the previous pageName from the cookie
    digitalData._set(
      'previousPage.pageInfo.pageName',
      _satellite.cookie.get('gpv')
    );
  }

  //SUSI
  //-----------------------------------------
  if (digitalData._get('digitalData.page.pageInfo.siteSection') === 'IMS') {
    digitalData._delete('digitalData.page.pageInfo.puser');
  }
  
  //trim the length of the follow fields if they are greater then 400 characters
  dataElements = [
    'digitalData.initialPage.pageInfo.location.href',
    'digitalData.initialPage.pageInfo.location.search',
    'digitalData.initialPage.topFrameInfo.location.href',
    'digitalData.initialPage.topFrameInfo.location.search',
    'digitalData.page.pageInfo.location.href',
    'digitalData.page.pageInfo.location.search',
    'digitalData.page.topFrameInfo.location.href',
    'digitalData.page.topFrameInfo.location.search'
  ];

  // loop through each of the data elements in the list and try to set them if we 
  // are supposed to
  for (i = 0, il = dataElements.length; i < il; i++) {
    // get the dataElement details
    dataElementName = dataElements[i];
    // set the data layer property
    // checks if values are already set so we catch any that are only set once.
    if(digitalData._get(dataElementName).length > 400)
      digitalData._set(
        dataElementName,
        digitalData._get(dataElementName).substr(0,400)
      );
  }
  //if(host === 'documentcloud.adobe.com' || host.indexOf('.acrobat.com') !== -1){
  //_satellite.getVar('remove_url_parameters');
  //}

};
return setDigitalData;
}
      }
    },
    "aep_eventMergeID": {
      "modulePath": "adobe-alloy/dist/lib/dataElements/eventMergeId/index.js",
      "settings": {
        "cacheId": "dbbaafd7-c845-4031-81b6-5691c062ec79"
      }
    },
    "aep_interactions": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
if(event && event.detail && event.detail.digitalData && event.detail.digitalData._get('primaryEvent.eventInfo.interaction.click')){
  return event.detail.digitalData._get('primaryEvent.eventInfo.interaction.click');
}
}
      }
    },
    "adobe_dynamicValue": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  dynamicValue;
dynamicValue = function (passedValue) {
  if (passedValue.indexOf('##') != -1)
  {
    var finalselector, datafrom, dataident, newvalue = '';
    datafrom = passedValue.split('##')[1];
    if(typeof passedValue.split('##')[2] !== 'undefined')
      dataident = passedValue.split('##')[2];
    else
      datafrom='invalid';
    if( datafrom == 'da' && typeof passedValue.split('##')[3] !== 'undefined')
      finalselector = passedValue.split('##')[3];
    else
      datafrom='invalid';
    if(['dl','da','text'].includes(datafrom)){
      switch(datafrom){
        case 'dl':
          if(window.digitalData._get(dataident) !== 'undefined')
            newvalue = window.digitalData._get(dataident);
          else
            newvalue = 'invalid';
          break;
        case 'da':
          if(document.querySelector(finalselector) && document.querySelector(finalselector).getAttribute(dataident))
            newvalue = document.querySelector(finalselector).getAttribute(dataident);
          else
            newvalue = 'invalid';
          break;
        case 'text':
          if(document.querySelector(finalselector))
            newvalue = document.querySelector(dataident).innerText.trim();
          else
            newvalue = 'invalid';          
          break;
      }
    }
    else
      newvalue = 'invalid';
    passedValue = passedValue.replace(/##.*##/, newvalue);
  }
  return passedValue;
};
return dynamicValue;
}
      }
    },
    "leadForensic_enable": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var check = false,
  path = window.location.pathname;
if (path.search(/\/(uk|africa|gr_en|be_nl|be_fr|be_en|cz|cis_en|cy_en|dk|de|ee|es|fr|ie|il_en|it|lv|lt|lu_de|lu_en|lu_fr|hu|mt|mena_en|nl|no|at|pl|pt|ro|ch_de|si|sk|ch_fr|fi|se|ch_it|tr|bg|ru|cis_ru|ua|mena_ar|il_he)\//) !== -1) {
  if ((path.search(/\/(creativecloud|education).html/) !== -1) || (path.search(/\/education/) !== -1) ||
    (path.search(/\/(creativecloud|products|education)\/(business|photoshop|premiere|illustrator|indesign|buy|schools|institutions)\/?(teams|education|students)?\/?(plans|features|deploy-and-manage)?(.html)/) !== -1)) {

    check = true;
  }

}
return check;
}
      }
    },
    "preOptIn": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var consent = {
  'aa': true,
  'aam': true,
  'adcloud': true,
  'campaign': true,
  'ecid': true,
  'livefyre': true,
  'mediaaa': true,
  'target': true
};

return consent;
}
      }
    },
    "digitalData.fbViewContent": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  name = 'digitalData.fbViewContent',
  loc = window.location,
  promise,
  unresolved;

// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
if (promise) {
  return promise;
}

// else, create the promise...

unresolved = {
  contentInfo: 'unknown'
};

promise = new Promise(function (resolve) {
  var
    pageNameLogic = _satellite.getVar('adobe_pageNameLogic'),
    pageName = pageNameLogic(loc),
    planType = '';

  if (pageName === 'adobe.com:creativecloud:plans') {
    if (_satellite._getQueryParam('single_app') && _satellite._getQueryParam('plan') === 'individual') {
      planType = _satellite._getQueryParam('single_app');
    } else if (_satellite._getQueryParam('plan')) {
      planType = _satellite._getQueryParam('plan');
    }
  }

  _satellite._request({
    method: 'GET',
    url: 'https://adobeioruntime.net/api/v1/web/14257_66870/default/fbContent?pageName=' + encodeURIComponent(pageName) + '&planType=' + planType,
  })
  .then(function (response) {

    // assign
    if (
      response &&
        response.data
    ) {
      resolve(response.data);
    }
  })
  .catch(function () {
    return unresolved;
  });
  
});

promise.unresolved = unresolved;

// assign the promise
_satellite._promises[name] = promise;

return promise;
}
      }
    },
    "mbox_parameter_categoryId": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var	host = window.location.hostname,
	category = '';
if (host.indexOf('blog.marketo.com') !== -1) {
	if (document.querySelector("meta[property='article:section']") && (document.querySelector("meta[property='article:section']").getAttribute('content') != null || undefined) ) {
	  category = document.querySelector("meta[property='article:section']").getAttribute('content')
	}
	return category;
}
}
      }
    },
    "digitalData.evidon.notice.consentIsGiven": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var
  w = window,
  name = 'digitalData.evidon.notice.consentIsGiven',
  promise,
  unresolved = false;

// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
if (promise) {
  return promise;
}

promise = new Promise(function (resolve) {

  // if consent is already given, just resolve
  if (_satellite.getVar('isConsentGiven')) {
    resolve(true);

  // otherwise, wait until the PrivacyConsent event fires and consent is given
  } else {
    w.addEventListener('adobePrivacy:PrivacyConsent', function () {
      resolve(true);
    });
  }

  // make sure we don't wait for longer than 5 seconds to resolve this promise
  setTimeout(function () {
    resolve(unresolved);
  }, 5000);

});

// cache it
_satellite._promises[name] = promise;

promise.unresolved = unresolved;

return promise;
}
      }
    },
    "enable_performanceCookie": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  consent = false,
  oneTc = _satellite.cookie.get('OptanonConsent'),
  checkPerformance = function () {
    if (oneTc.indexOf('C0002:1') !== -1) {
      return true;
    }
    return false;
  },
  OptanonChoice = _satellite.cookie.get('OptanonChoice');

//If Evidon cookie present or one trust not present trigger everything
if (_satellite.getVar('isConsentGiven') || !oneTc || _satellite.getVar('ignoreConsent')) {
  consent = true;
}

//check for rejection/accept/custom
else if (OptanonChoice) {
  if (OptanonChoice === '1') {
    consent = true;
  }
  if (OptanonChoice === '2' || OptanonChoice === '3') {
    consent = checkPerformance();
  }
}

//if One trust cookie exist and final check
else {
  if (oneTc) {
    //check for first load/reload and trigger
    if (checkPerformance() || oneTc.indexOf('interactionCount=0') !== -1 || oneTc.indexOf('interactionCount=1') !== -1) {
      consent = true;
    }
  }
}

return consent;
}
      }
    },
    "adobe_aec_pages": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var aec = false,
  w = window,
  loc = w.location,
  h = loc.hostname.toLowerCase(),
  p = loc.pathname;



if (h.indexOf('adobe.com') !== -1 &&
  (p.indexOf('/analytics') !== -1 ||
    p.indexOf('/advertising/') !== -1 ||
    p.indexOf('/marketing') !== -1 ||
    p.indexOf('/analytics-cloud') !== -1 ||
    p.indexOf('/marketing-cloud') !== -1 ||
    p.indexOf('/what-is-adobe-experience-cloud') !== -1 ||
    p.indexOf('/experience-cloud') !== -1 ||
    p.indexOf('/insights') !== -1 ||
    p.indexOf('/commerce') !== -1 ||
    p.indexOf('/data-analytics-cloud') !== -1
  )
) {
  aec = true;
}

return aec;

}
      }
    },
    "thirdParty_demandBase_r2c831N7": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window.location,
  hostname = w.hostname,
  pathname = w.pathname,
  hostnameIndex = _satellite.getVar('thirdPartyTags_allowedDomains') || -1,
  geo = digitalData.page.pageInfo.geoRegion || '',
  isAcrobatTrue = false;

var GeoRegEx = new RegExp(/\/(jp|de|fr|uk|ca|au|nz|dk|es|fi|it|nl|no|se)\//);
// var GeoRegEx = new RegExp(/\/(us\/en)\//); If applicable only to us/en/ pages
if ((hostnameIndex == 1 && (GeoRegEx.test(pathname) || geo == 'US') &&
    (pathname === '/pricing/business-pricing.html' || // Added from earlier list
      pathname.indexOf('/documents/') !== -1 || // Added from earlier list
      pathname.indexOf('/sign.html') !== -1 ||
      pathname.indexOf('/uk/sign/use-cases/legal.html') !== -1 ||
      pathname.indexOf('/uk/sign/use-cases.html') !== -1 ||
      pathname.indexOf('/why-adobe.html') !== -1 ||
      pathname.indexOf('/request-form.html') !== -1 ||
      pathname.indexOf('/acrobat/e-sign-pdf-files.html') !== -1 ||
      pathname.indexOf('/acrobat/how-to/electronic-signatures-online-e-signatures.html') !== -1 ||
      pathname.indexOf('/acrobat/send-for-signature.html') !== -1 ||
      pathname.indexOf('/acrobat/contact.html') !== -1 ||
      pathname.indexOf('/acrobat/contact/contact-thankyou.html') !== -1 ||
      pathname.indexOf('/sign/use-cases/human-resources.html') !== -1 ||
      pathname.indexOf('/sign/use-cases/procurement.html') !== -1 ||
      pathname.indexOf('/sign/use-cases/sales.html') !== -1 ||
      pathname.indexOf('/sign/pricing/plans.html') !== -1 ||
      pathname.indexOf('/sign/pricing/compare-plans.html') !== -1 ||
      pathname.indexOf('/sign/contact.html') !== -1 ||
      pathname.indexOf('/sign/contact/contact-thankyou.html') !== -1 ||
      pathname.indexOf('/sign/free-trial-global.html') !== -1 ||
      pathname.indexOf('/sign/free-trial-global/registration-thankyou.html') !== -1 ||
      pathname.indexOf('/sign/free-trial-global/salesforce.html') !== -1 ||
      pathname.indexOf('/sign/free-trial-global/salesforce-thankyou.html') !== -1 ||
      pathname.indexOf('/sign/capabilities/sign-approve.html') !== -1 ||
      pathname.indexOf('/sign/capabilities/sign-send-documents.html') !== -1 ||
      pathname.indexOf('/sign/capabilities/track-manage-documents.html') !== -1 ||
      pathname.indexOf('/why-adobe/about-adobe-pdf.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/salesforce.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/ariba.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/apttus.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/microsoft-dynamic-crm.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/microsoft-sharepoint.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/workday.html') !== -1 ||
      pathname.indexOf('/why-adobe/integrations/xero.html') !== -1 ||
      pathname.indexOf('/why-adobe/it-resources.html') !== -1)
  )) {
  isAcrobatTrue = true;
} else if (hostname === 'landing.adobe.com' &&
  (pathname === '/en/na/products/echosign/61511-free-sign.html' || // Added from earlier list
    pathname === '/de/de/products/echosign/61511-free-sign.html' || // Added from earlier list
    pathname === '/fr/fr/products/echosign/61511-free-sign.html' || // Added from earlier list
    pathname === '/jp/ja/products/echosign/61511-free-sign.html' || // Added from earlier list
    pathname === '/br/pt/products/echosign/61511-free-sign.html') // Added from earlier list
) {
  isAcrobatTrue = true;
} else if (hostname === 'www.adobe.com' &&
  (pathname === '/products/coldfusion/download-trial/get-started.html') // ENB- 3123
) {
  isAcrobatTrue = true;
} else if (hostname === 'blog.adobe.com') // ENB- 3583
{
  isAcrobatTrue = true;
}

return isAcrobatTrue;
}
      }
    },
    "isSite_AdobeDotCom": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var host = window.location.hostname.toLowerCase(),
  is = false,
  index = function(str, substr) {
    return str.indexOf(substr) !== -1;
  };
var hostnames = [
  'www.adobe.com',
  'www.stage.adobe.com',
  'www.stage2.adobe.com',
  'www.qa01.adobe.com',
  'www.qa02.adobe.com',
  'www.qa03.adobe.com',
  'www.qa04.adobe.com',
  'www.qa05.adobe.com',
  'www.dev01.adobe.com',
  'www.dev02.adobe.com',
  'www.dev03.adobe.com',
  'www.dev04.adobe.com'
];

for (var i = 0; i < hostnames.length; i++) {
  if (index(host, hostnames[i])) {
    is = true;
  }
}
return is;
}
      }
    },
    "adobe_pageNameLogic": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
var
  pageNameLogic;

pageNameLogic = function (l) {

  // default it to something if it is empty
  l = l || window.location;

  var
    i, il,
    pageName = '',
    d = document,
    title = d.title,
    pathname = l.pathname,
    hostname = l.hostname.toLowerCase(),
    pathnameTemp = '',
    pathnamePiece = '',
    pathnameTempSplit = [],
    hostnameTemp = '',
    fileExtensions = [
      '.aspx',
      '.php',
      '.html'
    ],
    countryUrls = _satellite.getVar('adobe_urlRegions'),
    d_host = digitalData._get('page.pageInfo.location.hostname'),
    d_site = digitalData._get('page.pageInfo.siteSection'),
    d_pageName = digitalData._get('page.pageInfo.pageName'),
    d_geo = digitalData._get('page.pageInfo.geoRegion'),
    d_template = digitalData._get('page.pageInfo.template');




  //----------------------------------------------------------------------------
  // pageName normalization
  //----------------------------------------------------------------------------
  if (title.indexOf('page cannot be found') !== -1) {
    pageName = '';
  } else {
    pathnameTemp = pathname;
    hostnameTemp = hostname;

    //--------------------------------------------------------------------------
    // Hostname
    //--------------------------------------------------------------------------
    // replace www. in the hostname
    hostnameTemp = hostnameTemp.replace('www.', '');


    //--------------------------------------------------------------------------
    // Pathname
    //--------------------------------------------------------------------------
    // replace common file extensions
    for (i = 0, il = fileExtensions.length; i < il; i++) {
      pathnameTemp = pathnameTemp.replace(fileExtensions[i], '');
    }

    // remove all empty strings from pathname
    // (i.e. ...adobe.com//products//photoshop.html/ has 4 empty strings in the 
    // pathname)
    pathnameTempSplit = pathnameTemp.split('/');
    for (i = pathnameTempSplit.length - 1; i >= 0; i--) {
      pathnamePiece = pathnameTempSplit[i];
      if (pathnamePiece === '') {
        pathnameTempSplit.splice(i, 1);
      }
    }

    // replace region from path
    // we do it this way to ensure that it only occurs in the beginning of 
    // the string
    var tempPath = [];
    for (i = 0; i < pathnameTempSplit.length; i++) {
      if (countryUrls[pathnameTempSplit[i].toLowerCase()]) {
        tempPath.push(pathnameTempSplit[i]);
      }
    }
    pathnameTempSplit = pathnameTempSplit.filter(function (val) {
      return tempPath.indexOf(val) == -1;
    });

    // join the path together with colons
    pathnameTemp = pathnameTempSplit.join(':');
    //--------------------------------------------------------------------------
    // All together now
    //--------------------------------------------------------------------------
    pageName = hostnameTemp + (pathnameTemp === '' ? '' : (':' + pathnameTemp));
  }
  if (hostname === 'creativecloud.adobe.com' && pageName.indexOf(':cc:discover') !== -1) {
    pageName = pageName.replace(':cc:discover', ':discover');
  }
  if (
    (d_site && d_site.indexOf('adminconsole.adobe.com') !== -1) ||
    d_site === 'webApp:photoshop.adobe.com' ||
    d_site === 'IMS' ||
    d_site === 'InApp:NGL' ||
    d_site === 'echocdn.com' ||
    (d_site && d_site.indexOf('Community:') !== -1) ||
    d_template === 'AdobeSymposiumLiveStream2019' ||
    (d_pageName && d_pageName.indexOf('adobe.com:mini-plans') !== -1 && d_pageName.indexOf(':buy') !== -1) ||
    (d_pageName && d_pageName.indexOf('adobe.com:creativecloud:Plans') !== -1 && d_pageName.indexOf('Modal') !== -1) ||
    (d_site && d_site.indexOf('adobe.io:apis:') !== -1) ||
    (d_host && d_host === 'app.adobemaxmural.com') ||
    (d_host && (d_host === 'spark.adobe.com' || d_host.indexOf('express.adobe.com') !== -1) && d_pageName)
  ) {
    return d_pageName;
  } else if (d_site === 'account.adobe.com' || d_site === 'plan.adobe.com') {
    var
      AMLogic = _satellite.getVar('adobe_AM_pageNameLogic');
    return AMLogic(pageName);
  } else if (hostname && hostname.indexOf('marketo.com') !== -1 && d_geo && pageName && pageName.indexOf(d_geo) !== -1) {

    return pageName.replace(d_geo + '.', '');
  } else {
    return pageName;
  }
};

return pageNameLogic;
}
      }
    },
    "marketingCloudServer": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  w = window,
  search = w.location.search,
  userAgent = w.navigator.userAgent,
  server = 'stats.adobe.com';

// turn off redirect
if (
  // we this is a test
  (search.indexOf('performance=VisitorAPIParameterTweaks') !== -1) &&
  (
    // if Chrome
    // eslint-disable-next-line no-useless-escape
    /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/.test(userAgent) ||
    // if one of our lighthouse test devices
    userAgent.indexOf('Mozilla/5.0 (iPhone') !== -1
  )
) {
  server = '';
}

return server;

}
      }
    },
    "hasCSP": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  w = window,
  h = w.location.hostname,
  hostnameContains,
  hasCSP = false;

// contains function for minification
hostnameContains = function(string) {
  return h.indexOf(string) !== -1;
};

if (
  // is document cloud
  _satellite.getVar('isDCWeb') ||
  // what is this?
  hostnameContains('.licenses.adobe.com') ||
  // what is this?
  hostnameContains('workflow')
) {
  hasCSP = true;
}

return hasCSP;
}
      }
    },
    "digitalData.adobe.experienceCloud.visitorService": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  info = {},
  visitor = _satellite.getVisitorId();

// get version
if (
  visitor
) {
  info.version = visitor.version;
}

// info
value.info = info;

return value;
}
      }
    },
    "digitalData.marketingTags": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
//marketingTagInfo
var marketingTags = marketingTagInfo,
tags = '';

if (marketingTags && marketingTags != undefined && marketingTags.length > 0) {
  for (var i = 0; i < marketingTags.length; i++) {
    if (i == marketingTags.length - 1) {
      tags += marketingTags[i].pixelName + ':' + marketingTags[i].pixelID;
    } else {
      tags += marketingTags[i].pixelName + ':' + marketingTags[i].pixelID + '|';
    }
  }
}
return tags;
}
      }
    },
    "digitalData.page.pageInfo.performanceTiming": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
  UNDEF = 'undefined',
  wp = w.performance || '',
  wpt = wp.timing || '';

if (wpt && wpt.loadEventEnd !== UNDEF &&
  wpt.navigationStart !== UNDEF &&
  wpt.navigationStart > 0) {

  var promise,
    unresolved,
    pT = {},
    preformanceTiming = {};
  promise = new Promise(function (resolve) {

    _satellite._poll(function () {
      var w = window,
      UNDEF = 'undefined',
      performanceTimingLogic = _satellite.getVar('adobe_performanceTimingLogic');
      resolve(performanceTimingLogic([0,10],[0,10]));
    }, [
      function () {
        if (wpt.loadEventEnd > 0)
          return true;
      }
    ], {
      timeout: 8000,
      interval: 250
    });
  });
  promise.unresolved = unresolved;
  return promise;
}
else
  return false;
}
      }
    },
    "ignoreConsent": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return false;
}
      }
    },
    "digitalData.cmo.impression": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var
name = 'digitalData.cmo.impression',
promise,
unresolved;

// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
if (promise) {
return promise;
}

promise = new Promise(function (resolve) {
  setTimeout(function() {
    resolve(_satellite.getVar('digitalData.primaryEvent.eventInfo.interaction.impression'));
}, 2000);
});

promise.unresolved = 'unknown';

// assign the promise
_satellite._promises[name] = promise;

return promise;


}
      }
    },
    "digitalData.nglParams": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */

var appCtxId = '',
  prodNameVersion,
  entryScreen,
  nglFlag,
  nglParam = '';

if (digitalData._get('digitalData.page.pageInfo.siteSection') === 'InApp:NGL') {
  if (digitalData._get('app.appInfo.appCtxId') && digitalData._get('app.appInfo.appCtxId') !== 'context data NA') {

    appCtxId = digitalData._get('app.appInfo.appCtxId').split('_');
    prodNameVersion = appCtxId[0] + '|' + appCtxId[1];
    entryScreen = appCtxId[3];
    nglFlag = appCtxId[2];

  } else if (digitalData._get('app.appInfo.id') && digitalData._get('app.appInfo.version')) {

    prodNameVersion = digitalData._get('app.appInfo.id') + '|' + digitalData._get('app.appInfo.version');
    entryScreen = nglFlag = 'No Value';

  } else {
    prodNameVersion = entryScreen = nglFlag = 'No Value';
  }

  nglParam = (digitalData._get('app.appInfo.allowedDevices') ? digitalData._get('app.appInfo.allowedDevices') : 'No Value') + '|' + prodNameVersion + '|' + (digitalData._get('app.appInfo.license.licenseInfo.entitlementType') ? digitalData._get('app.appInfo.license.licenseInfo.entitlementType') : 'No Value') + '|' + (digitalData._get('app.appInfo.license.licenseInfo.licenseType') ? digitalData._get('app.appInfo.license.licenseInfo.licenseType') : 'No Value') + '|' + (digitalData._get('page.pageInfo.operatingSystem') ? digitalData._get('page.pageInfo.operatingSystem') : 'No Value') + '|' + (digitalData._get('app.appInfo.isProfileForVDI') ? digitalData._get('app.appInfo.isProfileForVDI') : 'No Value') + '|' + (digitalData._get('app.appInfo.license.licenseInfo.daysRemaining') ? (digitalData._get('app.appInfo.license.licenseInfo.daysRemaining') === '0' ? 'zero' : digitalData._get('app.appInfo.license.licenseInfo.daysRemaining')) : 'No Value') + '|' + (entryScreen || 'No Value') + '|' + (nglFlag || 'No Value');
}
return nglParam;
}
      }
    },
    "digitalData.marketingtech.diagnostic.stateChangepromise": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
    var 
  promise,
  unresolved = "promise unresolved";
  promise = new Promise(function (resolve) {
    resolve("promise resolved");
  });
  promise.unresolved = unresolved;
  return promise;
}
      }
    },
    "digitalData.page.pageInfo.language": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
if (digitalData._get('digitalData.page.pageInfo.language')) {

  return digitalData._get('digitalData.page.pageInfo.language').replace('_', '-');

}
}
      }
    },
    "digitalData.page.pageInfo.timeSpentOnPage": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var timeSpent = Math.round(_satellite._timeSpentOnPage.getTimeSpent() / 100) / 10;

// return the time spent on page 
return timeSpent;
}
      }
    },
    "digitalData.primaryEvent.eventInfo.interaction.impression": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  handle,
  wp = w.performance || '',
  wpt = wp.timing || '';
if (document.querySelectorAll('[daa-im], [data-daa-im]').length > 0 || (wp && wpt && wpt.domInteractive === 0)) {
  if(!w.tempImpression){
    w.tempImpression = '';
  }
  handle = function () {
    var lhtext = '',
      x = document.querySelectorAll('[daa-im] [daa-ll],[daa-im][daa-ll],[data-daa-im] [data-daa-ll],[data-daa-im][data-daa-ll]'),
      i,
      QAElement = '',
      lhparent,
      visiblecheck,
      visiblecheckflag = true;
    for (i = 0; i < x.length; i++) {
      visiblecheckflag = true;
      visiblecheck = x[i];
      while (visiblecheck.offsetParent !== null && visiblecheckflag !== false) {
        if (((visiblecheck.offsetParent.offsetWidth <= visiblecheck.offsetLeft || visiblecheck.offsetLeft < -25)) || visiblecheck.style.visibility == 'hidden')
          visiblecheckflag = false;
        visiblecheck = visiblecheck.offsetParent;
      }
      if (x[i].offsetParent !== null && visiblecheckflag === true) {
        lhparent = x[i];
        do {
          if (lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh')) {
            var selectortest = lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh');
            if (selectortest.indexOf('##') != -1)
            {
              var dynamicvalue = _satellite.getVar('adobe_dynamicValue');
              selectortest = dynamicvalue(selectortest);
            }
            if (QAElement !== '' && (lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh'))) {
              QAElement = selectortest + '|' + QAElement;
            }
            else if (lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh')) {
              QAElement = selectortest;
            }
          }
          lhparent = lhparent.parentNode.closest('[daa-lh], [data-daa-lh]');
        } while (lhparent);
        if (QAElement !== '') {
          QAElement = (x[i].getAttribute('daa-ll') || x[i].getAttribute('data-daa-ll')) + '|' + QAElement;
        } else {
          QAElement = (x[i].getAttribute('daa-ll') || x[i].getAttribute('data-daa-ll'));
        }
        QAElement = QAElement.split(',').join('').split('|,').join(',');
        if(_satellite._getQueryParam('clickflag') == 'false'){  
          localStorage.removeItem('clickflag');
        }
        if(_satellite._getQueryParam('clickflag') == 'true' || localStorage.getItem('clickflag') == 'true'){  
           localStorage.setItem('clickflag', true);
          x[i].setAttribute('title', QAElement);
        }
        if (w.tempImpression.indexOf(QAElement) == -1 && lhtext.indexOf(',' + QAElement + ',') == -1)
          lhtext =  ',' + QAElement + lhtext;
        QAElement = '';
      }
    }
    if (lhtext.length > 0) {
      var click_track = lhtext.substring(1).replace('|,', ',');
      return click_track;
    }
  };
  if(w.event && w.event.type && w.event.type === 'beforeunload')
    return handle();
  else
  {
    var
      promise,
      name = 'digitalData.primaryEvent.eventInfo.interaction.impression',
      unresolved = null;
    // a global place to store all our promises that we only want to have 1 of
    _satellite._promises = _satellite._promises || {};

    // get the promise if it already was created
    promise = _satellite._promises[name];

    // if the promise exists, return ''...
    if (promise && !promise.isResolved) {
      return '';
    }
    promise = new Promise(function (resolve) {
      var
        w = window,
        visible = 0,
        visibleyet;
      visibleyet = function () {
        _satellite._poll(function() {
          setTimeout(function(){
            resolve(handle());
          }, 500);            
        }, [
          function () {
            if (visible === 0 && getComputedStyle(document.querySelector('body')).opacity === '1' && document.querySelectorAll('[daa-im] [daa-ll],[daa-im][daa-ll],[data-daa-im] [data-daa-ll],[data-daa-im][data-daa-ll]').length > 0)
              document.querySelectorAll('[daa-im] [daa-ll],[daa-im][daa-ll],[data-daa-im] [data-daa-ll],[data-daa-im][data-daa-ll]').forEach(function (visibleheight) {  if(visible === 0) visible += visibleheight.offsetHeight; });
            if (visible > 0)
              return true;
          }
        ], {
          timeout: 3000,
          interval: 200,
          callOnTimeout: true
        });
      };
      _satellite._poll(function() {
        var wat = w.adobe.target || '',
          wate = wat.event || '';
        if(document.querySelectorAll('[daa-im] [daa-ll],[daa-im][daa-ll],[data-daa-im] [data-daa-ll],[data-daa-im][data-daa-ll]').length > 0 && wp && wpt && wpt.domInteractive > 0)
        {
          if(!w._sophia)
            visibleyet();
          else if(w._sophia && w._sophia.result && w._sophia.result.doesResponseExist)
            visibleyet();
          else
            document.addEventListener('sophia:render:finished', visibleyet());
          setTimeout(function(){
            visibleyet(); 
          }, 2000);
        }
        else
        {
          if(w.ttMETA && w.ttMETA.length >= 1)
          {
            visibleyet();
          }
          else if(_satellite.getVar('target_enable') && wate && w.ttMETA && w.ttMETA.length === 0)
          {
            document.addEventListener(wate.CONTENT_RENDERING_SUCCEEDED, visibleyet());
            document.addEventListener(wate.CONTENT_RENDERING_FAILED, visibleyet());
            document.addEventListener(wate.CONTENT_RENDERING_NO_OFFERS, visibleyet());     
          }
          setTimeout(function(){
            visibleyet(); 
          }, 2000);
        }
      }, [
        function () {
          var wat = w.adobe.target || '';
          if ((wat && wat.event) || (wp && wpt && wpt.domInteractive > 0)) {
            return true;
          }
        }
      ], {
        timeout: 5000,
        interval: 200
      }
      );
    });
    promise.unresolved = unresolved;
    // assign the promise
    _satellite._promises[name] = promise;
    _satellite._promises[name].then(function(value) {
      _satellite._promises[name].isResolved = true;
    });
    return promise;
  }
}
}
      }
    },
    "previousPermissions": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  consent = {
    'aa': false,
    'aam': false,
    'adcloud': false,
    'campaign': false,
    'ecid': false,
    'livefyre': false,
    'mediaaa': false,
    'target': false
  };

//if evidon cookie is present trigger everything...(priority for evidon from us)

if (_satellite.getVar('enable_performanceCookie')) {
  consent = {
    'aa': true,
    'aam': true,
    'adcloud': true,
    'campaign': true,
    'ecid': true,
    'livefyre': true,
    'mediaaa': true,
    'target': true
  };
}
return consent;
}
      }
    },
    "digitalData.campaign.internal.salesforce": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  campaignInfo;

// s_iid
if (_satellite._getQueryParam('s_iid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('s_iid'),
    name: 'Salesforce - s_iid',
    queryParameter: 's_iid',
  };
}

if (
  campaignInfo &&
  campaignInfo.id
) {
  value.campaignInfo = campaignInfo;
}

return value;
}
      }
    },
    "aep_pageLoad_XDM": {
      "cleanText": true,
      "storageDuration": "pageview",
      "modulePath": "adobe-alloy/dist/lib/dataElements/xdmObject/index.js",
      "settings": {
        "data": {
          "web": {
            "webInteraction": {
              "linkClicks": {
                "value": 0
              }
            },
            "webPageDetails": {
              "name": "%web.webPageDetails.name%",
              "server": "sstats.adobe.com",
              "viewName": "%web.webPageDetails.name%",
              "pageViews": {
                "value": 1
              },
              "siteSection": "%digitalData.page.pageInfo.siteSection%"
            }
          },
          "_adobe_corpnew": {
            "digitalData": {
              "page": {
                "pageInfo": {
                  "language": "%digitalData.page.pageInfo.language%",
                  "pageName": "%web.webPageDetails.name%",
                  "siteSection": "%digitalData.page.pageInfo.siteSection%"
                }
              },
              "primaryUser": {
                "primaryProfile": {
                  "profileInfo": {
                    "authState": "%aep_profileInfo.authState%",
                    "profileID": "%aep_profileInfo.profileID%",
                    "entitlementCreativeCloud": "%aep_profileInfo.entitlementCreativeCloud%"
                  }
                }
              },
              "organization": {
                "demandbase": "%aep_demandbase%"
              }
            },
            "marketingPixels": {
              "facebook": {
                "fbp": "%aep_fb%"
              }
            }
          }
        },
        "sandbox": {
          "name": "prod"
        }
      }
    },
    "digitalData.page.pageInfo.siteSection": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
    w = window,
    hostname = w.location.hostname.toLowerCase(),
    siteSection = digitalData._get('digitalData.page.pageInfo.siteSection');

if (siteSection && siteSection === document.title ) {
    siteSection = hostname.replace('www.', '');
}
return siteSection;

}
      }
    },
    "digitalData.campaign.external.primary": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  campaignInfo;

// sdid
if (_satellite._getQueryParam('sdid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('sdid'),
    name: 'CGen - sdid',
    queryParameter: 'sdid',
  };

// trackingid
} else if (_satellite._getQueryParam('trackingid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('trackingid'),
    name: 'CGen - trackingid',
    queryParameter: 'trackingid',
  };

// s_cid
} else if (_satellite._getQueryParam('s_cid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('s_cid'),
    name: 'Salesforce - s_cid',
    queryParameter: 's_cid',
  };

// s_rtid
} else if (_satellite._getQueryParam('s_rtid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('s_rtid'),
    name: 'Salesforce - s_rtid',
    queryParameter: 's_rtid',
  };
}

// if eVar6 is not '' AND the value of eVar6 is not the same as the cookie value of s_a_campaign
// then return eVar6
// otherwise return ''
if (
  campaignInfo &&
  campaignInfo.id &&
  _satellite._getValOnce(campaignInfo.id, 's_a_campaign', 0, 0, _satellite._getDomain())
) {
  value.campaignInfo = campaignInfo;
}

return value;
}
      }
    },
    "aep_eventName": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* eslint-disable no-undef */
//Only AEC pages
if (_satellite.getVar('adobe_aec_pages') && !digitalData._get('primaryEvent.eventInfo.eventName') && (event && event.detail && event.detail.digitalData && event.detail.digitalData.event && event.detail.digitalData.event.length > 0)) {
  return event.detail.digitalData._get('event[0].eventInfo.eventName');
}


//events with spanshot
else if(event && event.detail && event.detail.digitalData && event.detail.digitalData._get('primaryEvent.eventInfo.eventName')){
  return event.detail.digitalData._get('primaryEvent.eventInfo.eventName');
}
 
//Normal event calls
else if (digitalData._get('primaryEvent.eventInfo.eventName')){
  return digitalData._get('primaryEvent.eventInfo.eventName');
}

//Interaction calls
else if(event && event.detail && event.detail.digitalData && event.detail.digitalData._get('primaryEvent.eventInfo.interaction.click')){
  return event.detail.digitalData._get('primaryEvent.eventInfo.interaction.click');
}

else return '';
  
}
      }
    },
    "digitalData.channel": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  channel = {},
  channelInfo = {};

// mv
if (_satellite._getQueryParam('mv')) {
  channelInfo.marketingVehicle = _satellite._getQueryParam('mv');
}

// mv2
if (_satellite._getQueryParam('mv2')) {
  channelInfo.marketingVehicleDetail = _satellite._getQueryParam('mv2');
}

if (
  channelInfo &&
  channelInfo.marketingVehicle
) {
  channel.channelInfo = channelInfo;

  // set the primary (digitalData.channel.primary)
  value.primary = channel;

  // add it to the list (digitalData.channel.list[n])
  value.list = [];
  value.list.push(channel);
}

return value;
}
      }
    },
    "adobe_aec_products": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
  loc = w.location,
  path = loc.pathname,
  host = loc.hostname,
  ecProducts = {
    'adobe-advertising-cloud':'advertising-cloud',
    'advertising-cloud':'advertising-cloud',
    'adobe-analytics': 'adobe-analytics',
    'analytics': 'adobe-analytics',
    'target': 'adobe-target',
    'primetime': 'Adobe Primetime',
    'audience-manager': 'Adobe AudienceManager',
    'media-optimizer': 'media-optimizer',
    'campaign': 'campaign',
    'experience-manager': 'web-experience-management',
    'magento': 'magento',
    'social': 'Adobe Social'
  },
  pathSplit = path.split('/'),
  productStr = '';

for(i=0;i<pathSplit.length;i++){
  pathSplit[i] = pathSplit[i].replace('.html','');
  if(ecProducts[pathSplit[i]]){
    productStr = ';'+ecProducts[pathSplit[i]];
  }
}

return productStr;
}
      }
    },
    "adobe_linkInternalFilters": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return [
  'acrobat.com',
  'acrobatclub.com',
  'acrobatusers.com',
  'adobe-createnow.jp',
  'adobe-creativity.com',
  'adobe-designforimpact.com',
  'adobe-digital-marketing.com',
  'adobe-edu.ru',
  'adobe-education.com',
  'adobe-eseminars.de',
  'adobe-events-france.com',
  'adobe-html5.jp',
  'adobe-max.com',
  'adobe-mobile.co.uk',
  'adobe-mobile.com',
  'adobe-mobile.de',
  'adobe-mobile.fr',
  'adobe-newsroom.de',
  'adobe-onlineservices.com',
  'adobe-pepe.jp',
  'adobe-promo.jp',
  'adobe-ria.jp',
  'adobe-solutions.de',
  'adobe-target.com',
  // should explicitly identify each TLD?
  'adobe.',
  // not needed since 'adobe.' takes care of it...
  // however I am leaving this in case we refactor
  // 'adobe.events.net.cn',
  'adobeacrobat.com',
  'adobeaemcloud.com',
  'adobeawards.com',
  'adobecc.com',
  'adobeceea.com',
  'adobecoopmdf.com',
  'adobecqcloud.com',
  'adobecqms.net',
  'adobecreate.co.uk',
  'adobecreatenow-apac.com',
  'adobecreativecloud.com',
  'adobecreativesuite.it',
  'adobecs2.com',
  'adobecs3.com',
  'adobedigitalmarketing.co.uk',
  'adobedms.pl',
  'adobeexchange.com',
  'adobeeventsonline.com',
  'adobeformscentral.com',
  'adobeforums.com',
  'adobegeneration.anz.com',
  'adobegeneration.co.uk',
  'adobegeneration.com',
  'adobegov.com',
  'adobegunlugu.com',
  'adobeindia.com',
  'adobekb.com',
  'adobeknowhow.com',
  'adobeku.com',
  'adobeleanprint.com',
  'adobelr.com',
  'adobemarketing.co.uk',
  'adobemarketplace.com',
  'adobeme.com',
  'adobemaxmural.com',
  'adobeparfait.com',
  'adobepartnernews.com',
  'adobeprerelease.com',
  'adoberatingreviews.webqamapps.com',
  'adobeshinethissummer.com',
  'adobestudentlicensing.at',
  'adobestudentlicensing.ch',
  'adobestudentlicensing.de',
  'adobesunbreak.com',
  'adobeawards.net',
  'adobeanalyticspro.com',
  'adobetargetpro.com',
  'adobemarketingpro.com',
  'adobecampaignpro.com',
  'adobemediaoptimizerpro.com',
  'adobeexperiencemanagerpro.com',
  // should explicitly identify each TLD?  
  'adobesystems.',
  'adobetraining.pro',
  'appspot.com',
  'behance.net',
  'businesscatalyst.com',
  'canaladobe.com',
  'ccpsx.com',
  'channelconduit.com',
  'cmo.com',
  'cmoconnect.com',
  'douwriteright.com',
  'dpssummit.com',
  'echosign.com',
  'elements-service.com',
  'flex.org',
  'fotolia.com',
  'fotolia.net',
  'gocreate.pro',
  'hellodigitals.it',
  'ihiwebhost.com',
  'ihidevelopment.com',
  'insideadobesummit.com',
  'jaknapdf.cz',
  'javascript:', // jshint ignore:line
  'lightroomcomp.jp',
  'loveacrobat.co.za',
  'adobeevents.com',
  'mailto:',
  // should explicitly identify each TLD?  
  'macromedia.',
  'mediacenter-adobe.com',
  'mixamo.com',
  'myportfolio.com',
  'adobestock.com',
  'omniture.com',
  'openscreenproject.org',
  'photoshop.com',
  'project1324.com',
  'rhapsodyconcept.com.sg',
  'runaware.com',
  'scene7.com',
  'tel:',
  'typekit.com',
  'withmalala.com',
  'withmalala.org',
  'adobesignaturemoments.com',
  'worldsecuresystems.com',
  //adding magento
  'magento.com',
  //adding marketo
  'marketo.com',
  'adobesymposium2019-in.com',
  'adobecreativetour.hvnln.com',
  '../'
].join(',');
}
      }
    },
    "digitalData.max": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
  wdd = w.digitalData || '',
  wddm = wdd.max || '';

if (wdd && !wddm) {
  var promise,
    unresolved;
  promise = new Promise(function (resolve) {
    _satellite._poll(function () {
      var w = window,
        wdd = w.digitalData;
      resolve(wdd._get('max'));
    }, [
      function () {
        if(wdd._get('max'))
          return true;
      }
    ], {
      timeout: 8000,
      interval: 250
    });
  });
  promise.unresolved = unresolved;
  return promise;
}
else
  return wddm;
}
      }
    },
    "digitalData.page.category": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  name = 'digitalData.page.category',
  loc = window.location,
  promise,
  unresolved;

// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
if (promise) {
  return promise;
}

// else, create the promise...

unresolved = {
  contentInfo: 'unknown'
};

promise = new Promise(function (resolve) {

  _satellite._request({
    method: 'GET',
    url: 'https://14257-contentmetadata.adobeioruntime.net/api/v1/web/content-classification-app-0.0.2/meta-data?url=' + encodeURIComponent(window.location.hostname + window.location.pathname)
  })
  .then(function (response) {

    // assign
    if (
      response &&
        response.data
    ) {
      resolve(response.data);
    }
  })
  .catch(function () {
    return unresolved;
  });
  
});

promise.unresolved = unresolved;

// assign the promise
_satellite._promises[name] = promise;

return promise;
}
      }
    },
    "mbox_parameter_entitlement_cloud": {
      "defaultValue": "",
      "forceLowerCase": true,
      "cleanText": true,
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  w = window,
  entitlement,
  clouds,
  cc,
  dc,
  ec;

if (
  w.feds && 
  w.feds.data && 
  w.feds.data.isLoggedIn && 
  w.feds.data.entitlements
) {
  clouds = w.feds.data.entitlements.clouds;
  cc = clouds.creative_cloud; // values: undefined or true or false
  dc = clouds.document_cloud; // values: undefined or true or false
  ec = clouds.experience_cloud; // values: undefined or true or false

  if (cc && dc && ec) {
    entitlement = 'cc_dc_ec_paid';
  } else if (cc && dc && !ec) {
    entitlement = 'cc_dc_paid';
  } else if (cc && !dc && ec) {
    entitlement = 'cc_ec_paid';
  } else if (!cc && dc && ec) {
    entitlement = 'dc_ec_paid';
  } else if (cc && !dc && !ec) {
    entitlement = 'cc_paid_only';
  } else if (!cc && dc && !ec) {
    entitlement = 'dc_paid_only';
  } else if (!cc && !dc && ec) {
    entitlement = 'ec_paid_only';
  } else {
    entitlement = 'free';
  }
}
else if (
  w.feds && 
  w.feds.data && 
  !w.feds.data.isLoggedIn
) {
  entitlement = 'logged_out';
}
return entitlement;
}
      }
    },
    "pageLoad_ECP": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  promise,
  l = w.location,
  h,
  p,
  hostnameContains,
  pathnameContains,
  abort = true;

// parameter or default to location.hostname
h = l.hostname;
p = l.pathname;
// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function(string){
  return p.indexOf(string) !== -1;
};

if(hostnameContains('documentcloud.adobe.com') || 
  (hostnameContains('workflow') && hostnameContains('.licenses.adobe.com')) || 
  hostnameContains('.acrobat.com') || hostnameContains('.services.adobe.com')){
  abort = false;
}

return abort;
}
      }
    },
    "digitalData.organization.demandbase": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  name = 'digitalData.organization.demandbase',
  promise,
  unresolved = {
    demandbaseInfo: {},
    dimensions: '',
    dimensionsCustom: '',
  },
  cookie = _satellite.cookie,
  cookieName = 's_dmdbase';

// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
if (promise) {
  return promise;
}

// if we already set this for the session
if (
  // either we disable demandbase
  _satellite.getVar('demandbase_disable') ||
  // we have already fired demandbase
  cookie.get(cookieName) == '1' ||
  // or the mar_alias localStorage item is present
  (
    localStorage &&
    localStorage.getItem('mar_alias')
  )
) {

  unresolved.alreadysent = true;
  promise = Promise.resolve(unresolved);

  // otherwise wait for the promise and try to retrieve demandbase info
} else {

  promise = new Promise(function (resolve) {
    var
      execute,
      optanonConsent = cookie.get('OptanonConsent'),
      listener;

    // when we know we are okay to call demandbase APIs...
    execute = function () {

      // create API with key
      var demandbase = new w.DemandbaseAPI({
        key: 'e4086fa3ea9d74ac2aae2719a0e5285dc7075d7b'
      });

      // get the data for this IP address
      demandbase.IP.get(function (data) {
        var
          value = {},

          delim = ':',
          nonOrgMatchLabel = '[n/a]',
          dimensions = {
            'demandbase_sid': 12,
            'company_name': 60,
            'industry': 20,
            'sub_industry': 20,
            'employee_range': 10,
            'revenue_range': 12,
            'audience': 20,
            'audience_segment': 20
          },
          dimensionsCustom = {
            'web_site': 50,
            // 'state' : 4,
            //'registry_state': 4,
            'watch_list_ww_dme_namedaccounts': 5,
            'watch_list_AMC_NamedAccts_DE': 5,
            // 'country' : 4,
            //'registry_country_code': 4,
            'watch_list_ww_dma_namedaccounts': 5,
            'b2b': 5,
            'b2c': 5,
            'watch_list_top100': 7,
            'top_design_schools': 5
          },
          dataKey,
          dataSubKey,
          assemble;

        // only continue if we have data
        if (
          !data ||
          !Object.keys(data).length
        ) {
          resolve(unresolved);
          return;
        }

        // set all of the raw data in the data layer
        try {
          value.demandbaseInfo = JSON.parse(JSON.stringify(data));
        } catch (e) {
          // nothing
        }

        // set Marketing Alias in Local Storage
        try {
          if (localStorage) {
            for (var mKey in data) {
              if (data.hasOwnProperty(mKey)) {
                if (mKey === 'marketing_alias') {
                  localStorage.setItem('mar_alias', data[mKey]);
                }
                if (mKey === 'audience') {
                  localStorage.setItem('mar_aud', data[mKey]);
                }
                if (mKey === 'industry') {
                  localStorage.setItem('mar_ind', data[mKey]);
                }
              }
            }
          }
        } catch (e) {
          // nothing
        }

        // flatten data
        // NOTE: This is why we have to make a copy in demandbaseInfo
        for (dataKey in data) {
          if (data.hasOwnProperty(dataKey)) {
            if (
              typeof data[dataKey] === 'object' &&
              data[dataKey] !== null
            ) {
              for (dataSubKey in data[dataKey]) {
                if (data[dataKey].hasOwnProperty(dataSubKey)) {
                  data[dataKey + '_' + dataSubKey] = data[dataKey][dataSubKey];
                }
              }
              delete data[dataKey];
            }
          }
        }

        // create function for assembling it all together
        assemble = function (dimensions) {
          var
            tempArray = [],
            name,
            val,
            max,
            assembled;

          // compact to string
          for (name in dimensions) {
            if (!dimensions.hasOwnProperty(name)) {
              continue;
            }

            max = dimensions[name] || 20;

            if (name) {
              if (data[name]) {
                val = data[name];
                val = val.toString();
                val = val.replace(delim, ' ');
                tempArray.push(val.substring(0, max));
              } else if (data[name] === false) {
                tempArray.push('false');
              } else {
                tempArray.push(nonOrgMatchLabel);
              }
            }
          }

          // cookie value
          assembled = tempArray.join(delim);

          return assembled;
        };

        // dimensions
        value.dimensions = assemble(dimensions);

        // dimensionsCustom
        value.dimensionsCustom = assemble(dimensionsCustom);

        // set cookie
        cookie.set(cookieName, '1', {
          domain: _satellite._getDomain()
        });

        // return
        resolve(value);
      });
    };

    // if it already ran
    if (
       _satellite.getVar('ignoreConsent') ||
      (
        optanonConsent &&
        optanonConsent.indexOf('C0002:1') !== -1
      )
    ) {
      execute();

      // if it hasn't run yet, wait for the event to fire
    } else {
      var privacyExe = false;
      // create listener
      listener = function () {
        if (!privacyExe) {
          if (
             _satellite.getVar('ignoreConsent') ||
            (w.OnetrustActiveGroups &&
              w.OnetrustActiveGroups.indexOf(',C0002,') !== -1)
          ) {
            execute();
          } else {
            resolve(unresolved);
          }
          privacyExe = true;
          // remove listeners
          // NOTE: This is important so that it doesn't execute AFTER we have  
          // already resolved this promise.  If we did, that would cause the 
          // s_dmdbase cookie to be set and on the next page we still wouldn't
          // capture demandbase values
          w.removeEventListener('adobePrivacy:PrivacyConsent', listener);
          w.removeEventListener('adobePrivacy:PrivacyCustom', listener);
        }
      };
      // wait for either the "enable all"
      w.addEventListener('adobePrivacy:PrivacyConsent', listener);
      // or wait for the "privacyCustom event"
      w.addEventListener('adobePrivacy:PrivacyCustom', listener);
      // give us some insurance in case the promise never resolves
      setTimeout(function () {
        listener();
      }, 5000);
    }
  });
}

// cache it
_satellite._promises[name] = promise;

promise.unresolved = unresolved;

return promise;
}
      }
    },
    "adobe_AM_pageNameLogic": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
var
  AMpageNameLogic;
AMpageNameLogic = function (pageNameAM) {
  if (digitalData._get('page.pageInfo.pageName'))
    pageNameAM = digitalData._get('page.pageInfo.pageName');
  if (pageNameAM && digitalData._get('page.pageInfo.siteSection') === 'account.adobe.com') {
    if (pageNameAM.indexOf('accounts') == -1) {
      pageNameAM = pageNameAM.replace('account', 'accounts');
    }

    if (pageNameAM.indexOf('accounts.adobe.com:plans:change-plan:review') !== -1) {
      return 'accounts.adobe.com:plans:switch:review';
    }

    if (window.digitalData.accountManagement && window.digitalData.accountManagement.offers && (pageNameAM.indexOf('adobe.com:plans:cancel-plan:retention') !== -1 || pageNameAM.indexOf('adobe.com:plans:cancel-plan:offers') !== -1)) {
      if (window.digitalData.accountManagement.offers[0]) {
        pageNameAM = 'accounts.adobe.com:plans:switch:' + digitalData.accountManagement.offers[0].code;
      }
      return pageNameAM;
    }

    if (pageNameAM.indexOf('adobe.com:plans:cancel-plan:retention') !== -1 || pageNameAM.indexOf('adobe.com:plans:cancel-plan:offers') !== -1) {
      if (digitalData.accountManagement && digitalData.accountManagement.isChatOffered) {
        return 'accounts.adobe.com:plans:switch:AGENT_CHAT';
      }
      else {
        return 'accounts.adobe.com:plans:switch:no_offerShown';
      }
    }


    if (pageNameAM.indexOf('adobe.com:plans:cancel-plan:feedback') !== -1) {
      return 'accounts.adobe.com:plans:cancel-reason';
    }

    if (pageNameAM.indexOf('accounts.adobe.com:plans:cancel-plan:confirmation') !== -1 || pageNameAM.indexOf('accounts.adobe.com:plans:cancel-plan:accept-concession') !== -1 || pageNameAM.indexOf('accounts.adobe.com:plans:change-plan:complete') !== -1 || pageNameAM.indexOf('accounts.adobe.com:plans:plan-benefits-modal') !== -1 || pageNameAM.indexOf('accounts.adobe.com:free-days-modal') !== -1) {
      return 'accounts.adobe.com:plans:switch:complete';
    }
    
    if (pageNameAM.search("account.adobe.com:.*:(cancel-plan|change-plan|orders|edit-payment)$") !== -1) {
      return pageNameAM.replace( /plans:.*:/ , 'plans:');
    }
    
    else {
      return pageNameAM;
    }
  }
  if (pageNameAM && digitalData._get('page.pageInfo.siteSection') === 'plan.adobe.com') {
    if(pageNameAM.indexOf('plan.adobe.com:switch:') !== -1 && pageNameAM.indexOf(':to:') !== -1 ){
      return 'plan.adobe.com:switch:review';
    }
    return pageNameAM;
  }
};
return AMpageNameLogic;
}
      }
    },
    "digitalData.adobe.experienceCloud.dxVisits": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  if (_satellite.getVar('enable_performanceCookie')) {
  var w = window,
    loc = w.location,
    host = loc.hostname,
    path = loc.pathname,
    cookieValue = _satellite.cookie.get('dxHit'),
    index = function(str, substr) {
      return str.indexOf(substr) !== -1;
    },
    setDXCookie = function() {
      var cookieValue = _satellite.cookie.get('dxHit') ? Number(_satellite.cookie.get('dxHit')) + 1 : 1;
      _satellite.cookie.set(
        'dxHit',
        // Set the new value for the cookie
        cookieValue, {
          //expires: expires,
          domain: _satellite._getDomain()
        }
      );
    };

  if ((host === 'business.adobe.com' || host === 'business.stage.adobe.com') || // All pages of this domain
    ((host === 'www.adobe.com' || host === 'www.stage.adobe.com') &&  // only pages that matches below pattern
      path.search(/^\/jp\/offer\/(003258-gartner-mq-dxp2021|003225-forrester-wave-cat2020).html/) !== -1 || // only for Japan region
      path.search(/\/diversity\/strategy\/((employees(\/(employee-networks|benefits))?)|(overview|industry|pipeline|candidates(\/digital-academy)?)).html/) !== -1 //pages for all geo's
    )
  ) {

    if (_satellite.cookie.get('dxHit') == undefined || cookieValue <= '2') {
      setDXCookie();
      return _satellite.cookie.get('dxHit');
    }
  }
  return false;
} else {
  return false;
}
}
      }
    },
    "digitalData.helpx.translatedStatus": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var element1 = document.querySelector('meta[name="pageCreatedAt"]');
var content1 = element1 && element1.getAttribute('content');
var element = document.querySelector('meta[name="translated"]');
var content = element && element.getAttribute('content');

if (content1 == '/content/help/en' && content == 'true') {
  return 'Translated';
}
if (content1 == '/content/help/en' && content == 'false') {
  return 'Untranslated';
}
if (content1 != '/content/help/en' && content == 'false') {
  return 'Original';
}
}
      }
    },
    "remove_url_parameters": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var propertyReset;

propertyReset = function (url, parameter) {
  if (url) {
    var urlparts = url.split('?');
    if (urlparts.length >= 2) {

      var prefix = encodeURIComponent(parameter) + '=';
      var pars = urlparts[1].split(/[&;]/g);

      //reverse iteration as may be destructive
      for (var i = pars.length; i-- > 0;) {
        //idiom for string.startsWith
        if (pars[i].lastIndexOf(prefix, 0) !== -1) {
          pars.splice(i, 1);
        }
      }

      return urlparts[0] + (pars.length > 0 ? '?' + pars.join('&') : '');
    }
  } else {
    return url;
  }
}


return propertyReset;
}
      }
    },
    "target_enable": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  d = document,
  enable = false,
  target,
  search = w.location.search,
  visitorCookie = _satellite.cookie.get('AMCV_9E1005A551ED61CA0A490D45@AdobeOrg'),
  searchContains;

searchContains = function (string) {
  return search.indexOf(string) !== -1;
};

// get ref to target 
target = (
  w.marketingtech &&
  w.marketingtech.adobe &&
  w.marketingtech.adobe.target
);

if (
  // they set a flag that they want to use target
  target &&
  // the opt-out cookie is not present (so we can load Target)
  (
    d.cookie.indexOf('adobe_optout') === -1
  ) &&
  // the user is either not on the first visit, or there are special 
  // circumstances telling us to load target on the first visit anyway
  (
    // it's the latest version of the boostrap file
    digitalData._get('marketingtech.bootstrap.version') >= '0.18.1' ||
    // otherwise it must meet these conditions
    (
      // the user is NOT visiting the site for the very first time
      // NOTE: this is to disable target on the user's first visit to a page
      (
        // we have the visitor cookie
        visitorCookie &&
        // and the ECID has been set to something
        visitorCookie.indexOf('MCMID') !== -1
      ) ||
      // or they are visiting for the first time, but target is required for this 
      // page on the first visit
      // NOTE: the reason for this is because there are campaigns that drive 
      // visitors to this page and they want to target them or add them to 
      // campaigns.
      target.required ||
      // or the search contain any of the following parameters
      (
        searchContains('cmpgn=') ||
        searchContains('promoid=') ||
        searchContains('sdid=') ||
        searchContains('trackingid=')
      )
    )
  )
) {
  enable = true;
} else {
  enable = false;
  
  // remove the style
  var
    style = d.getElementById('at-body-style');
  
  // if the style exists
  if (
    style &&
    style.parentNode
  ) {
    try {
      style.parentNode.removeChild(style);
    } catch (e) {
      // nothing
    }
  }
  
}

return enable;
}
      }
    },
    "adobe_linkDownloadFileTypes": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return [
  'adpp',
  'air',
  'apk',
  'avi',
  'bin',
  'cptx',
  'css',
  'csv',
  'dmg',
  'doc',
  'docx',
  'eps',
  'exe',
  'flv',
  'hqx',
  'jar',
  'jpg',
  'js',
  'm4v',
  'mov',
  'mp3',
  'mp4',
  'mpg',
  'msi',
  'mxp',
  'pdf',
  'png',
  'ppt',
  'pptx',
  'psd',
  'rar',
  'svg',
  'swc',
  'tab',
  'tbz2',
  'txt',
  'vsd',
  'vxd',
  'wav',
  'wma',
  'wmv',
  'xls',
  'xlsx',
  'xml',
  'zip',
  'zxp',
  'url'
].join(',');
}
      }
    },
    "SophiaLogic": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  SophiaLogic;

SophiaLogic= function (snapshot) {
  snapshot = snapshot || digitalData;
  var response=0,
  actionblockid = '',
  campaignid = '',
  containerid = '',
  controlgroupid = '',
  treatmentid = '',
  variationid = '',
  cardid = '',
  surfaceid = '',
  additional = '',
  currentresponse = '',
  completeresponse = '',
  href = snapshot._get("page.pageInfo.location.href"),
  pagehref = href && href.toLowerCase(),
  SR = 'sophiaResponse.fromPage.',
  sug = s.Util.getQueryParam;
  if(sug("campaignid", pagehref))
  {
    actionblockid = sug("actionblockid", pagehref) || '';
    campaignid = sug("campaignid", pagehref) || '';
    containerid = sug("containerid", pagehref) || '';
    controlgroupid = sug("controlgroupid", pagehref) || '';
    treatmentid = sug("treatmentid", pagehref) || '';
    variationid = sug("variationid", pagehref) || '';
    cardid = sug("cardid", pagehref) || '';
    surfaceid =sug("surfaceid", pagehref) || sug("surface", pagehref) || '';
    if(sug("intent", pagehref))
      additional = 'intent-' + sug("intent", pagehref) + '|fromOffer-' + sug("fromoffer", pagehref) + '|toOfferId-' + sug("toofferid", pagehref);
    currentresponse = actionblockid + ':' + campaignid + ':' + containerid + ':' + controlgroupid + ':' + treatmentid + ':' + variationid + ':' + cardid + ':' + surfaceid;
    if(additional !== '')
      currentresponse = currentresponse + ':' + additional;    
    if(currentresponse !== ':::::::')
      completeresponse = currentresponse;
  }
  if(snapshot._get("sophiaResponse.fromPage.campaignId"))
  {
    actionblockid = snapshot._get("sophiaResponse.fromPage.actionBlockId") || '';
    campaignid = snapshot._get("sophiaResponse.fromPage.campaignId") || '';
    containerid = snapshot._get("sophiaResponse.fromPage.containerId")  || '';
    controlgroupid = snapshot._get("sophiaResponse.fromPage.controlGroupId ")  || '';
    treatmentid = snapshot._get("sophiaResponse.fromPage.treatmentId")  || '';
    variationid = snapshot._get("sophiaResponse.fromPage.variationId")  || '';
    cardid = snapshot._get("sophiaResponse.fromPage.cardId")  || '';
    surfaceid = snapshot._get("sophiaResponse.fromPage.surfaceId")  || '';
    currentresponse = actionblockid + ':' + campaignid + ':' + containerid + ':' + controlgroupid + ':' + treatmentid + ':' + variationid + ':' + cardid + ':' + surfaceid;
    if(currentresponse !== ':::::::') {
      if(completeresponse !== '')
        completeresponse = completeresponse + ','; 
      completeresponse = completeresponse + currentresponse;
    }
  }
  if(snapshot._get('sophiaResponse') && snapshot._get('sophiaResponse.'+response)){
    SR = 'sophiaResponse.';
  }
  while (snapshot._get('sophiaResponse') && snapshot._get(SR+response)){
    actionblockid = snapshot._get(SR + response + '.actionBlockId') || snapshot._get(SR + response + '.ActionId') || '';
    campaignid = snapshot._get(SR + response + '.campaignId') || snapshot._get(SR + response + '.CampaignId') || '';
    containerid = snapshot._get(SR + response + '.containerId') || snapshot._get(SR + response + '.ContainerId') || '';
    controlgroupid = snapshot._get(SR + response + '.controlGroupId') || snapshot._get(SR + response + '.ControlGroupId') || '';
    treatmentid = snapshot._get(SR + response + '.treatmentId') || snapshot._get(SR + response + '.TreatmentId') || '';
    variationid = snapshot._get(SR + response + '.variationId') || snapshot._get(SR + response + '.VariationId') || '';
    cardid = snapshot._get(SR + response + '.cardId') || snapshot._get(SR + response + '.CardId') || '';
    surfaceid = snapshot._get(SR + response + '.surfaceId') ||  snapshot._get(SR + response + '.SurfaceId') || '';
    currentresponse = actionblockid + ':' + campaignid + ':' + containerid + ':' + controlgroupid + ':' + treatmentid + ':' + variationid + ':' + cardid + ':' + surfaceid;
    if(currentresponse !== ':::::::') {
      if(completeresponse !== '')
        completeresponse = completeresponse + ','; 
      completeresponse = completeresponse + currentresponse;
    }
    ++response;
  }
  return completeresponse;
}
return SophiaLogic;
}
      }
    },
    "aep_IMSOrgID": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  if(window.location.hostname ==='elearning.adobe.com' || window.location.pathname === '/creativecloud/plans.html'){
 
  return '9E1005A551ED61CA0A490D45@AdobeOrg'
}
}
      }
    },
    "digitalData.adobe.experienceCloud.analytics": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  info = {};

// get version 
if (
  window.s_adobe
) {
  info.version = window.s_adobe.version;
}

// info
value.info = info;

return value;
}
      }
    },
    "digitalData.page.pageInfo.performanceTiming.unload": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
  UNDEF = 'undefined',
  performanceTimingLogic = _satellite.getVar('adobe_performanceTimingLogic');
return performanceTimingLogic([0,15],[0,100]);
}
      }
    },
    "marketingCloudOrganizationID": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return '9E1005A551ED61CA0A490D45@AdobeOrg';
}
      }
    },
    "digitalData.plansPageAttributes.bannerImpression": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true 
*/

if (digitalData._get('digitalData.plansPageAttributes.type') && digitalData._get('digitalData.plansPageAttributes.type').indexOf('mini-Plans') != -1 && digitalData._get('digitalData.plansPageAttributes.banner')) {

  var bannerLength = digitalData.plansPageAttributes.banner.length,
    banner = [];

  for (var i = 0; i < bannerLength; i++) {
    var bannerValue = digitalData.plansPageAttributes.banner[i].bannerInfo;
    banner[i] = 'mini-plans|' + bannerValue.bannerTab + '|' + bannerValue.bannerCard + '|' + bannerValue.bannerPlan + '|' + bannerValue.bannerId + '|' + bannerValue.bannerName;
  }

  banner = banner.join(',');

  digitalData._set('digitalData.plansPageAttributes.bannerImpression', banner);

  return banner;
}


}
      }
    },
    "mbox_parameter_at_property": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var host = window.location.hostname,
  path = window.location.pathname,
  at_property = '';

if (host === 'www.adobe.com' && path.indexOf('/acrobat/reader/') !== -1) { //RGS - Doc Cloud
  at_property = 'a77c9437-77c0-1012-2234-49f047aa80dd';
} else if (host === 'photoshop.adobe.com') { //Photoshop
  at_property = '2bb70f5a-cc1f-79c3-a659-66e4e32dc3fc';
} else if (host === 'spark.adobe.com' || (host.indexOf('adobeprojectm.com') > -1)) { //Spark
  at_property = '60d153f1-513f-3125-b0da-075bcb9a043d';
} else if (host === 'www.behance.net') { //Behance
  at_property = '06c0c8f1-9096-c8ed-f214-aa61717ce417';
} else if (host === 'www.adobe.com' && (path.indexOf('/genuine/') !== -1 || path.indexOf('/documentcloud/genuine/') !== -1)) { //Genuine
  at_property = 'a4c9a339-39b9-06f1-fe19-4ef156446eb2';
} else if (host === 'magento.com' || host === 'info2.magento.com' || host === 'www.marketo.com' || host === 'blog.marketo.com' || host === 'launchpoint.marketo.com' || host === 'de.marketo.com' || host === 'fr.marketo.com' || host === 'uk.marketo.com' || host === 'au.marketo.com' || host === 'es.marketo.com' || host === 'de.blog.marketo.com' || host === 'fr.blog.marketo.com' || host === 'cmo.marketo.com' || host === 'jp.marketo.com' || host === 'bizible.com' ) { //Magento & Marketo
  at_property = 'fa6c1e1d-57b0-eabe-75d7-ee9fed3867a0';
}else if ( (host === 'www.adobe.com' || host === 'helpx.adobe.com' || host === 'business.adobe.com') && ( path.indexOf('/africa/') !== -1 || path.indexOf('/be_en/') !== -1 || path.indexOf('/be_fr/') !== -1 || path.indexOf('/be_nl/') !== -1 || path.indexOf('/cis_en/') !== -1 || path.indexOf('/cy_en/') !== -1 || path.indexOf('/dk/') !== -1 || path.indexOf('/de/') !== -1 || path.indexOf('/ee/') !== -1 || path.indexOf('/es/') !== -1 || path.indexOf('/fr/') !== -1 || path.indexOf('/gr_en/') !== -1 || path.indexOf('/ie/') !== -1 || path.indexOf('/il_en/') !== -1 || path.indexOf('/it/') !== -1 || path.indexOf('/lv/') !== -1 || path.indexOf('/it/') !== -1 || path.indexOf('/lu_de/') !== -1 || path.indexOf('/lu_en/') !== -1 || path.indexOf('/lu_fr/') !== -1 || path.indexOf('/hu/') !== -1 || path.indexOf('/mt/') !== -1 || path.indexOf('/mena_en/') !== -1 || path.indexOf('/nl/') !== -1 || path.indexOf('/no/') !== -1 || path.indexOf('/pl/') !== -1 || path.indexOf('/pt/') !== -1 || path.indexOf('/ro/') !== -1 || path.indexOf('/ch_de/') !== -1 || path.indexOf('/si/') !== -1 || path.indexOf('/sk/') !== -1 || path.indexOf('/ch_fr/') !== -1 || path.indexOf('/fi/') !== -1 || path.indexOf('/se/') !== -1 || path.indexOf('/ch_it/') !== -1 || path.indexOf('/tr/') !== -1 || path.indexOf('/uk/') !== -1 || path.indexOf('/at/') !== -1 || path.indexOf('/cz/') !== -1 || path.indexOf('/bg/') !== -1 || path.indexOf('/ru/') !== -1 || path.indexOf('/cis_ru/') !== -1 || path.indexOf('/ua/') !== -1 || path.indexOf('/il_he/') !== -1 || path.indexOf('/mena_ar/') !== -1 || path.indexOf('/lt/') !== -1 || path.indexOf('/sa_en/') !== -1 || path.indexOf('/ae_en/') !== -1 || path.indexOf('/ae_ar/') !== -1 || path.indexOf('/sa_ar/') !== -1)) {
  at_property = '488edf5f-3cbe-f410-0953-8c0c5c323772'; //EMEA
} else if ( (host === 'www.adobe.com' || host === 'helpx.adobe.com' || host === 'business.adobe.com') && ( path.indexOf('/au/') !== -1 || path.indexOf('/hk_en/') !== -1 || path.indexOf('/in/') !== -1 || path.indexOf('/nz/') !== -1 || path.indexOf('/sea/') !== -1 || path.indexOf('/cn/') !== -1 || path.indexOf('/hk_zh/') !== -1 || path.indexOf('/tw/') !== -1 || path.indexOf('/kr/') !== -1 || path.indexOf('/sg/') !== -1 || path.indexOf('/th_en/') !== -1 || path.indexOf('/th_th/') !== -1)) {
  at_property = '3de509ee-bbc7-58a3-0851-600d1c2e2918'; //APAC
} else if (host === 'solutionpartners.adobe.com' || host === 'solutionpartners.stage.adobe.com') {
  at_property = '98e4a454-ad1c-2094-e03c-6fa76a183e22'; //solution partners
} else if ( (host === 'www.adobe.com' || host === 'helpx.adobe.com' || host === 'business.adobe.com') && ( path.indexOf('/jp/') !== -1)) {
  at_property = 'ba5bc9e8-8fb4-037a-12c8-682384720007'; //JP
} else if ( (host === 'www.adobe.com' || host === 'helpx.adobe.com' || host === 'business.adobe.com') && ( path.indexOf('/br/') !== -1 || path.indexOf('/cl/') !== -1 || path.indexOf('/la/') !== -1 || path.indexOf('/mx/') !== -1)) {
  at_property = '2ad9c850-3ab6-b4d3-2452-2165bfe35925'; //LATAM
} else if (host === 'www.stage.adobe.com' || host === 'stage.ccmui.adobe.com' || host === 'business.stage.adobe.com' || host === 'primary.stock.stage.adobe.com' || host === 'helpx.stage.adobe.com' || host === 'localhost' || host === 'www.net.dev0.be.lan' || host === 'net.s2stagehance.com' ||
          (host.indexOf('acrobat.adobe.com') > -1 && (host.indexOf('stage') > -1 || host.indexOf('con01') > -1)) || host === 'dx-dc-author-prod.acrobat.adobe.com' ||
           host === 'stage.account.adobe.com' || host === 'stage.adminconsole.adobe.com' || host === 'previewusers.echosignawspreview.com' || host === 'stage-launchpoint.marketo.com' || host === 'stage-www.marketo.com' || host === 'stage-edit-www.marketo.com' || host === 'stage-de.marketo.com' || host === 'stage-fr.marketo.com' || host === 'stage-uk.marketo.com' || host === 'stage-au.marketo.com' || host === 'stage-es.marketo.com' || host === 'stage-blog.marketo.com' || host === 'stage-de.blog.marketo.com' || host === 'stage-fr.blog.marketo.com' || host === 'stage-cmo.marketo.com') {
  at_property = 'bc8dfa27-29cc-625c-22ea-f7ccebfc6231'; //stage
}

return at_property;
}
      }
    },
    "audienceManager_enable": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  l = w.location,
  h,
  p,
  hostnameContains,
  pathnameContains;

// parameter or default to location.hostname
h = l.hostname;
p = l.pathname;
// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function(string){
  return p.indexOf(string) !== -1;
};

if (l.search.indexOf('noThirdParty=true') !== -1) {
  return false;
}

// turn off audience manager on the mobile version of adobe.com/mini-plans pages
if (
  hostnameContains('.adobe.com') && 
  pathnameContains('/mini-plans') && 
  !l.href.match(/(\?|\&)web\=1/)
) {
  return false;
}

if (

  // make sure the flag has been set
  w.marketingtech &&
  w.marketingtech.adobe &&
  w.marketingtech.adobe.audienceManager && 

  // if not opted out...
  !_satellite.cookie.get('adobe_optout')
 
) {
  return true;
}

return false;
}
      }
    },
    "aep_profileInfo.entitlementCreativeCloud": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return digitalData._get('digitalData.primaryUser.primaryProfile.profileInfo.entitlementStatusCreativeCloud');
}
      }
    },
    "s.productLogic": {
      "defaultValue": "",
      "forceLowerCase": true,
      "cleanText": true,
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* eslint-disable no-undef */
// s.products
// 
// Syntax:
// "Category;Product;Quantity;Price;eventN=X[|eventN2=X2];eVarN=merch_category[|eVarN2=merch_category2]"

//--------------------------------------------------------------------------
// determine the s.products based on the data layer
//--------------------------------------------------------------------------

var
  productLogic;



productLogic = function (snapshot) {
  var
    products = [],
    items;
  // if we have a data layer object
  if (snapshot) {
    // figure out what items we should be going over
    // first try transaction
    if (snapshot.transaction && snapshot.transaction.item && Array.isArray(snapshot.transaction.item)) {
      items = snapshot.transaction.item;
      // second try cart
    }
    else if (snapshot.cart && snapshot.cart.item && Array.isArray(snapshot.cart.item)) {
      items = snapshot.cart.item;
    }
    // third try primaryProduct
    else if (snapshot.primaryProduct) {
      if (digitalData._get('plansPageAttributes.type') === 'Plans - Reimagine' && !digitalData._get('digitalData.primaryProduct.quantity')) {
        snapshot._set('digitalData.primaryProduct.quantity', digitalData._get('digitalData.primaryProduct.productInfo.quantity'));
      }
      items = [snapshot.primaryProduct];
    }
    // fourth try Product
    else if (snapshot.product && Array.isArray(snapshot.product)) {
      //if plans page update my code
      if (digitalData._get('page.pageInfo.pageName') && digitalData._get('page.pageInfo.pageName').indexOf('plans') !== -1 && digitalData._get('plansPageAttributes.cardProductData')) {
        snapshot.product = Object.values(digitalData._get('plansPageAttributes.cardProductData').reduce(function (unique, o) {
          if (!unique[o.productInfo.sku]) unique[o.productInfo.sku] = o;
          return unique;
        }, {}));

        digitalData.product = snapshot.product;
      }
      items = snapshot.product;
    }
    // otherwise return blank
    else {
      return '';
    }
    // loop through each and build the productsString
    items.forEach(function (item) {
      var
        parts = [];
      // if we have at least the basic information we need, proceed
      if (item && item.productInfo) {
        // 0 = Category
        if (item.category && item.category.primaryCategory) {
          parts[0] = item.category.primaryCategory;
        }
        else {
          parts[0] = '';
        }
        // 1 = Product
        parts[1] =
          // first try sku
          item.productInfo.sku ||

          item.productInfo.offerId ||
          // second try productID
          item.productInfo.productID ||
          // third try productName
          item.productInfo.productName;
        // 2 = Quantity
        if (item.quantity) {
          parts[2] = item.quantity;
        } else {
          parts[2] = '';
        }
        // 3 = Price
        // TODO: consider multiplying the quantity by the basePrice
        // TODO: also consider adding everything up with shipping, taxes, etc.
        if (item.price && item.price.basePrice) {
          parts[3] = item.price.basePrice;
        } else if (item.productInfo && item.productInfo.price) {
          parts[3] = item.productInfo.price;
        }
        else {
          parts[3] = '';
        }
        // 4 = Events
        // TODO: Figure this one out
        // 5 = eVars
        // TODO: Figure this one out

        // join them together and add to products
        products.push(parts.join(';'));
      }
    });
  }
  return products.join(',');
};


return productLogic;

}
      }
    },
    "thirdPartyTags_allowedDomains": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var w = window,
  h = w.location.hostname;
/*DO NOT CHANGE THE KEY::VALUE MAPPING*/
var hostnames = {
  'www.adobe.com': 1,
  'www-author.corp.adobe.com': 1,
  'www-author.stage.corp.adobe.com': 1,
  'www.qa01.adobe.com': 1,
  'www.qa02.adobe.com': 1,
  'www.dev01.adobe.com': 1,
  'www.dev02.adobe.com': 1,
  'www.stage.adobe.com': 1,
  'www.stage2.adobe.com': 1,

  'stage.acrobat.adobe.com': 2,
  'www-stage01.acrobat.adobe.com': 2,
  'acrobat.adobe.com': 2,
  'esign.adobe.com': 2,

  'helpx.adobe.com': 3,
  'helpx.stage.adobe.com': 3,

  'community.adobe.com': 4,

  'www.cmo.com': 5,
  'cmo.adobe.com': 5,

  /*Stock Exploritory domain for a launch migration*/
  'launch.stock.stage.adobe.com': 2,

  /*Below are the list of microsites value must be greater then 25*/
  'www.adobeexchange.com': 26,
  'stage.adobeexchange.com': 26,
  'stage.exchange.adobe.com': 26,
  'exchange.adobe.com': 26,

  'summit.adobe.com': 27,
  'summit-emea.adobe.com': 28,

  'landing.adobe.com': 29,
  'landing-stage.dmg.suitedemand.com': 29,

  'letsxd.com': 30,

  'exploreadobe.com': 31,

  'captivateprime.adobe.com': 32,

  'elearning.adobe.com': 33,

  'coldfusion.adobe.com': 34,

  'info2.magento.com': 35,
  'na-ab09.marketo.com': 35,
  'magento.com': 42,
  'dc-stage.magedevteam.com': 42,

  'create.adobe.com': 36,
  'stockenterprise.adobe.com': 37,
  'blog.adobe.com': 38,
  'get.adobe.com': 39,
  'max.adobe.com': 40,
  'creativecloud.adobe.com': 41,
  'photoshop.com': 44,
  'business.stage.adobe.com': 45,
  'business.adobe.com': 45,
  'business.dev02.adobe.com' : 45,
  'business.qa02.adobe.com' : 45,
  'www.adobe-students.com' : 46
};

//43 for Marketo sub-domains
var pattern = /^(www|(de|fr|au|uk|jp|es)|engage|(de\.|fr\.)?blog|cmo|(stage-)?launchpoint|stage-((de\.|fr\.)?blog|cmo|es)|(dev-edit-|local-|stage-)(www|de|fr|au|uk))\.marketo\.com/;
if (pattern.test(h) ||
  h === 'na-ab29.marketo.com' ||
  h === 'ad1035sd9t.smartrelease.jp'
) {
  return 43;
}

var C_Host = h in hostnames;

if (C_Host && hostnames[h]) {
  return hostnames[h];
} else {
  return false;
}
}
      }
    },
    "topFrameInfo_abort": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  // Determines whether we should abort the topFrame Information in 
// pageload beacon or add it

var
  w = window,
  l = w.location,
  h,
  hostnameContains,
  abort = false;

// parameter or default to location.hostname
h = l.hostname;

// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

if(hostnameContains('workflow') && hostnameContains('.licenses.adobe.com')){
  abort = true;
}
return abort;
}
      }
    },
    "digitalData.organization.ecid": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var visitor = Visitor.getInstance("9E1005A551ED61CA0A490D45@AdobeOrg")
return visitor.getMarketingCloudVisitorID();

}
      }
    },
    "adobe_parseQueryParams": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
return function (search) {
  var
    keyValuePairs,
    keyValue,
    i, il,
    decode,
    values = {},
    key,
    host = window.location.hostname;

  // create uri decode function
  decode = function (string) {
    var 
      decoded = string || '';

    try {
      decoded = decodeURIComponent(string);
    } catch(err) {
      //nothing
    }

    return decoded;
  };

  // if serach starts with ? remove it
  if (search.indexOf('?') === 0) {
    search = search.substring(1);
  }

  // split up the search
  keyValuePairs = search.split('&');

  // loop through each
  for (i = 0, il = keyValuePairs.length; i < il; i++) {
    keyValue = keyValuePairs[i].split('=');

    if (
      keyValue[0]
    ) {
      values[decode(keyValue[0])] = decode(keyValue[1]);
    }
  }
  //remove few unwanted Query Params
  if
  (
    host.indexOf('.acrobat.com') !== -1 ||
      host === 'documentcloud.adobe.com'
  ){
    for (key in values) {
      if (key === 'uri' || key === 'assetUri') {
        delete values[key];
      }
    }
  }

  return values;
};
}
      }
    },
    "aep_form": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var aep_form = {},
  eventName = _satellite.getVar('aep_eventName'),
  ddPrimForm = 'digitalData.form.primaryForm.formInfo',
  ddFormResp = 'digitalData.form.response',
  index = function(str, substr) {
    return str.indexOf(substr) !== -1;
  };

if(event && event.detail && event.detail.digitalData){
  
  if(event.detail.digitalData.primaryEvent && event.detail.digitalData.primaryEvent.eventInfo && event.detail.digitalData.primaryEvent.eventInfo.eventName){
    eventName = event.detail.digitalData.primaryEvent.eventInfo.eventName;
  }
  if( event.detail.digitalData._get('form.primaryForm') ){
     digitalData._set('digitalData.form.primaryForm',event.detail.digitalData._get('form.primaryForm'));
  }
}

 

if (eventName && (index(eventName, 'FaaS Form') || index(eventName, 'Marketo Form'))) {
  
  var form_id = digitalData._get(ddPrimForm + '.id') &&  digitalData._get(ddPrimForm + '.id').toString();
  
  aep_form = {
    
    'formInfo': {
      'formId': form_id || '',
      'formType': digitalData._get(ddPrimForm + '.type') || '',
    },

    'response': {
      'submissionID': digitalData._get(ddFormResp + '.submissionID') || '',
      'domain': digitalData._get(ddFormResp + '.domain') || '',
      'functionalArea': digitalData._get(ddFormResp + '.functionalArea') || '',
      'hashedEmail': digitalData._get(ddFormResp + '.hashedEmail') || '',
      'industry': digitalData._get(ddFormResp + '.industry') || '',
      'jobTitle': digitalData._get(ddFormResp + '.jobTitle') || '',
      'organizationName': digitalData._get(ddFormResp + '.organizationName') || '',
      'orgType': digitalData._get(ddFormResp + '.orgType') || '',
      'productOfInterest': digitalData._get(ddFormResp + '.productInterest') || '',
      'website': digitalData._get(ddFormResp + '.website') || '',
      'isProductDemoChecked': digitalData._get(ddFormResp + '.isDemandBaseWidgetLoaded') || '',
      'isDemandBaseWidgetLoaded': digitalData._get(ddFormResp + '.isDemandBaseWidgetLoaded') || ''
    }
  }
}


return aep_form;
}
      }
    },
    "mbox_parameter_mar_ind": {
      "defaultValue": "",
      "cleanText": true,
      "modulePath": "core/src/lib/dataElements/localStorage.js",
      "settings": {
        "name": "mar_ind"
      }
    },
    "digitalData.cmo.contentId": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var path = window.location.pathname,
  contentID,
  str2;
if (path.indexOf('articles') !== -1) {
  str2 = path.substr(path.indexOf('articles'), path.length).replace(/\//g, ":").replace('.html', '');
  contentID = 'cmo.com:' + str2;
} else if (path.indexOf('category-pages') !== -1) {
  str2 = path.substr(path.indexOf('category-pages'), path.length).replace(/\//g, ":").replace('.html', '');
  contentID = 'cmo.com:' + str2;
} else if (path.indexOf('customer-experience') !== -1) {
  str2 = path.substr(path.indexOf('customer-experience'), path.length).replace(/\//g, ":").replace('.html', '');
  contentID = 'cmo.com:' + str2;
} else if (path.indexOf('future-of-work') !== -1) {
  str2 = path.substr(path.indexOf('future-of-work'), path.length).replace(/\//g, ":").replace('.html', '');
  contentID = 'cmo.com:' + str2;
} else if (path.indexOf('emerging-technology') !== -1) {
  str2 = path.substr(path.indexOf('emerging-technology'), path.length).replace(/\//g, ":").replace('.html', '');
  contentID = 'cmo.com:' + str2;
} else if (path.indexOf('trends') !== -1) {
  str2 = path.substr(path.indexOf('trends'), path.length).replace(/\//g, ":").replace('.html', '');
  contentID = 'cmo.com:' + str2;
} else if (path !== '/') {
  contentID = 'cmo.com' + path.replace(/\//g, ":").replace('.html', '');
} else contentID = 'cmo.com';
return contentID;
}
      }
    },
    "analytics_pageload_abort": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  // Determines whether we should abort the initial pageload beacon or fire it
// This can happen when you have a single page application that is already 
// firing a pixel when it loads.

var
  w = window,
  l = w.location,
  h,
  href = l.href,
  p = l.pathname,
  hostnameContains,

  abort = false;

// parameter or default to location.hostname
h = l.hostname;

// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};


if (

  //----------------------------------------------------------------------------
  // CC Home - Grp-CCHome-Eng <Grp-CCHome-Eng@adobe.com>
  //----------------------------------------------------------------------------
  // local
  hostnameContains('app-local.hollywoodstudios.corp.adobe.com') ||
  hostnameContains('dev.hollywoodstudios.corp.adobe.com') ||
  hostnameContains('dev2.hollywoodstudios.corp.adobe.com') ||
  // dev
  hostnameContains('cchome-dev.adobe.io') ||
  hostnameContains('dev.creativecloud.adobe.com') ||
  hostnameContains('dev4.creativecloud.adobe.com') ||
  hostnameContains('dev.cc.adobe.com') ||
  hostnameContains('dev.cchome.adobe.com') ||
  hostnameContains('dev2.cchome.adobe.com') ||
  hostnameContains('dev3.cchome.adobe.com') ||
  // stage
  hostnameContains('cchome-stage.adobe.io') ||
  hostnameContains('stage.creativecloud.adobe.com') ||
  hostnameContains('stage.cc.adobe.com') ||
  hostnameContains('stage.cchome.adobe.com') ||
  hostnameContains('stage2.cchome.adobe.com') ||
  // prod
  hostnameContains('cchome.adobe.io') ||
  hostnameContains('creativecloud.adobe.com') ||
  hostnameContains('cc.adobe.com') ||
  hostnameContains('r.cchome.adobe.com') ||
  hostnameContains('cchome.adobe.com') ||

  //----------------------------------------------------------------------------
  // Accounts.adobe.com
  //----------------------------------------------------------------------------
  //stage
  hostnameContains('stage.account.adobe.com') ||
  //prod
  hostnameContains('account.adobe.com') ||

  //----------------------------------------------------------------------------
  //  NGL - Grp-NGL-CoreEngineering <ngl-coreengineering@adobe.com>
  //----------------------------------------------------------------------------
  //stage
  hostnameContains('workflow-stage.licenses.adobe.com') ||
  //dev
  hostnameContains('workflow-dev.licenses.adobe.com') ||
  //prod
  hostnameContains('workflow.licenses.adobe.com') ||

  //----------------------------------------------------------------------------
  //  HelpX - GRP EMAIL-ID to be updated
  //----------------------------------------------------------------------------
  //stage
  hostnameContains('helpx.stage') ||
  //dev
  hostnameContains('helpx.dev') ||
  //prod
  hostnameContains('helpx.adobe.com') ||
  //QA
  hostnameContains('helpx.qa') ||
  
  // Helpx specific author domains
  (hostnameContains('chl-author')&& hostnameContains('adobe.com')) ||



  //video.tv.adobe.com
  hostnameContains('video.tv.adobe.com') ||

  //cmo
  (hostnameContains('community-dev.adobe.com') ||
    hostnameContains('community-stg.adobe.com') ||
    hostnameContains('community.adobe.com')
  ) ||

  //cmo
  (hostnameContains('cmo-stage') ||
    hostnameContains('cmo.com') || hostnameContains('cmo.adobe.com') || hostnameContains('cmo-prod')
  ) ||

  //learningsummit
  (hostnameContains('learningsummit.elearning.adobeevents.com')) ||

  //adobe search page
  (hostnameContains('adobe.com') && window.location.pathname === '/search.html') ||

  //colors.adobe.com pages
  (hostnameContains('colorweb-stage.adobeku.com') ||
    hostnameContains('color.adobe.com')
  ) ||

  //photoshop.adobe.com (but not try.photoshop.adobe.com)
  (
    hostnameContains('photoshop.adobe.com') &&
    !hostnameContains('try.photoshop.adobe.com')
  ) ||

  //get.adobe.com 
  (new RegExp(/get[0-9]?.adobe.com/).test(h)) ||

  //adminconsole
  (hostnameContains('adminconsole')) ||

  //vidyard
  (hostnameContains('play.vidyard.com')) ||

  (hostnameContains('reg.adobe.com')) ||

  //max registration page
  ((hostnameContains('portal.adobe.com') && href.indexOf('adobe/am20/signin') !== -1)) ||

  //MAX Global Arts Projects
  (hostnameContains('app.adobemaxmural.com')) ||

  //Summit2021
  ((hostnameContains('portal.adobe.com') && href.indexOf('adobe/as21/') !== -1)) ||


  //cc express spark
  ((hostnameContains('spark.adobe.com') || hostnameContains('adobeprojectm.com') || hostnameContains('express.adobe.com')) &&
    (p.indexOf('image-resize') !== -1 || p.indexOf('-video') !== -1))

) {
  abort = true;
}


return abort;
}
      }
    },
    "isConsentGiven": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
var
  w = window,
  evidon = w.evidon,
  location,
  countriesRequiringConsent = {
    3: 1, // Germany
    4: 1, // Spain
    5: 1, // France
    6: 1, // United Kingdom
    7: 1, // Italy
    8: 1, // Netherlands
    9: 1, // Canada
    15: 1, // Denmark
    16: 1, // Ireland
    18: 1, // Poland
    19: 1, // Austria
    20: 1, // Belgium
    22: 1, // Sweden
    23: 1, // Slovakia
    24: 1, // Hungary
    25: 1, // Finland
    26: 1, // Portugal
    27: 1, // Czech Republic
    28: 1, // Luxembourg
    29: 1, // Greece
    30: 1, // Bulgaria
    31: 1, // Romania
    32: 1, // Estonia
    33: 1, // Latvia
    34: 1, // Lithuania
    35: 1, // Slovenia
    36: 1, // Malta
    37: 1, // Cyprus
    61: 1 // Croatia
  };

// get the location
if (evidon) {

  // if we found the location, use that
  if (
    evidon.location
  ) {
    location = evidon.location;

    // if we don't have that, but we do have the notice and the country, use that
  } else if (
    evidon.notice &&
    evidon.notice.country
  ) {
    location = evidon.notice.country;
  } else {
    // TODO: What do we do here?
  }

} else {
  // TODO: What do we do here?
}

// 1 of the 5 conditions must be true
if (

  //----------------------------------------------------------------------------
  // 1) if the evidon cookie exists, that means they have consented at some point
  //----------------------------------------------------------------------------
  (
    document.cookie.indexOf('_evidon_consent_cookie=') !== -1
  ) ||


  //----------------------------------------------------------------------------
  // 2) if we do have evidon and consentIsGiven flag is true
  //----------------------------------------------------------------------------
  (
    evidon &&
    evidon.notice &&
    evidon.notice.consentIsGiven
  ) ||


  //----------------------------------------------------------------------------
  // 3) if we have a location that was loaded from the country.js script and 
  // the country location is identified and it is NOT a country that requires
  // consent
  //----------------------------------------------------------------------------
  (
    location &&
    location.id &&
    !countriesRequiringConsent[location.id]
  )

) {
  return true;
}

return false;

}
      }
    },
    "adobe_adminConsole_userSelectedReasons": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var userSelectedReasonLogic,
  reasons = [],
  combinedReason = '',
  maxVariableLength = 255;
userSelectedReasonLogic = function (dl) {
  reasons = dl.adminConsole.purchase.userSelectedReason;
  
  for (var count = 0, len = reasons.length; count < len; count++) {
    if (reasons[count].reasonID){
      if (reasons[count].reasonID.indexOf('OTHER') == -1){
        combinedReason = (count == len - 1) ? (combinedReason + reasons[count].reasonID) : (combinedReason + reasons[count].reasonID + ',');
      } else
        combinedReason =  (reasons[count].userReason)? combinedReason+reasons[count].reasonID+','+reasons[count].userReason:combinedReason+reasons[count].reasonID;
    }   
  }
  return combinedReason.substring(0,maxVariableLength);
};

return userSelectedReasonLogic;


}
      }
    },
    "ecpDimensions": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var ecpDimensions = {};

ecpDimensions = {
  'geo' : digitalData._get('digitalData.organization.ecp.geo'),
  'market_area': digitalData._get('digitalData.organization.ecp.market_area'),
  'sub_std_name_key' : digitalData._get('digitalData.organization.ecp.sub_std_name_key')
}

return ecpDimensions
}
      }
    },
    "audienceManager_disableDestinationPublishingIframe": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  w = window,
  l = w.location,
  h,
  p,
  hostnameContains,
  pathnameContains,
  abort = false;

// parameter or default to location.hostname
h = l.hostname;
p = l.pathname;
// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function(string){
  return p.indexOf(string) !== -1;
};

if(hostnameContains('.adobe.com') && 
   pathnameContains('/mini-plans')
  ){
  abort = true;
}

if (l.search.indexOf('noThirdParty=true') !== -1) {
  abort = true;
}

return abort;
}
      }
    },
    "digitalData.primaryUser.primaryProfile.profileInfo": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  name = 'digitalData.primaryUser.primaryProfile.profileInfo',
  hostname = window.location.hostname,
  unknownString = 'unknown',
  promise,
  unresolved;

// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
// eslint-disable-next-line no-undef
if (promise) {
  return promise;
}

// else, create the promise...

unresolved = {
  authState: unknownString,
  entitlementCreativeCloud: unknownString,
  entitlementStatusCreativeCloud: unknownString,
  // NOTE: We add this here because we want to make sure that it doesn't get
  // overwritten by setting it outside of here...
  returningStatus: _satellite._getNewRepeat(365, 's_nr', _satellite._getDomain())
};

promise = new Promise(function (resolve) {
  var
    w = window,
    adobeIMS = w.adobeIMS,
    check,
    handle,
    profileInfo = {},
    scope = '',
    s = w.s_adobe,
    v = s && s.visitor,
    ecid = v && v.getMarketingCloudVisitorID(),
    locationHint = v && v.getAudienceManagerLocationHint(),
    i, il,
    serviceAccount,
    funnelStatusCookieName = 's_funnelStatus',
    handlev2;

  var updateProf = function (profile) {

    if (profile) {
      //if userid is present
      if (profile.userId) {
        var index1 = profile.userId.indexOf('@');
        if (index1 > 0) {
          profileInfo.profileID = profile.userId.substring(0, index1);
          profileInfo.authID = profileInfo.profileID;
        }
        profileInfo.fullProfileID = profile.userId;
        profileInfo.fullAuthID = profileInfo.fullProfileID;
      }
      //if authId is present
      if (profile.authId) {
        var index2 = profile.authId.indexOf('@');
        if (index2 > 0) {
          profileInfo.authID = profile.authId.substring(0, index2);
        }
        profileInfo.fullAuthID = profile.authId;
      }

      // determine adobeIMSUserProfile
      profileInfo.adobeIMSUserProfile = {};

      if (profile.account_type) {
        profileInfo.adobeIMSUserProfile.account_type = profile.account_type;
      }

      if (profile.preferred_languages) {
        profileInfo.adobeIMSUserProfile.preferred_languages = profile.preferred_languages;
      }

      if (profile.countryCode) {
        profileInfo.adobeIMSUserProfile.countryCode = profile.countryCode;
      }

      if (profile.serviceAccounts) {
        profileInfo.adobeIMSUserProfile.serviceAccounts = [];

        for (i = 0, il = profile.serviceAccounts.length; i < il; i++) {
          serviceAccount = profile.serviceAccounts[i];

          profileInfo.adobeIMSUserProfile.serviceAccounts.push({
            serviceCode: serviceAccount.serviceCode,
            serviceStatus: serviceAccount.serviceStatus,
            serviceLevel: serviceAccount.serviceLevel
          });
        }
      }

      if (profile.toua) {
        profileInfo.adobeIMSUserProfile.toua = profile.toua;
      }
    }

    // determine entitlement and entitlement status
    if (
      scope &&
      scope.indexOf('creative_cloud') !== -1 &&
      w.adobeIMS.isSignedInUser()
    ) {

      if (
        profile &&
        profile.serviceAccounts &&
        profile.serviceAccounts.length > 0
      ) {

        for (i = 0, il = profile.serviceAccounts.length; i < il; i++) {
          serviceAccount = profile.serviceAccounts[i];

          if (serviceAccount.serviceCode === 'creative_cloud') {

            if (serviceAccount.serviceLevel === 'CS_LVL_2') {
              profileInfo.entitlementCreativeCloud = 'paid';
            } else if (serviceAccount.serviceLevel === 'CS_LVL_1') {
              profileInfo.entitlementCreativeCloud = 'free';
            } else {
              profileInfo.entitlementCreativeCloud = 'notEntitled';
            }

            if (serviceAccount.serviceStatus) {
              profileInfo.entitlementStatusCreativeCloud = serviceAccount.serviceStatus;
            }

            break;
          }
        }

        if (!profileInfo.entitlementCreativeCloud) {
          profileInfo.entitlementCreativeCloud = 'notEntitled';
        }

        if (!profileInfo.entitlementStatusCreativeCloud) {
          profileInfo.entitlementStatusCreativeCloud = 'none';
        }

      } else {
        profileInfo.entitlementCreativeCloud = 'notEntitled';
        profileInfo.entitlementStatusCreativeCloud = 'none';
      }

    } else {
      profileInfo.entitlementCreativeCloud = 'unknown';
      profileInfo.entitlementStatusCreativeCloud = 'unknown';
    }

    // determine returningStatus
    profileInfo.returningStatus = unresolved.returningStatus;
  };


  handle = function () {
    // 'digitalData.primaryUser.primaryProfile.profileInfo.profileID'
    // 'digitalData.primaryUser.primaryProfile.profileInfo.authState'
    // 'digitalData.primaryUser.primaryProfile.profileInfo.adobeIMSUserProfile'
    // 'digitalData.primaryUser.primaryProfile.profileInfo.entitlementCreativeCloud'
    // 'digitalData.primaryUser.primaryProfile.profileInfo.entitlementStatusCreativeCloud'
    // 'digitalData.primaryUser.primaryProfile.profileInfo.returningStatus'

    var profile = w.adobeIMS.getUserProfile() ? w.adobeIMS.getUserProfile() : '',
      isSignedIn = w.adobeIMS.isSignedInUser() ? w.adobeIMS.isSignedInUser() : false;
    scope = w.adobeIMS.getScope() ? w.adobeIMS.getScope() : '';

    // determine authState
    if (isSignedIn) {
      profileInfo.authState = 'authenticated';
      // Invoke signedInState Direct Call Rule
      _satellite.track('signedInState');
    } else {
      profileInfo.authState = 'loggedOut';
    }

    updateProf(profile);

    resolve(profileInfo);
  };

  handlev2 = function () {
    if (w.adobeIMS && w.adobeIMS.adobeIdData && w.adobeIMS.adobeIdData.scope) {
      scope = w.adobeIMS.adobeIdData.scope;
    }
    // determine authState
    if (w.adobeIMS.isSignedInUser()) {
      profileInfo.authState = 'authenticated';
      // Invoke signedInState Direct Call Rule
      //_satellite.track('signedInState');
    } else {
      profileInfo.authState = 'loggedOut';
    }

    if (w.adobeIMS.isSignedInUser()) {
      w.adobeIMS.getProfile().then(function (profile) {
        updateProf(profile);
        resolve(profileInfo);
      });
    } else {
      resolve(profileInfo);
    }

  };
  check = function () {

    // if the page uses adobeIMS (sign in capabilities), then let's try to find out the information
    if (w.adobeIMS) {

      if (w.adobeIMS.version && w.adobeIMS.version.indexOf('v2-') !== -1) {
        // means is ims version 2
        handlev2();
      }
      // onReadyAlreadyCalled = We can get the information right now
      else if (w.adobeIMS.onReadyAlreadyCalled) {
        handle();

        // if onReadyAlreadyCalled is false or null, but we have an event listener
        // then attach a listener to adobeIMS to fire when it is ready to give us the information
      } else if (
        w.adobeIMS.addEventListener &&
        w.adobeIMS.Events &&
        w.adobeIMS.Events.READY
      ) {
        w.adobeIMS.addEventListener(w.adobeIMS.Events.READY, handle);

        // otherwise, we probably have an old implementation, so let's just poll
        // Note: This shouldn't happen very often
      } else {
        _satellite._poll(handle, [
          function () {
            return w.adobeIMS.onReadyAlreadyCalled;
          }
        ], {
          timeout: 10000,
          interval: 500
        });
      }

    } else {
      resolve(unresolved);
    }

  };

  // poll for window.adobeIMS object
  _satellite._poll(check, [
    function () {
      return !!w.adobeIMS;
    }
  ], {
    timeout: 2000,
    interval: 250,
    callOnTimeout: true
  });

});

promise.unresolved = unresolved;

// assign the promise
_satellite._promises[name] = promise;

return promise;
}
      }
    },
    "digitalData.campaign.external.arvato.campaignInfo.uid": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /*Enabled for capturing ThirdParty related data in digitalData Property*/

return  { 'TRADEDOUBLER': _satellite.cookie.get('TRADEDOUBLER') };

}
      }
    },
    "demandbase_disable": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  // Determines whether we should abort the topFrame Information in 
// pageload beacon or add it

var
  w = window,
  l = w.location,
  h,
  p,
  hostnameContains,
  pathnameContains,
  get_cookie= _satellite.cookie.get,
  abort = false;

// parameter or default to location.hostname
h = l.hostname;
p = l.pathname;
// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function(string){
  return p.indexOf(string) !== -1;
};

if(hostnameContains('workflow') && hostnameContains('.licenses.adobe.com')){
  abort = true;
}else if(hostnameContains('.adobe.com') && 
   pathnameContains('/mini-plans') && 
   _satellite._getQueryParam('web') !== '1'
){
  abort = true;
}else if (!_satellite.getVar('isStudent')) {
  abort = true;
}

return abort;
}
      }
    },
    "digitalData.adminConsole.contractInfo": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var renewalData = {
  'daysForAnniversary' : digitalData._get('digitalData.adminConsole.organizationInfo.contract.offsetFromAnniversaryDate')||'',
  'daysInContract':Math.abs(digitalData._get('digitalData.adminConsole.organizationInfo.contract.offsetFromContractStartDate'))||'',
  'daysleftForRenewal':0
};


if(digitalData._get('digitalData.adminConsole.organizationInfo.contract.inRenewalWindow')!='false'){
 renewalData.daysleftForRenewal= Math.abs(digitalData._get('digitalData.adminConsole.organizationInfo.contract.offsetFromRenewalStartDate'))
}

return renewalData
}
      }
    },
    "web.webPageDetails.name": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var  pageNameLogic = _satellite.getVar('adobe_pageNameLogic');

return pageNameLogic(window.location);
}
      }
    },
    "digitalData.campaign.onsite.cgen": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  campaignInfo;

// promoid
if (_satellite._getQueryParam('promoid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('promoid'),
    name: 'CGen - promoid',
    queryParameter: 'promoid',
  };
}

if (
  campaignInfo &&
  campaignInfo.id
) {
  value.campaignInfo = campaignInfo;
}

return value;
}
      }
    },
    "digitalData.diagnostic.page.aemImplementation": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  name = 'digitalData.page.pageInfo.technicalData.aemImplementation',
  promise,
  unresolved;
// a global place to store all our promises that we only want to have 1 of
_satellite._promises = _satellite._promises || {};

// get the promise if it already was created
promise = _satellite._promises[name];

// if the promise exists, return it...
if (promise) {
  return promise;
}

promise = new Promise(function (resolve) {
  _satellite._poll(function() {
    if(typeof window.dexter !== 'undefined')
      resolve('dexter');
    else
      resolve(false);
  }, [
    function () {
      if(typeof window.dexter !== 'undefined')
        return true;
    }
  ], {
    timeout: 3000,
    interval: 250,
    callOnTimeout: true
  });
});
promise.unresolved = unresolved;

// assign the promise
_satellite._promises[name] = promise;

return promise;
}
      }
    },
    "adobe_digitalData_State": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  setDigitalData;

setDigitalData = function (digitalData) {
  var
    dataElementName,
    dataElements,
    i, il;

  // mapping of data elements
  // Note: The order of this array is important because some data elements 
  // depend on   other data elements being set first.  Like 
  // digitalData.previousPage depends on digitalData.page being set first.
  dataElements = [


    'digitalData.marketingtech.diagnostic.stateChangepromise',

    //digitalData.nglParams
    //--------------------------------------------------------------------------  
    'digitalData.nglParams',

    //digitalData.app.appInfo.appCtxId
    //--------------------------------------------------------------------------
    //'digitalData.app.appInfo.appCtxId',

    // digitalData.app.appInfo.campaignId
    //--------------------------------------------------------------------------  
    'digitalData.app.appInfo.campaignId'
  ];

  // loop through each of the data elements in the list and try to set them if we 
  // are supposed to
  for (i = 0, il = dataElements.length; i < il; i++) {

    // get the dataElement details
    dataElementName = dataElements[i];

    // set the data layer property
    digitalData._set(dataElementName, _satellite.getVar(dataElementName));

  }
};

return setDigitalData;
}
      }
    },
    "digitalData.campaign.external.social": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  campaignInfo;

// scid
if (_satellite._getQueryParam('scid')) {
  campaignInfo = {
    id: _satellite._getQueryParam('scid'),
    name: 'Salesforce - scid',
    queryParameter: 'scid',
  };
}

if (
  campaignInfo &&
  campaignInfo.id
) {
  value.campaignInfo = campaignInfo;
}

return value;
}
      }
    },
    "digitalData.homepage.podInfo": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
    promise,
    unresolved = {

    },
    mapObj = {
        "CREATIVE CLOUD": "Creative Cloud",
        "DOCUMENT CLOUD": "Document Cloud",
        "EXPERIENCE CLOUD": "Experience Cloud",
        "ADOBE STOCK": "Adobe Stock"
    },
    buzType = function(businessType) {
        if (typeof mapObj[businessType] !== "undefined") {
            return mapObj[businessType];
        } else { return businessType }
    };

promise = new Promise(function(resolve) {

    // wait for the target event to fire
    var
        dl = window.digitalData,
        homepage = {},
        handleHomepage = function() {
            setTimeout(function() {
                //console.log("handle home page");
                if (digitalData.pods && digitalData.pods.podInfo) {
                    for (var i = 0; i < digitalData.pods.podInfo.length; i++) {
                        var podvalue;
                        if (digitalData.pods.podInfo[i].segmentInfo && digitalData.pods.podInfo[i].segmentInfo !== "Not Available") {
                            podvalue = buzType(digitalData.pods.podInfo[i].businessType) + "|" + digitalData.pods.podInfo[i].segmentInfo + "|" + digitalData.pods.podInfo[i].storyName + "|" + digitalData.pods.podInfo[i].storyPlacement + "|" + digitalData.pods.podInfo[i].system + "|" + digitalData.pods.podInfo[i].cta.toString();
                        } else {
                            podvalue = buzType(digitalData.pods.podInfo[i].businessType) + "|" + "Not Available" + "|" + digitalData.pods.podInfo[i].storyName + "|" + digitalData.pods.podInfo[i].storyPlacement + "|" + digitalData.pods.podInfo[i].system + "|" + digitalData.pods.podInfo[i].cta.toString();

                        }
                        if (digitalData.pods.podInfo[i].storyPlacement) {
                            if (digitalData.pods.podInfo[i].storyPlacement === "marquee") {
                                homepage[0] = podvalue;
                            }
                            if (digitalData.pods.podInfo[i].storyPlacement === "pod 1") {
                                homepage[1] = podvalue;
                            }
                            if (digitalData.pods.podInfo[i].storyPlacement === "pod 2") {
                                homepage[2] = podvalue;
                            }
                            if (digitalData.pods.podInfo[i].storyPlacement === "pod 3") {
                                homepage[3] = podvalue;
                            }
                        }
                    }
                    resolve(homepage);
                } else {
                    resolve(homepage);
                }
            }, 500);
        };
    //check for adobe.target object in a page
    if (adobe.target &&
        adobe.target.event) {
        //console.log("target test");
        document.addEventListener(adobe.target.event.CONTENT_RENDERING_SUCCEEDED, function(event) {
            //console.log("testing home page with target");
            handleHomepage();
        })
        document.addEventListener(adobe.target.event.CONTENT_RENDERING_FAILED, function(event) {
            //console.log("testing home page failed to render")
            handleHomepage();
        })
        document.addEventListener(adobe.target.event.CONTENT_RENDERING_NO_OFFERS, function(event) {
            //console.log("testing home page with no offers")
            handleHomepage();
        })
        document.addEventListener(adobe.target.event.REQUEST_FAILED, function(event) {
            // console.log("testing home page with request fail")
            handleHomepage();
        })
        setTimeout(function(){ handleHomepage(); }, 5000);
    } else {
        //console.log("home page resolve");
        handleHomepage();
    }
})

promise.unresolved = unresolved;

return promise;
}
      }
    },
    "aep_events": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var linkType = 'other';
if (s.linkType) {
  //console.log(s.linkType);
  if (s.linkType == 'd') {
    linkType = 'download';
  }
  if (s.linkType == 'e') {
    linkType = 'exit';
  }
}

return {

  'web': {
    'webInteraction': {
      'URL': digitalData._get('page.pageInfo.location.href'),

      'name': digitalData._get('primaryEvent.eventInfo.eventName'),

      'type': linkType,

      'linkClicks': {
        'value': 1
      }

    },
    'webReferrer': {
      'URL': document.referrer
    }

  },
   "eventMergeId": _satellite.getVar('aep_xdm_mergeID'),
   "eventType": "event",
}
}
      }
    },
    "digitalData.campaign.onsite.salesforce": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  value = {},
  campaignInfo;

// s_osc
if (_satellite._getQueryParam('s_osc')) {
  campaignInfo = {
    id: _satellite._getQueryParam('s_osc'),
    name: 'Salesforce - s_osc',
    queryParameter: 's_osc',
  };
}

if (
  campaignInfo &&
  campaignInfo.id
) {
  value.campaignInfo = campaignInfo;
}

return value;
}
      }
    },
    "adobe_removePiiLogic": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  // global digitalData:true
var
  removePiiLogic;

removePiiLogic = function (l) {
  var
    piis = [
      'email',
      'first_name',
      'last_name'
    ],
    i, il,
    w = window,
    pii;
  // remove any PII from the link text
  if (
    w.adobeIMS &&
    w.adobeIMS._profile &&
    l
  ) {
    for (i = 0, il = piis.length; i < il; i++) {
      // get the pii
      pii = w.adobeIMS._profile[piis[i]];
      // if we have pii
      if (pii) {
        // redact it
        l = l.replace(
          RegExp(pii, 'gim'),
          ''
        );
      }
    }
    // trim whitespace from ends
    l = l.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  }
  return l;
};
return removePiiLogic;
}
      }
    },
    "aep_profileInfo.profileID": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return digitalData._get('digitalData.primaryUser.primaryProfile.profileInfo.profileID');
}
      }
    },
    "digitalData.app.appInfo.campaignId": {
      "defaultValue": "",
      "cleanText": true,
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var inAppCampaign = '';

/*var inApp = _satellite._getQueryParam('appctxid'),
    inAppCampaign='';

if (inApp && inApp.indexOf('Ngl')!==-1){
*/
inAppCampaign = _satellite._getQueryParam('campaignid');
/*}*/

return inAppCampaign;
}
      }
    },
    "aep_profileInfo.authState": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return digitalData._get('digitalData.primaryUser.primaryProfile.profileInfo.authState');
}
      }
    },
    "aep_pageViews": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var pageNameLogic = _satellite.getVar('adobe_pageNameLogic');

return {
  'web': {
    'webPageDetails': {
       'URL': digitalData._get('digitalData.page.pageInfo.location.href'),

      'name': pageNameLogic(digitalData._get('page.pageInfo.location')),

      'siteSection': digitalData._get('digitalData.page.pageInfo.siteSection'),

      'pageViews': {
        'value': 1
      }
    },
      'webReferrer': {
      'URL': document.referrer
    }
  },
   'eventMergeId': _satellite.getVar('aep_xdm_mergeID'),
   'eventType': 'pageload',
}
}
      }
    },
    "adobe_copyLocation": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  
return function (w) {
  var
    l = w.location;

  return {
    href: l.href,
    origin: l.origin,
    protocol: l.protocol,
    host: l.host,
    hostname: l.hostname,
    port: l.port,
    pathname: l.pathname,
    search: l.search,
    hash: l.hash
  };

};
}
      }
    },
    "analytics_module_Media_enable": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  return true;
}
      }
    },
    "digitalData.community.communityInfo.details": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
/* global snapshot:true */
var eVar203 = '';

if (digitalData) {
  var snapshot = digitalData._snapshot();

  eVar203 = snapshot._get('digitalData.community.communityAttributes.cardCreatedDate') ? snapshot._get('digitalData.community.communityAttributes.cardCreatedDate') + '|' : '|';
  eVar203 += snapshot._get('digitalData.community.profileInfo.userRole') ? snapshot._get('digitalData.community.profileInfo.userRole') + '|' : '|';
  eVar203 += snapshot._get('digitalData.community.communityAttributes.countCorrectAnswer') ? snapshot._get('digitalData.community.communityAttributes.countCorrectAnswer') + '|' : '|';
  eVar203 += snapshot._get('digitalData.community.communityInfo.communityFlag') ? snapshot._get('digitalData.community.communityInfo.communityFlag') + '|' : '|';
  eVar203 += snapshot._get('digitalData.community.communityInfo.communityContentType') ? snapshot._get('digitalData.community.communityInfo.communityContentType') + '|' : '|';
  eVar203 += snapshot._get('digitalData.community.communityInfo.communityContentTab') ? snapshot._get('digitalData.community.communityInfo.communityContentTab') : '';

}

if(eVar203 === '|||') eVar203 = ''; 


return eVar203;
}
      }
    },
    "digitalData.linkTracking.params": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
var 
  eA = '',eN = '',lU = '',sH = '',lA = '',lP = '',pH = '';
if(digitalData._get('digitalData.linkTracking')){
  eA = digitalData._get('digitalData.primaryEvent.eventInfo.eventAction') || 'NoValue' ;
  eN = digitalData._get('digitalData.primaryEvent.eventInfo.eventName') || 'NoValue' ;
  lU = digitalData._get('digitalData.linkTracking.linkInfo.linkUrl') || 'NoValue' ;
  sH = digitalData._get('digitalData.linkTracking.linkInfo.sectionHeading') || 'NoValue' ;
  lA = digitalData._get('digitalData.linkTracking.linkInfo.linkAction') || 'NoValue' ;
  lP = digitalData._get('digitalData.linkTracking.linkInfo.linkPosition') || 'NoValue' ;
  pH = digitalData._get('digitalData.linkTracking.linkInfo.placeHolder') || 'NoValue';

  return eN.replace('Helpx:','') +'|'+ eA +'|'+ eN +'|'+ lU +'|'+ sH +'|'+ lA +'|'+ lP +'|'+ pH;
}
return false;
}
      }
    },
    "adobe_adminConsole_products": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* eslint-disable no-console */
/* eslint-disable no-undef */
// s.products
// 
// Syntax:
// "Category;Product;Quantity;Price;eventN=X1|eventN2=X2;eVarN=merch_category|eVarN2=merch_category2"

//--------------------------------------------------------------------------
// determine the s.products based on the data layer
//--------------------------------------------------------------------------

var
  acLogic,
  items,
  owned_items,
  pString = '',
  org_products = digitalData._get('digitalData.adminConsole.organizationInfo.product'),
  cleanArray = function (actual) {
    var newArray = [];
    for (var i = 0; i < actual.length; i++) {
      if (actual[i]) {
        newArray.push(actual[i]);
      }
    }
    return newArray;
  };



acLogic = function (dl) {
  var dl = dl || window.digitalData,
    products = [],
    events = [],
    purchase_flow = false;
  if (dl) {
    if (dl.primaryProduct && dl.primaryProduct.productInfo) {
      items = [dl.primaryProduct];
    } else if (dl.cart && dl.cart.item && Array.isArray(dl.cart.item)) {
      items = dl.cart.item;
    } else if (dl.product) {
      items = dl.product;
    }
  }

  if (items) {

    //capture product purchase and renewal details
    var event_products = function () {
      if ((dlp = dl.primaryEvent) && (dlpe = dlp.eventInfo) && (dlpe.eventAction === 'completeOrder')) {
        if ((dlt = dl.transaction) && (dlta = dlt.attributes) && (dltac = dlta.contract)) {
          purchase_flow = true;
          if (dl._get('page.pageInfo.pageName') && dl._get('page.pageInfo.pageName').indexOf('adminconsole.adobe.com:addReviewOrder') !== -1) {


            if (dltac.routeToMarket == 'DIRECT') {
              events[3] = 'purchase';
            }

            if (dltac.routeToMarket == 'INDIRECT') {
              return 'event510=1';
            }
            /*  if (dlta.contractType == 'INDIRECT_ORG') {
              events[3] = 'event510';
            }*/
            if (dltac.routeToMarket == 'DIRECT') {
              return 'event509=1';
            }
            /*if (dlta.contractType == 'DIRECT_ORG') {
              events[3] = 'purchase,event509';
            }*/
            return '';

          } else if (dl._get('page.pageInfo.pageName') && dl._get('page.pageInfo.pageName').indexOf('adminconsole.adobe.com:renewReviewOrder') !== -1) {
            /* if (dlta.contractType == 'INDIRECT_ORG') {
              events[3] = 'event514';
            }*/
            if (dltac.routeToMarket == 'INDIRECT') {
              return 'event514=1';
            }

            /*if (dlta.contractType == 'DIRECT_ORG') {
              events[3] = 'event513';
            }*/
            if (dltac.routeToMarket == 'DIRECT') {
              return 'event513=1';
            }
            return '';
          }
        }

      }
    }

    // loop through product array
    items.forEach(function (item) {
      var
        parts = [],
        pevents = [],
        pevars = [];
      // if we have at least the basic information we need, proceed
      if (item && item.productInfo) {
        // 0 = Category
        if (item.category && item.category.primaryCategory) {
          parts[0] = item.category.primaryCategory;
        } else {
          parts[0] = '';
        }
        // 1 = Product
        if (item.productInfo) {
          if (item.productInfo.offerId) {
            parts[1] =
              item.productInfo.offerId;
          } else if (item.productInfo.productName) {
            parts[1] =
              item.productInfo.productName;
          } else {
            parts[1] = '';
          }
        }

        // 2 = Quantity
        if (item.quantity) {
          parts[2] = item.quantity;
        } else {
          parts[2] = '';
        }
        // 3 = Price
        // TODO: consider multiplying the quantity by the basePrice
        // TODO: also consider adding everything up with shipping, taxes, etc.
        if (item.price && item.price.basePrice) {
          parts[3] = item.price.basePrice;
        } else if (item.productInfo && item.productInfo.price) {
          parts[3] = item.productInfo.price;
        } else {
          parts[3] = '';
        }

        // 4 = Events

        if (item.quantity) {
          pevents[0] = 'event506=' + item.quantity;
        }
        if (item.attributes && item.attributes.assignedLicense) {
          pevents[1] = 'event410=' + item.attributes.assignedLicense;
        }
        if (item.attributes && item.attributes.totalLicense) {
          pevents[2] = 'event411=' + item.attributes.totalLicense;
        }
        if (!item.quantity) {
          pevents[3] = 'event412=1';
        }
        if (item.attributes && item.attributes.unassignedLicenseCount) {
          pevents[4] = 'event414=' + item.attributes.unassignedLicenseCount;
        }

        //Update event if the product is for order/renewal
        pevents[5] = event_products();


        if (pevents && pevents.length) {
          pevents = cleanArray(pevents);
          if (pevents) {
            parts[4] = pevents.join('|');
          }
        } else {
          parts[4] = '';
        }

        // 5 = eVars
        if (item.attributes && item.attributes.sourceOfferLocation) {
          pevars[0] = 'eVar192=' + item.attributes.sourceOfferLocation;
        }
        if (item.attributes && item.attributes.customerSegment) {
          pevars[1] = 'eVar191=' + item.attributes.customerSegment;
        }

        if (item.attributes && item.attributes.licenseType) {
          pevars[2] = 'eVar189=' + item.attributes.licenseType;
        }


        if (pevars && pevars.length) {
          pevars = cleanArray(pevars);
          if (pevars) {
            parts[5] = pevars.join('|');
          }
        } else {
          parts[5] = '';
        }
        // join them together and add to products
        products.push(parts.join(';'));
      }
    });
  }

  if (org_products && !purchase_flow) {
    org_products.forEach(function (org_product) {
      var
        parts = [],
        oevents = [];

      if (org_product && org_product.productInfo) {
        parts[0] = '';
        parts[1] = org_product.productInfo.offerId;
        parts[2] = '';
        parts[3] = '';
        oevents[0] = 'event809=1';
        parts[5] = 'eVar124=' + org_product.productInfo.subscriptionGUID;
      }
      if (org_product.attributes && org_product.attributes.assignedLicense) {
        oevents[1] = 'event410=' + org_product.attributes.assignedLicense;
      }
      if (org_product.attributes && org_product.attributes.totalLicense) {
        oevents[2] = 'event411=' + org_product.attributes.totalLicense;
      }
      if (oevents && oevents.length) {
        oevents = cleanArray(oevents);
        if (oevents) {
          parts[4] = oevents.join('|');
        }
      } else {
        parts[4] = '';
      }
      products.push(parts.join(';'))
    });
  }

  products = products.join(',');

  // updating s.events 

  if (products && products.indexOf('event410') !== -1) {
    events[0] = 'event410';
  }
  if (products && products.indexOf('event411') !== -1) {
    events[1] = 'event411';
  }

  if (products && products.indexOf('event506') !== -1) {
    events[2] = 'event506';
  }



  if (products && products.indexOf('event510') !== -1) {
    events[4] = 'event510';
  }

  if (products && products.indexOf('event509') !== -1) {
    events[5] = 'event509';
  }

  if (products && products.indexOf('event514') !== -1) {
    events[6] = 'event514';
  }
  if (products && products.indexOf('event513') !== -1) {
    events[7] = 'event513';
  }

  if (products && products.indexOf('event412') !== -1) {
    events[8] = 'event412';
  }

  if (products && products.indexOf('event414') !== -1) {
    events[9] = 'event414';
  }

  if (products && products.indexOf('event809') !== -1) {
    events[10] = 'event809';
  }

  events = cleanArray(events);
  if (events) {
    s.events = events.join(',');
  }
  return products;

};



return acLogic;
}
      }
    },
    "adobe_AM_offerid": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var
  offerIdLogic;

offerIdLogic = function (dl) {
  dl = dl || window.digitalData;
  var
    productsAM, 
    eVar90value, 
    offerId,
    aM = dl.accountManagement || dl.managePlan || {};

  if (typeof dl !== 'undefined' && 
    typeof dl.product !== 'undefined' && 
    typeof dl.product.productInfo !== 'undefined' && 
    typeof dl.product.productInfo.offerId !== 'undefined' && 
    dl.product.productInfo.offerId) {
    offerId = dl.product.productInfo.offerId;
    if (typeof aM.flowId !== 'undefined') {
      //evar 90 logic
      //cancelcomplete with event103
      if(aM.flowId == 'CancelComplete')
        eVar90value  = 'CancelComplete';
      else if (typeof aM.offers !== 'undefined' && 
        (aM.flowId == 'SwitchComplete' || aM.flowId == 'CancelSaveComplete') && 
        typeof aM.acceptedConcessionCode !== 'undefined' && 
        aM.acceptedConcessionCode) {
        eVar90value = aM.acceptedConcessionCode;
      }
      else if(aM.flowId === 'SearchSwitchComplete')
        eVar90value = 'OFFER_SEARCH';
      
      //cancel save complete event104
      // Switch Values
      else if (typeof dl.product.productInfo.switchToOfferType !== 'undefined' && typeof dl.product.productInfo.switchToOfferId !== 'undefined')
      {
        //UPGRADE with event100
        if(dl.product.productInfo.switchToOfferType === 'UPGRADE')
          eVar90value  = 'UPGRADE';
        //DOWNGRADE with event102
        if (dl.product.productInfo.switchToOfferType === 'DOWNGRADE')
          eVar90value  = 'DOWNGRADE';
        //SIDEGRADE with event99
        if (dl.product.productInfo.switchToOfferType === 'SIDEGRADE')
          eVar90value = 'SIDEGRADE';
      }
      //switch
      else if (typeof aM.offers !== 'undefined' && typeof aM.offers[0] !== 'undefined' && typeof aM.offers[0].code !== 'undefined' && aM.offers[0].code) {
        eVar90value = '';
        for (var i = 0; i < aM.offers.length; i++) {
          if(aM.offers[i].code.indexOf('FREE_DAYS') !== -1 &&  aM.flowId === 'FreeDaysComplete')
            eVar90value = aM.offers[i].code;
          else if(aM.flowId !== 'FreeDaysComplete')
          {
            if(eVar90value != '')
              eVar90value += '-';
            if (aM.offers[i]) {
              eVar90value += aM.offers[i].code;
            }
          }
        }
      }
    }
    if (typeof aM !== 'undefined' && typeof aM.etfMessage !== 'undefined' && aM.etfMessage)
      eVar90value += ':' + aM.etfMessage;
    if(eVar90value && typeof dl.product.productInfo.switchToOfferId !== 'undefined' && dl.product.productInfo.switchToOfferId)
      productsAM  = ';' + offerId + ';;;;eVar90=' + eVar90value + '|eVar97=SwitchFrom,;' + dl.product.productInfo.switchToOfferId + ';;;;eVar90=' + eVar90value + '|eVar97=SwitchTo;';
    else if(!eVar90value && typeof dl.product.productInfo.switchToOfferId !== 'undefined' && dl.product.productInfo.switchToOfferId)
      productsAM  = ';' + offerId + ';;;;eVar97=SwitchFrom,;' + dl.product.productInfo.switchToOfferId + ';;;;eVar97=SwitchTo;';
    else if (eVar90value)
      productsAM  = ';' + offerId + ';;;;eVar90=' + eVar90value + '|eVar97=SwitchFrom';
    else
      productsAM  = ';' + offerId;
    return productsAM;
  }
};

return offerIdLogic;

}
      }
    },
    "digitalData.adobe.experienceCloud.audienceManager": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  w = window,
  value = {},
  info = {},
  visitor = _satellite.getVisitorId();

// get version 
if (
  w.DIL &&
  w.DIL.version
) {
  info.version = w.DIL.version;
}

// get location hint
if (
  visitor
) {
  info.locationHint = visitor.getLocationHint();
}

// info
value.info = info;

return value;
}
      }
    },
    "aep_impression": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  // eslint-disable-next-line no-undef
return digitalData._get('digitalData.aep.impression');
}
      }
    },
    "digitalData.search.searchInfo.ctrProp": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
var eVar143 = '';

if (digitalData) {
  snapshot = digitalData._snapshot();

  eVar143 = snapshot._get('digitalData.search.searchInfo.linkClickPosition') !== 'ZERO' ? 'SRP' : 'KM';
  eVar143 += snapshot._get('digitalData.search.searchInfo.keyword') ? '|' + snapshot._get('digitalData.search.searchInfo.keyword') : '|';
  eVar143 += snapshot._get('digitalData.search.searchInfo.linkClickPosition') ? '|' + snapshot._get('digitalData.search.searchInfo.linkClickPosition') : '|';
  eVar143 += snapshot._get('digitalData.page.pageInfo.location.hostname') ? '|' + snapshot._get('digitalData.page.pageInfo.location.hostname') + snapshot._get('digitalData.page.pageInfo.location.pathname') : '|';
  eVar143 += snapshot._get('digitalData.search.searchInfo.linkUrl') ? '|' + snapshot._get('digitalData.search.searchInfo.linkUrl').replace(/http(s)?:\/\//, '').replace(/\?(.*)/, '') : '';

}
return eVar143;
}
      }
    },
    "isSite_Acrobat": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var hostname = window.location.hostname.toLowerCase(),
  is = false;

if (
  // production environments
  (hostname.indexOf('acrobat.adobe.com') !== -1) || 
  // staging environments
  (hostname.indexOf('stage.acrobat.adobe.com') !== -1)
) {
  is = true;
}
return is;
}
      }
    },
    "mbox_parameter_mar_aud": {
      "cleanText": true,
      "modulePath": "core/src/lib/dataElements/localStorage.js",
      "settings": {
        "name": "mar_aud"
      }
    },
    "adobe_performanceTimingLogic": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  /* global digitalData:true */
var
  preformanceTimingLogic;
preformanceTimingLogic = function (range1, range2) {
  var w = window,
    UNDEF = 'undefined',
    wp = w.performance || '',
    wpt = wp.timing || '';

  if (wpt && wpt.loadEventEnd !== UNDEF &&
    wpt.navigationStart !== UNDEF &&
    wpt.navigationStart > 0) {
    var pT = {},
      preformanceTiming = {},
      nS = wpt.navigationStart,
      lE = wpt.loadEventEnd,
      fS = wpt.fetchStart,
      dLS = wpt.domainLookupStart,
      dLE = wpt.domainLookupEnd,
      cE = wpt.connectEnd,
      cS = wpt.connectStart,
      rS = wpt.responseStart,
      rE = wpt.responseEnd,
      lES = wpt.loadEventStart,
      dL = wpt.domLoading,
      comp_range = function (obj1, obj2, limit) {
        return ((obj1 - obj2) / 1000 > limit[0] && (obj1 - obj2) / 1000 < limit[1]);
      };
    if (lE > 0 && comp_range(lE, nS, range2)) {
      if (comp_range(fS, nS, range1))
        pT.redirectTiming = ((fS - nS) / 1000).toFixed(2);
      if (comp_range(dLS, fS, range1))
        pT.appCacheTiming = ((dLS - fS) / 1000).toFixed(2);
      if (comp_range(dLE, dLS, range1))
        pT.dnsTiming = ((dLE - dLS) / 1000).toFixed(2);
      if (comp_range(cE, cS, range1))
        pT.tcpTiming = ((cE - cS) / 1000).toFixed(2);
      if (comp_range(rS, cE, range1))
        pT.requestTiming = ((rS - cE) / 1000).toFixed(2);
      if (comp_range(rE, rS, range1))
        pT.responseTiming = ((rE - rS) / 1000).toFixed(2);
      if (comp_range(lES, dL, range1))
        pT.processingTiming = ((lES - dL) / 1000).toFixed(2);
      if (comp_range(lE, lES, range1))
        pT.onLoadTiming = ((lE - lES) / 1000).toFixed(2);
      pT.totalPageLoadTime = ((lE - nS) / 1000).toFixed(2);
      preformanceTiming = pT;
      return preformanceTiming;
    }
    else
      return false;
  }
}
return preformanceTimingLogic;
}
      }
    },
    "aep_event_XDM": {
      "storageDuration": "pageview",
      "modulePath": "adobe-alloy/dist/lib/dataElements/xdmObject/index.js",
      "settings": {
        "data": {
          "web": {
            "webInteraction": {
              "name": "%aep_eventName%",
              "type": "other",
              "linkClicks": {
                "value": 1
              }
            },
            "webPageDetails": {
              "name": "%web.webPageDetails.name%",
              "server": "sstats.adobe.com",
              "viewName": "%web.webPageDetails.name%",
              "pageViews": {
                "value": 0
              },
              "siteSection": "%digitalData.page.pageInfo.siteSection%"
            }
          },
          "_adobe_corpnew": {
            "digitalData": {
              "form": "%aep_form%",
              "page": {
                "pageInfo": {
                  "language": "%digitalData.page.pageInfo.language%",
                  "pageName": "%web.webPageDetails.name%",
                  "siteSection": "%digitalData.page.pageInfo.siteSection%"
                }
              },
              "click": "%aep_interactions%",
              "primaryUser": {
                "primaryProfile": {
                  "profileInfo": {
                    "authState": "%aep_profileInfo.authState%",
                    "profileID": "%aep_profileInfo.profileID%",
                    "entitlementCreativeCloud": "%aep_profileInfo.entitlementCreativeCloud%"
                  }
                }
              }
            }
          }
        },
        "sandbox": {
          "name": "prod"
        }
      }
    },
    "aep_fb": {
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var fbp =_satellite.cookie.get('_fbp')||'';

digitalData._set('digitalData.marketingTags.facebook.fbp', fbp)

return fbp;
}
      }
    },
    "digitalData.page.pageInfo.location.hashValues": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var hash = window.location.hash.substring(1);
var params = {};
hash.split('&').map(function (hk) {
    var temp = hk.split('=');
    params[temp[0]] = temp[1];
});
//console.log(params.search);
return params.search;
}
      }
    },
    "marketingCloudServerSecure": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var 
  w = window,
  search = w.location.search,
  userAgent = w.navigator.userAgent,
  server = 'sstats.adobe.com';

// turn off redirect
if (
  // we this is a test
  (search.indexOf('performance=VisitorAPIParameterTweaks') !== -1) &&
  (
    // if Chrome
    // eslint-disable-next-line no-useless-escape
    /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/.test(userAgent) ||
    // if one of our lighthouse test devices
    userAgent.indexOf('Mozilla/5.0 (iPhone') !== -1
  )
) {
  server = '';
}

return server;

}
      }
    },
    "mbox_parameter_entityId": {
      "defaultValue": "",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  var meta = document.getElementsByTagName("meta"),
    entity = '';
if (meta.entity_id && (meta.entity_id.getAttribute('content') != null || undefined) ) {
  entity = meta.entity_id.getAttribute('content');
}
return entity;
}
      }
    },
    "analytics_account_adbadobenonacdc": {
      "defaultValue": "",
      "storageDuration": "pageview",
      "modulePath": "core/src/lib/dataElements/customCode.js",
      "settings": {
        "source": function(event) {
  // 2.17.2019 Added prototype report suite
// 4.10.2019 Added ability to append additional report suites

var
  w = window,
  h = w.location.hostname,
  p = w.location.pathname,
  account,
  additionalAccounts,
  hostnameContains,
  pathnameContains;

// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function (string) {
  return p.indexOf(string) !== -1;
};

// Reading the account information from digitalData if it is set already by Dev's
/*if(_satellite.getVar('digitalData.adobe.experienceCloud.analytics.account')){
  account = _satellite.getVar('digitalData.adobe.experienceCloud.analytics.account');
}*/
if (w.digitalData._get('adobe.experienceCloud.analytics.account')) {
  account = w.digitalData._get('adobe.experienceCloud.analytics.account');
}

//----------------------------------------------------------------------------
// Virgo Web - Grp-dc-web-analytics <dc-web-analytics@adobe.com>
//----------------------------------------------------------------------------

// dev/stage
if (
  hostnameContains('local-test.acrobat.com') ||
  hostnameContains('dc.dev.dexilab.acrobat.com') ||
  hostnameContains('dc.dev.dexilab.adobe.com') ||
  hostnameContains('dc.stage.acrobat.com') ||
  hostnameContains('dc.stage.adobe.com')
) {
  account = 'adbadobenonacdcqa,adbdcwebqa';

  // prod
} else if (
  hostnameContains('dc.acrobat.com') ||
  hostnameContains('dc.adobe.com') ||
  hostnameContains('documentcloud.adobe.com')
) {
  account = 'adbadobenonacdcprod,adbdcwebprod';



  //----------------------------------------------------------------------------
  // Lancelot Web App <waters@adobe.com>
  //----------------------------------------------------------------------------
  // dev
  // stage
  // prod
} else if (
  (hostnameContains('pdfnow.corp.adobe.com') ||
    hostnameContains('pdfsexy.corp.adobe.com')) &&
  typeof window.marketingtech !== 'undefined' &&
  typeof window.marketingtech.adobe !== 'undefined' &&
  typeof window.marketingtech.adobe.launch !== 'undefined' &&
  typeof window.marketingtech.adobe.launch.environment !== 'undefined' &&
  window.marketingtech.adobe.launch.environment == 'dev'
) {
  account = 'adbadblancelotqa';

} else if (
  (hostnameContains('pdfnow.corp.adobe.com') ||
    hostnameContains('pdfsexy.corp.adobe.com'))
) {
  account = 'adbadblancelotprod';



  //----------------------------------------------------------------------------
  // CC Engagement - ORG-TIMBERT-ALL <ORG-TIMBERT-ALL@adobe.com>
  //----------------------------------------------------------------------------
  // dev
  // stage
  // prod
} else if (
  hostnameContains('adobelanding.com')
) {
  account = 'adbadobenonacdcprod,adbccgrowth';

  //----------------------------------------------------------------------------
  // bizable.com 
  //----------------------------------------------------------------------------
} else if (
  hostnameContains('bizible.com')
) {
  account = 'adbadobenonacdcprod,biziblecookiepoc';

  //----------------------------------------------------------------------------
  // magento.com 
  //----------------------------------------------------------------------------
} else if (
  hostnameContains('magento.com')
) {
  account = 'adbadobenonacdcprod,adbadobedxprod';

  //----------------------------------------------------------------------------
  // fallback
  //----------------------------------------------------------------------------
} else {

  // if we are using the production environment
  if (_satellite.buildInfo.environment === 'production') {
    account = 'adbadobenonacdcprod';

    // if we are using anything else
  } else {
    account = 'adbadobenonacdcqa';
  }
}

// DX Pages will be moving to the right version of Dexter in June so we can work with that team to remove parts of this logic in June
if ( h =='business.stage.adobe.com' || h =='business.adobe.com' || h =='business.con-b.adobe.com' || pathnameContains('/summit/2020/') || p === '/summit.html' || p === '/summit/thank-you.html' || pathnameContains('/experience-cloud/cxm-playbook') || pathnameContains('/summit/2020/') || pathnameContains('/events/government-symposium') || pathnameContains('/experience-makers-live') || pathnameContains('/experience-cloud') || pathnameContains('/analytics') || pathnameContains('/what-is-adobe-experience-cloud') || pathnameContains('/experience-platform') || pathnameContains('/advertising') || pathnameContains('/marketing') || pathnameContains('/commerce') || pathnameContains('/experience-cloud-it') || pathnameContains('/request-consultation') || pathnameContains('/industries')) {
  if (account.indexOf('adbadobenonacdcprod') !== -1) 
    account += ',adbadobedxprod';
  else if (account.indexOf('adbadobenonacdcqa') !== -1)
    account += ',adbadobedxqa';
}

// prototype report suite
if (account.indexOf('adbadobenonacdcprod') !== -1) {
  account += ',adbadobeprototype';
}

// additional Accounts
additionalAccounts = _satellite._getQueryParam('marketingtech.adobe.analytics.additionalAccounts');
if (additionalAccounts) {
  account += (
    (additionalAccounts.indexOf(',') === 0) ? '' : ','
  ) + additionalAccounts;
}

if (
  w.marketingtech &&
  w.marketingtech.adobe &&
  w.marketingtech.adobe.analytics &&
  w.marketingtech.adobe.analytics.additionalAccounts
) {
  digitalData._set('adobe.analytics.additionalAccounts',w.marketingtech.adobe.analytics.additionalAccounts);
  additionalAccounts = w.marketingtech.adobe.analytics.additionalAccounts;
  account += (
    (additionalAccounts.indexOf(',') === 0) ? '' : ','
  ) + additionalAccounts;
}


// eslint-disable-next-line no-undef
if (
  hostnameContains('stage2.adminconsole.adobe.com') ||
  hostnameContains('stage.adminconsole.adobe.com') 
) {
  account = 'adbadobenonacdcqa,amc.global.dev,amc.aac.dev';
}

if (account) {
  account = account.replace(/[ ]/g, '').split(',');
  var result = [];
  for (var i = 0; i < account.length; i++) {
    if (result.indexOf(account[i]) == -1) result.push(account[i]);
  }

  account = result.join(',');
}

return account;
}
      }
    }
  },
  "extensions": {
    "core": {
      "displayName": "Core",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EP205185a6537e4aacbdc36b05eb266113/",
      "modules": {
        "core/src/lib/dataElements/customCode.js": {
          "name": "custom-code",
          "displayName": "Custom Code",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

/**
 * The custom data element.
 * @param {Object} settings The data element settings object.
 * @param {string} settings.source The function that should be called which will return a value.
 * @param {string} event The event (if any) that triggered the evaluation of the data element.
 * @returns {string}
 */
module.exports = function(settings, event) {
  return settings.source(event);
};

          }

        },
        "core/src/lib/dataElements/localStorage.js": {
          "name": "local-storage",
          "displayName": "Local Storage",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var window = require('@adobe/reactor-window');

/**
 * The local storage data element.
 * @param {Object} settings The data element settings object.
 * @param {string} settings.name The name of the local storage item for which a value should be
 * retrieved.
 * @returns {string}
 */
module.exports = function(settings) {
  // When local storage is disabled on Safari, the mere act of referencing window.localStorage
  // throws an error. For this reason, referencing window.localStorage without being inside
  // a try-catch should be avoided.
  try {
    return window.localStorage.getItem(settings.name);
  } catch (e) {
    return null;
  }
};

          }

        },
        "core/src/lib/conditions/customCode.js": {
          "name": "custom-code",
          "displayName": "Custom Code",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

/**
 * Custom code condition. This executes condition code provided by the user.
 * @param {Object} settings Condition settings.
 * @param {Function} settings.source The custom script function.
 * @param {Object} event The underlying event object that triggered the rule.
 * @param {Object} event.element The element that the rule was targeting.
 * @param {Object} event.target The element on which the event occurred.
 * @returns {boolean}
 */
module.exports = function(settings, event) {
  // `this` and `target` are provided separately from event for backward-compatibility.
  return settings.source.call(event.element, event, event.target);
};

          }

        },
        "core/src/lib/events/keyPress.js": {
          "name": "key-press",
          "displayName": "Key Press",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';
var bubbly = require('./helpers/createBubbly')();

document.addEventListener('keypress', bubbly.evaluateEvent, true);

/**
 * The keypress event. This event occurs when a key is pressed down and the key normally produces
 * a character value.
 * @param {Object} settings The event settings object.
 * @param {string} [settings.elementSelector] The CSS selector the element must match in order for
 * the rule to fire.
 * @param {Object[]} [settings.elementProperties] Property values the element must have in order
 * for the rule to fire.
 * @param {string} settings.elementProperties[].name The property name.
 * @param {string} settings.elementProperties[].value The property value.
 * @param {boolean} [settings.elementProperties[].valueIsRegex=false] Whether <code>value</code>
 * on the object instance is intended to be a regular expression.
 * @param {boolean} [settings.bubbleFireIfParent=true] Whether the rule should fire if
 * the event originated from a descendant element.
 * @param {boolean} [settings.bubbleFireIfChildFired=true] Whether the rule should fire
 * if the same event has already triggered a rule targeting a descendant element.
 * @param {boolean} [settings.bubbleStop=false] Whether the event should not trigger
 * rules on ancestor elements.
 * @param {ruleTrigger} trigger The trigger callback.
 */
module.exports = function(settings, trigger) {
  bubbly.addListener(settings, trigger);
};

          }

        },
        "core/src/lib/events/click.js": {
          "name": "click",
          "displayName": "Click",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var window = require('@adobe/reactor-window');
var bubbly = require('./helpers/createBubbly')();
var WeakMap = require('./helpers/weakMap');
var evaluatedEvents = new WeakMap();

/**
 * Determines whether an element is a link that would navigate the user's current window to a
 * different URL.
 * @param node
 * @returns {boolean}
 */
var getDelayableLink = function(node) {
  while (node) {
    var tagName = node.tagName;

    if (tagName && tagName.toLowerCase() === 'a') {
      var href = node.getAttribute('href');
      var target = node.getAttribute('target');

      if (
        href &&
        (
          !target ||
          target === '_self' ||
          (target === '_top' && window.top === window) ||
          target === window.name
        )
      ) {
        return node;
      } else {
        // No need to continue searching ancestry.
        return;
      }
    }

    node = node.parentNode;
  }
};

document.addEventListener('click', bubbly.evaluateEvent, true);

/**
 * The click event. This event occurs when a user has clicked an element.
 * @param {Object} settings The event settings object.
 * @param {string} [settings.elementSelector] The CSS selector the element must match in order for
 * the rule to fire.
 * @param {Object[]} [settings.elementProperties] Property values the element must have in order
 * for the rule to fire.
 * @param {string} settings.elementProperties[].name The property name.
 * @param {string} settings.elementProperties[].value The property value.
 * @param {number} [settings.anchorDelay] When present and a link is clicked, actual
 * navigation will be postponed for a period of time equal with its value. This is typically used to
 * allow time for scripts within the rule to execute, beacons to be sent to servers, etc.
 * @param {boolean} [settings.elementProperties[].valueIsRegex=false] Whether <code>value</code>
 * on the object instance is intended to be a regular expression.
 * @param {boolean} [settings.bubbleFireIfParent=true] Whether the rule should fire if
 * the event originated from a descendant element.
 * @param {boolean} [settings.bubbleFireIfChildFired=true] Whether the rule should fire
 * if the same event has already triggered a rule targeting a descendant element.
 * @param {boolean} [settings.bubbleStop=false] Whether the event should not trigger
 * rules on ancestor elements.
 * @param {ruleTrigger} trigger The trigger callback.
 */
module.exports = function(settings, trigger) {
  bubbly.addListener(settings, function(syntheticEvent) {
    var nativeEvent = syntheticEvent.nativeEvent;

    // AppMeasurement captures the click events, and tries to detect if the element clicked is an A
    // tag that contains an exit link. When that happens, it stops the initial event, sends a
    // beacon, clones the initial event and fires it again.
    // Reactor detects the click events first, because its listeners are set on the capture phase.
    // We need to ignore the cloned event, otherwise the same rule will fire twice. AppMeasurement
    // sets `s_fe` attribute on the cloned event, and that is the flag we'll use to ignore these
    // fake events.
    // https://git.corp.adobe.com/analytics-platform/appmeasurement/blob/master/bin/js/src/AppMeasurement.js#L3196
    if (nativeEvent.s_fe) {
      return;
    }

    if (settings.anchorDelay) {
      if (!evaluatedEvents.has(nativeEvent)) {
        var delayableLink = getDelayableLink(nativeEvent.target);
        if (delayableLink) {
          nativeEvent.preventDefault();
          setTimeout(function() {
            window.location = delayableLink.href;
          }, settings.anchorDelay);
        }
        evaluatedEvents.set(nativeEvent, true);
      }
    }

    trigger(syntheticEvent);
  });
};

/**
 * @private
 * Clears all listeners. This should only be used in tests.
 */
module.exports.__reset = bubbly.__reset;

          }

        },
        "core/src/lib/events/directCall.js": {
          "name": "direct-call",
          "displayName": "Direct Call",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

/**
 * Object where the key is the call name and the value is an array of all rule trigger functions
 * for that call name.
 * @type {Object}
 */
var triggersByIdentifier = {};

window._satellite = window._satellite || {};

/**
 * Public function intended to be called by the user.
 * @param {string} identifier The identifier passed to _satellite.track().
 * @param {*} [detail] Any detail that should be passed along to conditions and actions.
 */
window._satellite.track = function(identifier, detail) {
  identifier = identifier.trim();
  var triggers = triggersByIdentifier[identifier];
  if (triggers) {
    var syntheticEvent = {
      identifier: identifier,
      detail: detail
    };

    triggers.forEach(function(trigger) {
      trigger(syntheticEvent);
    });

    var logMessage = 'Rules using the direct call event type with identifier "' + identifier +
      '" have been triggered' + (detail ? ' with additional detail:' : '.');
    var logArgs = [logMessage];

    if (detail) {
      logArgs.push(detail);
    }

    turbine.logger.log.apply(turbine.logger, logArgs);
  } else {
    turbine.logger.log('"' + identifier + '" does not match any direct call identifiers.');
  }
};

/**
 * Direct call event. This event occurs as soon as the user calls _satellite.track().
 * @param {Object} settings The event settings object.
 * @param {string} settings.identifier The identifier passed to _satellite.track().
 * @param {ruleTrigger} trigger The trigger callback.
 */
module.exports = function(settings, trigger) {
  var triggers = triggersByIdentifier[settings.identifier];

  if (!triggers) {
    triggers = triggersByIdentifier[settings.identifier] = [];
  }

  triggers.push(trigger);
};

          }

        },
        "core/src/lib/conditions/valueComparison.js": {
          "name": "value-comparison",
          "displayName": "Value Comparison",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * (c) 2018 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

/*eslint eqeqeq:0*/
'use strict';

var isNumber = function(value) {
  return typeof value === 'number' && isFinite(value); // isFinite weeds out NaNs.
};

var isString = function(value) {
  return typeof value === 'string' || value instanceof String;
};

var updateCase = function(operand, caseInsensitive) {
  return caseInsensitive && isString(operand) ? operand.toLowerCase() : operand;
};

var castToStringIfNumber = function(operand) {
  return isNumber(operand) ? String(operand) : operand;
};

var castToNumberIfString = function(operand) {
  return isString(operand) ? Number(operand) : operand;
};

var guardStringCompare = function(compare) {
  return function(leftOperand, rightOperand, caseInsensitive) {
    leftOperand = castToStringIfNumber(leftOperand);
    rightOperand = castToStringIfNumber(rightOperand);

    return (
      isString(leftOperand) &&
      isString(rightOperand) &&
      compare(leftOperand, rightOperand, caseInsensitive)
    );
  };
};

var guardNumberCompare = function(compare) {
  return function(leftOperand, rightOperand) {
    leftOperand = castToNumberIfString(leftOperand);
    rightOperand = castToNumberIfString(rightOperand);

    return (
      isNumber(leftOperand) &&
      isNumber(rightOperand) &&
      compare(leftOperand, rightOperand)
    );
  };
};

var guardCaseSensitivity = function(compare) {
  return function(leftOperand, rightOperand, caseInsensitive) {
    return compare(
      updateCase(leftOperand, caseInsensitive),
      updateCase(rightOperand, caseInsensitive)
    );
  };
};

var conditions = {
  equals: guardCaseSensitivity(function(leftOperand, rightOperand) {
    return leftOperand == rightOperand;
  }),
  doesNotEqual: function() {
    return !conditions.equals.apply(null, arguments);
  },
  contains: guardStringCompare(guardCaseSensitivity(function(leftOperand, rightOperand) {
    return leftOperand.indexOf(rightOperand) !== -1;
  })),
  doesNotContain: function() {
    return !conditions.contains.apply(null, arguments);
  },
  startsWith: guardStringCompare(guardCaseSensitivity(function(leftOperand, rightOperand) {
    return leftOperand.indexOf(rightOperand) === 0;
  })),
  doesNotStartWith: function() {
    return !conditions.startsWith.apply(null, arguments);
  },
  endsWith: guardStringCompare(guardCaseSensitivity(function(leftOperand, rightOperand) {
    return leftOperand.substring(
      leftOperand.length - rightOperand.length,
      leftOperand.length
    ) === rightOperand;
  })),
  doesNotEndWith: function() {
    return !conditions.endsWith.apply(null, arguments);
  },
  matchesRegex: guardStringCompare(function(leftOperand, rightOperand, caseInsensitive) {
    // Doing something like new RegExp(/ab+c/, 'i') throws an error in some browsers (e.g., IE11),
    // so we don't want to instantiate the regex until we know we're working with a string.
    return new RegExp(rightOperand, caseInsensitive ? 'i' : '').test(leftOperand);
  }),
  doesNotMatchRegex: function() {
    return !conditions.matchesRegex.apply(null, arguments);
  },
  lessThan: guardNumberCompare(function(leftOperand, rightOperand) {
    return leftOperand < rightOperand;
  }),
  lessThanOrEqual: guardNumberCompare(function(leftOperand, rightOperand) {
    return leftOperand <= rightOperand;
  }),
  greaterThan: guardNumberCompare(function(leftOperand, rightOperand) {
    return leftOperand > rightOperand;
  }),
  greaterThanOrEqual: guardNumberCompare(function(leftOperand, rightOperand) {
    return leftOperand >= rightOperand;
  }),
  isTrue: function(leftOperand) {
    return leftOperand === true;
  },
  isTruthy: function(leftOperand) {
    return Boolean(leftOperand);
  },
  isFalse: function(leftOperand) {
    return leftOperand === false;
  },
  isFalsy: function(leftOperand) {
    return !leftOperand;
  },
};

module.exports = function(settings) {
  return conditions[settings.comparison.operator](
    settings.leftOperand,
    settings.rightOperand,
    Boolean(settings.comparison.caseInsensitive)
  );
};

          }

        },
        "core/src/lib/events/windowLoaded.js": {
          "name": "window-loaded",
          "displayName": "Window Loaded",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var pageLifecycleEvents = require('./helpers/pageLifecycleEvents');

/**
 * Window loaded event. This event occurs at the end of the document loading process. At this point,
 * all of the objects in the document are loaded in the DOM, and all images, scripts, links,
 * and sub-frames have finished loading.
 * @param {Object} settings The event settings object.
 * @param {ruleTrigger} trigger The trigger callback.
 */
module.exports = function(settings, trigger) {
  pageLifecycleEvents.registerWindowLoadedTrigger(trigger);
};

          }

        },
        "core/src/lib/events/customCode.js": {
          "name": "custom-code",
          "displayName": "Custom Code",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

/**
 * Custom code event. This executes event code provided by the user. The user's code will call
 * <code>trigger</code> when the rule should fire.
 * @param {Object} settings The event settings object.
 * @param {Function} settings.source The custom script function.
 */
module.exports = function(settings, trigger) {
  settings.source(trigger);
};

          }

        },
        "core/src/lib/actions/customCode.js": {
          "name": "custom-code",
          "displayName": "Custom Code",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var document = require('@adobe/reactor-document');
var decorateCode = require('./helpers/decorateCode');
var loadCodeSequentially = require('./helpers/loadCodeSequentially');
var postscribe = require('../../../node_modules/postscribe/dist/postscribe');
var extensionSettings = turbine.getExtensionSettings();

var postscribeWrite = (function() {
  var write = function(source) {
    postscribe(document.body, source, {
      beforeWriteToken: function(tag) {
        if (extensionSettings.cspNonce && tag.tagName === 'script') {
          tag.attrs.nonce = extensionSettings.cspNonce;
        }
        return tag;
      },
      error: function(error) {
        turbine.logger.error(error.msg);
      }
    });
  };

  var queue = [];

  // If the Launch library is loaded asynchronously, it may finish loading before document.body
  // is available. This means the custom code action may be running before document.body is
  // available, in which case can't write the custom code to document.body. We could, in this
  // case, write it to document.head since it will for sure be available, but the user's custom
  // code may have something like an img tag for sending a beacon (this use case was seen in DTM).
  // Adding display elements like an img tag to document.head is against HTML spec, though it
  // does seem like an image request is still made. We opted instead to ensure we comply with
  // HTML spec and wait until we see that document.body is available before writing.
  var flushQueue = function() {
    if (document.body) {
      while (queue.length) {
        write(queue.shift());
      }
    } else {
      // 20 is an arbitrarily small amount of time but not too aggressive.
      setTimeout(flushQueue, 20);
    }
  };

  return function(source) {
    queue.push(source);
    flushQueue();
  };
})();

var libraryWasLoadedAsynchronously = (function() {
  // document.currentScript is not supported by IE
  if (document.currentScript) {
    return document.currentScript.async;
  } else {
    var scripts = document.querySelectorAll('script');
    for (var i = 0; i < scripts.length; i++) {
      var script = scripts[i];
      // Find the script that loaded our library. Take into account embed scripts migrated
      // from DTM. We'll also consider that they may have added a querystring for cache-busting
      // or whatever.
      if (/(launch|satelliteLib)-[^\/]+.js(\?.*)?$/.test(script.src)) {
        return script.async;
      }
    }
    // We couldn't find the Launch script, so we'll assume it was loaded asynchronously. This
    // is the safer assumption.
    return true;
  }
})();

/**
 * The custom code action. This loads and executes custom JavaScript or HTML provided by the user.
 * @param {Object} settings Action settings.
 * @params {boolean} settings.isExternal When true, <code>settings.source</code> contains the
 * code itself. When false, <code>settings.source</code> contains a relative path to the file
 * containing the user's code.
 * @param {string} settings.source If <code>settings.external</code> is <code>false</code>,
 * this will be the user's code. Otherwise, it will be a relative path to the file containing
 * the user's code.
 * @param {string} settings.language The language of the user's code. Must be either javascript or
 * html.
 * @param {Object} event The underlying event object that triggered the rule.
 * @param {Object} event.element The element that the rule was targeting.
 * @param {Object} event.target The element on which the event occurred.
 * <code>javascript</code> or <code>html</code>.
 */
module.exports = function(settings, event) {
  var action = {
    settings: settings,
    event: event
  };

  var source = action.settings.source;
  if (!source) {
    return;
  }

  if (action.settings.isExternal) {
    return loadCodeSequentially(source).then(function(source) {
      if (source) {
        postscribeWrite(decorateCode(action, source));
      }
    });
  } else {
    // This area has been modified several times, so here are some helpful details:
    // 1. Custom code will be included into the main launch library if it's for a rule that uses the
    //    Library Loaded or Page Bottom event. isExternal will be false. However, keep in mind that
    //    the same rule may have other events that are not Library Loaded or Page Bottom. This means
    //    we could see isExternal = false on the action when the event that fired the rule is
    //    a click, for example.
    // 2. When users load a library synchronously which has a rule using the Library Loaded
    //    or Page Bottom event with a Custom Code action, they expect the custom code to be written
    //    to the document in a blocking fashion (prevent the parser from continuing until their
    //    custom code is executed). In other words, they expect document.write to be used. When
    //    the library is loaded asynchronously, they do not have this expectation. However, note
    //    that if the Library Loaded event is used and the website does not call
    //    _satellite.pageBottom(), page bottom rules will be run when the DOMContentLoaded event
    //    is fired (at which point we can't use document.write or it will wipe out website content).
    // 3. Calls to document.write will be ignored by the browser if the Launch library is loaded
    //    asynchronously, even if the calls are made before DOMContentLoaded.
    // 4. There's a bug in IE 10 where readyState is sometimes set to "interactive" too
    //    early (before DOMContentLoaded has fired). https://bugs.jquery.com/ticket/12282
    //    This may cause Postscribe to be used sometimes when document.write() could have been
    //    used instead, but we have concluded that IE 10 usage is low enough and the risk small
    //    enough that this behavior is tolerable.
    if (!libraryWasLoadedAsynchronously && document.readyState === 'loading') {
      // Document object in XML files is different from the ones in HTML files. Documents served
      // with the `application/xhtml+xml` MIME type don't have the `document.write` method.
      // More info:
      // https://www.w3.org/MarkUp/2004/xhtml-faq#docwrite
      // https://developer.mozilla.org/en-US/docs/Archive/Web/Writing_JavaScript_for_HTML
      if (document.write) {
        document.write(decorateCode(action, source));
      } else {
        postscribeWrite(decorateCode(action, source));
      }
    } else {
      postscribeWrite(decorateCode(action, source));
    }
  }
};

          }

        },
        "core/src/lib/events/libraryLoaded.js": {
          "name": "library-loaded",
          "displayName": "Library Loaded (Page Top)",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var pageLifecycleEvents = require('./helpers/pageLifecycleEvents');

/**
 * Library loaded event. This event occurs as soon as the runtime library is loaded.
 * @param {Object} settings The event settings object.
 * @param {ruleTrigger} trigger The trigger callback.
 */
module.exports = function(settings, trigger) {
  pageLifecycleEvents.registerLibraryLoadedTrigger(trigger);
};

          }

        },
        "core/src/lib/events/pageBottom.js": {
          "name": "page-bottom",
          "displayName": "Page Bottom",
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var pageLifecycleEvents = require('./helpers/pageLifecycleEvents');

/**
 * Page bottom event. This event occurs as soon as the user calls _satellite.pageBottom() (which is
 * supposed to be at the bottom of the page).
 * @param {Object} settings The event settings object.
 * @param {ruleTrigger} trigger The trigger callback.
 */
module.exports = function(settings, trigger) {
  pageLifecycleEvents.registerPageBottomTrigger(trigger);
};

          }

        },
        "core/src/lib/events/helpers/createBubbly.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var WeakMap = require('./weakMap');
var matchesProperties = require('./matchesProperties');
var matchesSelector = require('./matchesSelector');

// Note to developers of other extensions:
// This module largely exists to support advanced bubbling options
// that were carried over to Launch from DTM. It is highly unlikely
// that you need to support these options in your own extension.
// As such, please only copy this code if you know why you're doing so
// and feel you have a justifiable reason.

/**
 * Handles logic related to bubbling options provided for many event types.
 */
module.exports = function() {
  var listeners = [];

  // It's important that a new weak map is created for each instance of bubbly in order to store
  // whether this particular bubbly instance has processed the event. More than one instance of
  // bubbly may process an event. No instance of bubbly should process an event more than once.
  var processedEvents = new WeakMap();

  var bubbly = {
    /**
     * Register a config object that should be evaluated for an event to determine if a rule
     * should be executed. If it should be executed, the callback function will be called.
     * @param {Object} settings The event config object.
     * @param {string} [settings.elementSelector] The CSS selector the element must match in order
     * for the rule to fire.
     * @param {Object[]} [settings.elementProperties] Property values the element must have in order
     * for the rule to fire.
     * @param {string} settings.elementProperties[].name The property name.
     * @param {string} settings.elementProperties[].value The property value.
     * @param {boolean} [settings.elementProperties[].valueIsRegex=false] Whether <code>value</code>
     * on the object instance is intended to be a regular expression.
     * @param {boolean} [settings.bubbleFireIfParent=true] Whether the rule should fire if the
     * event originated from a descendant element.
     * @param {boolean} [settings.bubbleFireIfChildFired=true] Whether the rule should fire if the
     * same event has already triggered a rule targeting a descendant element.
     * @param {boolean} [settings.bubbleStop=false] Whether the event should not trigger rules on
     * ancestor elements.
     * @param {Function} callback The function to be called when a matching event is seen. If the
     * callback does not end up triggering a rule, the callback should explicitly return false.
     */
    addListener: function(settings, callback) {
      listeners.push({
        settings: settings,
        callback: callback
      });
    },
    /**
     * Evaluate an event to determine if any rule targeting elements in the event target's DOM
     * hierarchy should be executed. Note that event.type is not inspected. This assumes that
     * all registered listeners care about this particular event type.
     * @param {Event} event The event that has occurred.
     * @param {HTMLElement} event.target The HTML element where the event originated.
     * @param {boolean} [eventIsSynthetic] Whether the event passed in is synthetic (instead of
     * native).
     */
    evaluateEvent: function(event, eventIsSynthetic) {
      if (!listeners.length) {
        return;
      }

      // When an event is handled it is evaluated a single time but checks out which rules are
      // targeting elements starting at the target node and looking all the way up the element
      // hierarchy. This should only happen once regardless of how many listeners exist for the
      // event.
      if (processedEvents.has(event)) {
        return;
      }

      var node = event.target;
      var childHasTriggeredRule = false;

      // Loop through from the event target up through the hierarchy evaluating each node
      // to see if it matches any rules.
      while (node) {
        var preventEvaluationOnAncestors = false;

        var nodeTriggeredRule = false;

        // Just because this could be processed a lot, we'll use a for loop instead of forEach.
        for (var i = 0; i < listeners.length; i++) {
          var listener = listeners[i];
          var elementSelector = listener.settings.elementSelector;
          var elementProperties = listener.settings.elementProperties;

          // bubbleFireIfChildFired should be considered true by default
          if (listener.settings.bubbleFireIfChildFired === false && childHasTriggeredRule) {
            continue;
          }

          // bubbleFireIfParent should be considered true by default
          if (node !== event.target && listener.settings.bubbleFireIfParent === false) {
            continue;
          }

          // If the user didn't specify elementSelector or elementProperties then they want the
          // rule to run whenever the event occurs on any element. They don't intend for the
          // rule to run for every node in the element hierarchy though.
          if (node !== event.target && !elementSelector &&
              (!elementProperties || !Object.keys(elementProperties).length)) {
            continue;
          }

          if (elementSelector && !matchesSelector(node, elementSelector)) {
            continue;
          }

          if (elementProperties && !matchesProperties(node, elementProperties)) {
            continue;
          }

          var syntheticEventForCallback = {};

          // We'll attach relevant data depending on whether the passed in event is synthetic
          // or native.
          if (eventIsSynthetic) {
            Object.keys(event).forEach(function(key) {
              syntheticEventForCallback[key] = event[key];
            });
          } else {
            syntheticEventForCallback.nativeEvent = event;
          }

          syntheticEventForCallback.element = node;
          syntheticEventForCallback.target = event.target;

          var callbackResponse = listener.callback(syntheticEventForCallback);

          // The callback should return false if it didn't end up triggering a rule.
          var ruleTriggered = callbackResponse !== false;

          if (ruleTriggered) {
            nodeTriggeredRule = true;

            if (listener.settings.bubbleStop) {
              preventEvaluationOnAncestors = true;
            }
          }
        }

        if (preventEvaluationOnAncestors) {
          break;
        }

        if (nodeTriggeredRule) {
          childHasTriggeredRule = true;
        }

        node = node.parentNode;
      }

      processedEvents.set(event, true);
    }
  };

  /**
   * @private
   * Clears all listeners. This should only be used in tests.
   */
  bubbly.__reset = function() {
    listeners = [];
  };

  return bubbly;
};

          }

        },
        "core/src/lib/events/helpers/weakMap.js": {
          "script": function(module, exports, require, turbine) {
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// This is copied from
// https://github.com/webcomponents/webcomponentsjs/blob/7dc6731eb9c9f9c3fea4419c50c6ee3ca0367544/src/WeakMap/WeakMap.js
// because there's not an npm package that makes it easy to import only WeakMap. We've also
// modified it slightly so that it doesn't ever set window.WeakMap.

'use strict';

var window = require('@adobe/reactor-window');
var WeakMap = window.WeakMap;

if (typeof WeakMap === 'undefined') {
  var defineProperty = Object.defineProperty;
  var counter = Date.now() % 1e9;

  WeakMap = function() {
    this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
  };

  WeakMap.prototype = {
    set: function(key, value) {
      var entry = key[this.name];
      if (entry && entry[0] === key)
        entry[1] = value;
      else
        defineProperty(key, this.name, {value: [key, value], writable: true});
      return this;
    },
    get: function(key) {
      var entry;
      return (entry = key[this.name]) && entry[0] === key ?
        entry[1] : undefined;
    },
    delete: function(key) {
      var entry = key[this.name];
      if (!entry || entry[0] !== key) return false;
      entry[0] = entry[1] = undefined;
      return true;
    },
    has: function(key) {
      var entry = key[this.name];
      if (!entry) return false;
      return entry[0] === key;
    }
  };
}

module.exports = WeakMap;

          }

        },
        "core/src/lib/events/helpers/matchesProperties.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var textMatch = require('./../../helpers/textMatch');

var getElementProperty = function(element, property) {
  if (property === '@text' || property === 'innerText') {
    return element.textContent || element.innerText;
  } else if (property in element) {
    return element[property];
  } else if (element.getAttribute) {
    return element.getAttribute(property);
  }
};

/**
 * Determines whether an element's properties and their values match a set of properties and values.
 * If the element doesn't have the property, the element's attribute with the same name will be
 * evaluated if it exists.
 * @param {HTMLElement} element The element to match against.
 * @param {Object[]} properties The criteria of properties to match again.
 * @param {string} properties.name The property name.
 * @param {string} properties.value The property value.
 * @param {boolean} [properties.valueIsRegex=false] Whether <code>value</code> on the
 * object instance is intended to be a regular expression.
 * @returns {boolean} Whether the element matches the criteria.
 */
module.exports = function(element, properties) {
  if (properties) {
    return properties.every(function(property) {
      var actualValue = getElementProperty(element, property.name);
      var criterionValue = property.valueIsRegex ? new RegExp(property.value, 'i') : property.value;
      return textMatch(actualValue, criterionValue);
    });
  }
  return true;
};

          }

        },
        "core/src/lib/events/helpers/matchesSelector.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

/**
 * Returns whether an element matches a selector.
 * @param {HTMLElement} element The HTML element being tested.
 * @param {string} selector The CSS selector.
 * @returns {boolean}
 */
module.exports = function(element, selector) {
  var matches = element.matches || element.msMatchesSelector;

  if (matches) {
    try {
      return matches.call(element, selector);
    } catch (error) {
      turbine.logger.warn('Matching element failed. ' + selector + ' is not a valid selector.');
      return false;
    }
  }

  return false;
};

          }

        },
        "core/src/lib/helpers/textMatch.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

/**
 * Performs a string match based on another string or a regex.
 * @param {string} str The string to be evaluate.
 * @param {string|RegExp} pattern The pattern to match against.
 * @returns {boolean} Whether the string matches the pattern.
 */
module.exports = function(str, pattern) {
  if (pattern == null) {
    throw new Error('Illegal Argument: Pattern is not present');
  }
  if (str == null) {
    return false;
  }
  if (typeof pattern === 'string') {
    return str === pattern;
  } else if (pattern instanceof RegExp) {
    return pattern.test(str);
  } else {
    return false;
  }
};

          }

        },
        "core/src/lib/events/helpers/pageLifecycleEvents.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * (c) 2018 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

// We need to be able to fire the rules in a specific order, no matter if the library is loaded
// sync or async. The rules are fired in the following order:
// Library loaded rules -> Page bottom rules -> Dom Ready rules -> Window load rules.

var window = require('@adobe/reactor-window');
var document = require('@adobe/reactor-document');

var isIE10 = window.navigator.appVersion.indexOf('MSIE 10') !== -1;
var WINDOW_LOADED = 'WINDOW_LOADED';
var DOM_READY = 'DOM_READY';
var PAGE_BOTTOM = 'PAGE_BOTTOM';

var lifecycleEventsOrder = [PAGE_BOTTOM, DOM_READY, WINDOW_LOADED];

var createSyntheticEvent = function(element, nativeEvent) {
  return {
    element: element,
    target: element,
    nativeEvent: nativeEvent
  };
};

var registry = {};
lifecycleEventsOrder.forEach(function(event) {
  registry[event] = [];
});

var processRegistry = function(lifecycleEvent, nativeEvent) {
  lifecycleEventsOrder
    .slice(0, getLifecycleEventIndex(lifecycleEvent) + 1)
    .forEach(function(lifecycleEvent) {
      processTriggers(nativeEvent, lifecycleEvent);
    });
};

var detectLifecycleEvent = function() {
  if (document.readyState === 'complete') {
    return WINDOW_LOADED;
  } else if (document.readyState === 'interactive') {
    return !isIE10 ? DOM_READY : null;
  }
};

var getLifecycleEventIndex = function(event) {
  return lifecycleEventsOrder.indexOf(event);
};

var processTriggers = function(nativeEvent, lifecycleEvent) {
  registry[lifecycleEvent].forEach(function(triggerData) {
    processTrigger(nativeEvent, triggerData);
  });
  registry[lifecycleEvent] = [];
};

var processTrigger = function(nativeEvent, triggerData) {
  var trigger = triggerData.trigger;
  var syntheticEventFn = triggerData.syntheticEventFn;

  trigger(syntheticEventFn ? syntheticEventFn(nativeEvent) : null);
};

window._satellite = window._satellite || {};
window._satellite.pageBottom = processRegistry.bind(null, PAGE_BOTTOM);

document.addEventListener(
  'DOMContentLoaded',
  processRegistry.bind(null, DOM_READY),
  true
);
window.addEventListener(
  'load',
  processRegistry.bind(null, WINDOW_LOADED),
  true
);

// Depending on the way the Launch library was loaded, none of the registered listeners that
// execute `processRegistry` may fire . We need to execute the `processRegistry` method at
// least once. If this timeout fires before any of the registered listeners, we auto-detect the
// current lifecycle event and fire all the registered triggers in order. We don't care if the
// `processRegistry` is called multiple times for the same lifecycle event. We fire the registered
// triggers for a lifecycle event only once. We used a `setTimeout` here to make sure all the rules
// using Library Loaded are registered and executed synchronously and before rules using any of the
// other lifecycle event types.
window.setTimeout(function() {
  var lifecycleEvent = detectLifecycleEvent();
  if (lifecycleEvent) {
    processRegistry(lifecycleEvent);
  }
}, 0);

module.exports = {
  registerLibraryLoadedTrigger: function(trigger) {
    trigger();
  },
  registerPageBottomTrigger: function(trigger) {
    registry[PAGE_BOTTOM].push({
      trigger: trigger
    });
  },
  registerDomReadyTrigger: function(trigger) {
    registry[DOM_READY].push({
      trigger: trigger,
      syntheticEventFn: createSyntheticEvent.bind(null, document)
    });
  },
  registerWindowLoadedTrigger: function(trigger) {
    registry[WINDOW_LOADED].push({
      trigger: trigger,
      syntheticEventFn: createSyntheticEvent.bind(null, window)
    });
  }
};

          }

        },
        "core/src/lib/actions/helpers/decorateCode.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var id = 0;

var isSourceLoadedFromFile = function(action) {
  return action.settings.isExternal;
};

var decorateGlobalJavaScriptCode = function(action, source) {
  // The line break after the source is important in case their last line of code is a comment.
  return '<scr' + 'ipt>\n' + source + '\n</scr' + 'ipt>';
};

var decorateNonGlobalJavaScriptCode = function(action, source) {
  var runScriptFnName = '__runScript' + ++id;

  _satellite[runScriptFnName] = function(fn) {
    fn.call(action.event.element, action.event, action.event.target);
    delete _satellite[runScriptFnName];
  };

  // The line break after the source is important in case their last line of code is a comment.
  return '<scr' + 'ipt>_satellite["' + runScriptFnName + '"](function(event, target) {\n' +
    source +
    '\n});</scr' + 'ipt>';
};

var decorators = {
  javascript: function(action, source) {
    return action.settings.global ?
      decorateGlobalJavaScriptCode(action, source) :
      decorateNonGlobalJavaScriptCode(action, source);
  },
  html: function(action, source) {
    // We need to replace tokens only for sources loaded from external files. The sources from
    // inside the container are automatically taken care by Turbine.
    if (isSourceLoadedFromFile(action)) {
      return turbine.replaceTokens(source, action.event);
    }

    return source;
  }
};

module.exports = function(action, source) {
  return decorators[action.settings.language](action, source);
};

          }

        },
        "core/src/lib/actions/helpers/loadCodeSequentially.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';

var Promise = require('@adobe/reactor-promise');
var getSourceByUrl = require('./getSourceByUrl');

var previousExecuteCodePromise = Promise.resolve();

module.exports = function(sourceUrl) {
  var sequentiallyLoadCodePromise = new Promise(function(resolve) {
    var loadCodePromise = getSourceByUrl(sourceUrl);

    Promise.all([
      loadCodePromise,
      previousExecuteCodePromise
    ]).then(function(values) {
      var source = values[0];
      resolve(source);
    });
  });

  previousExecuteCodePromise = sequentiallyLoadCodePromise;
  return sequentiallyLoadCodePromise;
};

          }

        },
        "core/node_modules/postscribe/dist/postscribe.js": {
          "script": function(module, exports, require, turbine) {
/**
 * @file postscribe
 * @description Asynchronously write javascript, even with document.write.
 * @version v2.0.8
 * @see {@link https://krux.github.io/postscribe}
 * @license MIT
 * @author Derek Brans
 * @copyright 2016 Krux Digital, Inc
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["postscribe"] = factory();
	else
		root["postscribe"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _postscribe = __webpack_require__(1);
	
	var _postscribe2 = _interopRequireDefault(_postscribe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	module.exports = _postscribe2['default'];

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = postscribe;
	
	var _writeStream = __webpack_require__(2);
	
	var _writeStream2 = _interopRequireDefault(_writeStream);
	
	var _utils = __webpack_require__(4);
	
	var utils = _interopRequireWildcard(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * A function that intentionally does nothing.
	 */
	function doNothing() {}
	
	/**
	 * Available options and defaults.
	 *
	 * @type {Object}
	 */
	var OPTIONS = {
	  /**
	   * Called when an async script has loaded.
	   */
	  afterAsync: doNothing,
	
	  /**
	   * Called immediately before removing from the write queue.
	   */
	  afterDequeue: doNothing,
	
	  /**
	   * Called sync after a stream's first thread release.
	   */
	  afterStreamStart: doNothing,
	
	  /**
	   * Called after writing buffered document.write calls.
	   */
	  afterWrite: doNothing,
	
	  /**
	   * Allows disabling the autoFix feature of prescribe
	   */
	  autoFix: true,
	
	  /**
	   * Called immediately before adding to the write queue.
	   */
	  beforeEnqueue: doNothing,
	
	  /**
	   * Called before writing a token.
	   *
	   * @param {Object} tok The token
	   */
	  beforeWriteToken: function beforeWriteToken(tok) {
	    return tok;
	  },
	
	  /**
	   * Called before writing buffered document.write calls.
	   *
	   * @param {String} str The string
	   */
	  beforeWrite: function beforeWrite(str) {
	    return str;
	  },
	
	  /**
	   * Called when evaluation is finished.
	   */
	  done: doNothing,
	
	  /**
	   * Called when a write results in an error.
	   *
	   * @param {Error} e The error
	   */
	  error: function error(e) {
	    throw new Error(e.msg);
	  },
	
	
	  /**
	   * Whether to let scripts w/ async attribute set fall out of the queue.
	   */
	  releaseAsync: false
	};
	
	var nextId = 0;
	var queue = [];
	var active = null;
	
	function nextStream() {
	  var args = queue.shift();
	  if (args) {
	    var options = utils.last(args);
	
	    options.afterDequeue();
	    args.stream = runStream.apply(undefined, args);
	    options.afterStreamStart();
	  }
	}
	
	function runStream(el, html, options) {
	  active = new _writeStream2['default'](el, options);
	
	  // Identify this stream.
	  active.id = nextId++;
	  active.name = options.name || active.id;
	  postscribe.streams[active.name] = active;
	
	  // Override document.write.
	  var doc = el.ownerDocument;
	
	  var stash = {
	    close: doc.close,
	    open: doc.open,
	    write: doc.write,
	    writeln: doc.writeln
	  };
	
	  function _write(str) {
	    str = options.beforeWrite(str);
	    active.write(str);
	    options.afterWrite(str);
	  }
	
	  _extends(doc, {
	    close: doNothing,
	    open: doNothing,
	    write: function write() {
	      for (var _len = arguments.length, str = Array(_len), _key = 0; _key < _len; _key++) {
	        str[_key] = arguments[_key];
	      }
	
	      return _write(str.join(''));
	    },
	    writeln: function writeln() {
	      for (var _len2 = arguments.length, str = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        str[_key2] = arguments[_key2];
	      }
	
	      return _write(str.join('') + '\n');
	    }
	  });
	
	  // Override window.onerror
	  var oldOnError = active.win.onerror || doNothing;
	
	  // This works together with the try/catch around WriteStream::insertScript
	  // In modern browsers, exceptions in tag scripts go directly to top level
	  active.win.onerror = function (msg, url, line) {
	    options.error({ msg: msg + ' - ' + url + ': ' + line });
	    oldOnError.apply(active.win, [msg, url, line]);
	  };
	
	  // Write to the stream
	  active.write(html, function () {
	    // restore document.write
	    _extends(doc, stash);
	
	    // restore window.onerror
	    active.win.onerror = oldOnError;
	
	    options.done();
	    active = null;
	    nextStream();
	  });
	
	  return active;
	}
	
	function postscribe(el, html, options) {
	  if (utils.isFunction(options)) {
	    options = { done: options };
	  } else if (options === 'clear') {
	    queue = [];
	    active = null;
	    nextId = 0;
	    return;
	  }
	
	  options = utils.defaults(options, OPTIONS);
	
	  // id selector
	  if (/^#/.test(el)) {
	    el = window.document.getElementById(el.substr(1));
	  } else {
	    el = el.jquery ? el[0] : el;
	  }
	
	  var args = [el, html, options];
	
	  el.postscribe = {
	    cancel: function cancel() {
	      if (args.stream) {
	        args.stream.abort();
	      } else {
	        args[1] = doNothing;
	      }
	    }
	  };
	
	  options.beforeEnqueue(args);
	  queue.push(args);
	
	  if (!active) {
	    nextStream();
	  }
	
	  return el.postscribe;
	}
	
	_extends(postscribe, {
	  // Streams by name.
	  streams: {},
	  // Queue of streams.
	  queue: queue,
	  // Expose internal classes.
	  WriteStream: _writeStream2['default']
	});

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _prescribe = __webpack_require__(3);
	
	var _prescribe2 = _interopRequireDefault(_prescribe);
	
	var _utils = __webpack_require__(4);
	
	var utils = _interopRequireWildcard(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Turn on to debug how each chunk affected the DOM.
	 * @type {boolean}
	 */
	var DEBUG_CHUNK = false;
	
	/**
	 * Prefix for data attributes on DOM elements.
	 * @type {string}
	 */
	var BASEATTR = 'data-ps-';
	
	/**
	 * ID for the style proxy
	 * @type {string}
	 */
	var PROXY_STYLE = 'ps-style';
	
	/**
	 * ID for the script proxy
	 * @type {string}
	 */
	var PROXY_SCRIPT = 'ps-script';
	
	/**
	 * Get data attributes
	 *
	 * @param {Object} el The DOM element.
	 * @param {String} name The attribute name.
	 * @returns {String}
	 */
	function getData(el, name) {
	  var attr = BASEATTR + name;
	
	  var val = el.getAttribute(attr);
	
	  // IE 8 returns a number if it's a number
	  return !utils.existy(val) ? val : String(val);
	}
	
	/**
	 * Set data attributes
	 *
	 * @param {Object} el The DOM element.
	 * @param {String} name The attribute name.
	 * @param {null|*} value The attribute value.
	 */
	function setData(el, name) {
	  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	
	  var attr = BASEATTR + name;
	
	  if (utils.existy(value) && value !== '') {
	    el.setAttribute(attr, value);
	  } else {
	    el.removeAttribute(attr);
	  }
	}
	
	/**
	 * Stream static html to an element, where "static html" denotes "html
	 * without scripts".
	 *
	 * This class maintains a *history of writes devoid of any attributes* or
	 * "proxy history".
	 *
	 * Injecting the proxy history into a temporary div has no side-effects,
	 * other than to create proxy elements for previously written elements.
	 *
	 * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to
	 * `proxy_history + staticHtml`.
	 * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes
	 * beside or inside of proxy elements), reflects the DOM structure that would
	 * have resulted if all writes had been squashed into a single write.
	 *
	 * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,
	 * `node` is appended to the corresponding *real* element within the DOM.
	 *
	 * Proxy elements are mapped to *actual* elements in the DOM by injecting a
	 * `data-id` attribute into each start tag in `staticHtml`.
	 *
	 */
	
	var WriteStream = function () {
	  /**
	   * Constructor.
	   *
	   * @param {Object} root The root element
	   * @param {?Object} options The options
	   */
	  function WriteStream(root) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, WriteStream);
	
	    this.root = root;
	    this.options = options;
	    this.doc = root.ownerDocument;
	    this.win = this.doc.defaultView || this.doc.parentWindow;
	    this.parser = new _prescribe2['default']('', { autoFix: options.autoFix });
	
	    // Actual elements by id.
	    this.actuals = [root];
	
	    // Embodies the "structure" of what's been written so far,
	    // devoid of attributes.
	    this.proxyHistory = '';
	
	    // Create a proxy of the root element.
	    this.proxyRoot = this.doc.createElement(root.nodeName);
	
	    this.scriptStack = [];
	    this.writeQueue = [];
	
	    setData(this.proxyRoot, 'proxyof', 0);
	  }
	
	  /**
	   * Writes the given strings.
	   *
	   * @param {...String} str The strings to write
	   */
	
	
	  WriteStream.prototype.write = function write() {
	    var _writeQueue;
	
	    (_writeQueue = this.writeQueue).push.apply(_writeQueue, arguments);
	
	    // Process writes
	    // When new script gets pushed or pending this will stop
	    // because new writeQueue gets pushed
	    while (!this.deferredRemote && this.writeQueue.length) {
	      var arg = this.writeQueue.shift();
	
	      if (utils.isFunction(arg)) {
	        this._callFunction(arg);
	      } else {
	        this._writeImpl(arg);
	      }
	    }
	  };
	
	  /**
	   * Calls the given function.
	   *
	   * @param {Function} fn The function to call
	   * @private
	   */
	
	
	  WriteStream.prototype._callFunction = function _callFunction(fn) {
	    var tok = { type: 'function', value: fn.name || fn.toString() };
	    this._onScriptStart(tok);
	    fn.call(this.win, this.doc);
	    this._onScriptDone(tok);
	  };
	
	  /**
	   * The write implementation
	   *
	   * @param {String} html The HTML to write.
	   * @private
	   */
	
	
	  WriteStream.prototype._writeImpl = function _writeImpl(html) {
	    this.parser.append(html);
	
	    var tok = void 0;
	    var script = void 0;
	    var style = void 0;
	    var tokens = [];
	
	    // stop if we see a script token
	    while ((tok = this.parser.readToken()) && !(script = utils.isScript(tok)) && !(style = utils.isStyle(tok))) {
	      tok = this.options.beforeWriteToken(tok);
	
	      if (tok) {
	        tokens.push(tok);
	      }
	    }
	
	    if (tokens.length > 0) {
	      this._writeStaticTokens(tokens);
	    }
	
	    if (script) {
	      this._handleScriptToken(tok);
	    }
	
	    if (style) {
	      this._handleStyleToken(tok);
	    }
	  };
	
	  /**
	   * Write contiguous non-script tokens (a chunk)
	   *
	   * @param {Array<Object>} tokens The tokens
	   * @returns {{tokens, raw, actual, proxy}|null}
	   * @private
	   */
	
	
	  WriteStream.prototype._writeStaticTokens = function _writeStaticTokens(tokens) {
	    var chunk = this._buildChunk(tokens);
	
	    if (!chunk.actual) {
	      // e.g., no tokens, or a noscript that got ignored
	      return null;
	    }
	
	    chunk.html = this.proxyHistory + chunk.actual;
	    this.proxyHistory += chunk.proxy;
	    this.proxyRoot.innerHTML = chunk.html;
	
	    if (DEBUG_CHUNK) {
	      chunk.proxyInnerHTML = this.proxyRoot.innerHTML;
	    }
	
	    this._walkChunk();
	
	    if (DEBUG_CHUNK) {
	      chunk.actualInnerHTML = this.root.innerHTML;
	    }
	
	    return chunk;
	  };
	
	  /**
	   * Build a chunk.
	   *
	   * @param {Array<Object>} tokens The tokens to use.
	   * @returns {{tokens: *, raw: string, actual: string, proxy: string}}
	   * @private
	   */
	
	
	  WriteStream.prototype._buildChunk = function _buildChunk(tokens) {
	    var nextId = this.actuals.length;
	
	    // The raw html of this chunk.
	    var raw = [];
	
	    // The html to create the nodes in the tokens (with id's injected).
	    var actual = [];
	
	    // Html that can later be used to proxy the nodes in the tokens.
	    var proxy = [];
	
	    var len = tokens.length;
	    for (var i = 0; i < len; i++) {
	      var tok = tokens[i];
	      var tokenRaw = tok.toString();
	
	      raw.push(tokenRaw);
	
	      if (tok.attrs) {
	        // tok.attrs <==> startTag or atomicTag or cursor
	        // Ignore noscript tags. They are atomic, so we don't have to worry about children.
	        if (!/^noscript$/i.test(tok.tagName)) {
	          var id = nextId++;
	
	          // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'
	          actual.push(tokenRaw.replace(/(\/?>)/, ' ' + BASEATTR + 'id=' + id + ' $1'));
	
	          // Don't proxy scripts: they have no bearing on DOM structure.
	          if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {
	            // Proxy: strip all attributes and inject proxyof attribute
	            proxy.push(
	            // ignore atomic tags (e.g., style): they have no "structural" effect
	            tok.type === 'atomicTag' ? '' : '<' + tok.tagName + ' ' + BASEATTR + 'proxyof=' + id + (tok.unary ? ' />' : '>'));
	          }
	        }
	      } else {
	        // Visit any other type of token
	        // Actual: append.
	        actual.push(tokenRaw);
	
	        // Proxy: append endTags. Ignore everything else.
	        proxy.push(tok.type === 'endTag' ? tokenRaw : '');
	      }
	    }
	
	    return {
	      tokens: tokens,
	      raw: raw.join(''),
	      actual: actual.join(''),
	      proxy: proxy.join('')
	    };
	  };
	
	  /**
	   * Walk the chunks.
	   *
	   * @private
	   */
	
	
	  WriteStream.prototype._walkChunk = function _walkChunk() {
	    var node = void 0;
	    var stack = [this.proxyRoot];
	
	    // use shift/unshift so that children are walked in document order
	    while (utils.existy(node = stack.shift())) {
	      var isElement = node.nodeType === 1;
	      var isProxy = isElement && getData(node, 'proxyof');
	
	      // Ignore proxies
	      if (!isProxy) {
	        if (isElement) {
	          // New actual element: register it and remove the the id attr.
	          this.actuals[getData(node, 'id')] = node;
	          setData(node, 'id');
	        }
	
	        // Is node's parent a proxy?
	        var parentIsProxyOf = node.parentNode && getData(node.parentNode, 'proxyof');
	        if (parentIsProxyOf) {
	          // Move node under actual parent.
	          this.actuals[parentIsProxyOf].appendChild(node);
	        }
	      }
	
	      // prepend childNodes to stack
	      stack.unshift.apply(stack, utils.toArray(node.childNodes));
	    }
	  };
	
	  /**
	   * Handles Script tokens
	   *
	   * @param {Object} tok The token
	   */
	
	
	  WriteStream.prototype._handleScriptToken = function _handleScriptToken(tok) {
	    var _this = this;
	
	    var remainder = this.parser.clear();
	
	    if (remainder) {
	      // Write remainder immediately behind this script.
	      this.writeQueue.unshift(remainder);
	    }
	
	    tok.src = tok.attrs.src || tok.attrs.SRC;
	
	    tok = this.options.beforeWriteToken(tok);
	    if (!tok) {
	      // User has removed this token
	      return;
	    }
	
	    if (tok.src && this.scriptStack.length) {
	      // Defer this script until scriptStack is empty.
	      // Assumption 1: This script will not start executing until
	      // scriptStack is empty.
	      this.deferredRemote = tok;
	    } else {
	      this._onScriptStart(tok);
	    }
	
	    // Put the script node in the DOM.
	    this._writeScriptToken(tok, function () {
	      _this._onScriptDone(tok);
	    });
	  };
	
	  /**
	   * Handles style tokens
	   *
	   * @param {Object} tok The token
	   */
	
	
	  WriteStream.prototype._handleStyleToken = function _handleStyleToken(tok) {
	    var remainder = this.parser.clear();
	
	    if (remainder) {
	      // Write remainder immediately behind this style.
	      this.writeQueue.unshift(remainder);
	    }
	
	    tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';
	
	    tok = this.options.beforeWriteToken(tok);
	
	    if (tok) {
	      // Put the style node in the DOM.
	      this._writeStyleToken(tok);
	    }
	
	    if (remainder) {
	      this.write();
	    }
	  };
	
	  /**
	   * Build a style and insert it into the DOM.
	   *
	   * @param {Object} tok The token
	   */
	
	
	  WriteStream.prototype._writeStyleToken = function _writeStyleToken(tok) {
	    var el = this._buildStyle(tok);
	
	    this._insertCursor(el, PROXY_STYLE);
	
	    // Set content
	    if (tok.content) {
	      if (el.styleSheet && !el.sheet) {
	        el.styleSheet.cssText = tok.content;
	      } else {
	        el.appendChild(this.doc.createTextNode(tok.content));
	      }
	    }
	  };
	
	  /**
	   * Build a style element from an atomic style token.
	   *
	   * @param {Object} tok The token
	   * @returns {Element}
	   */
	
	
	  WriteStream.prototype._buildStyle = function _buildStyle(tok) {
	    var el = this.doc.createElement(tok.tagName);
	
	    el.setAttribute('type', tok.type);
	
	    // Set attributes
	    utils.eachKey(tok.attrs, function (name, value) {
	      el.setAttribute(name, value);
	    });
	
	    return el;
	  };
	
	  /**
	   * Append a span to the stream. That span will act as a cursor
	   * (i.e. insertion point) for the element.
	   *
	   * @param {Object} el The element
	   * @param {string} which The type of proxy element
	   */
	
	
	  WriteStream.prototype._insertCursor = function _insertCursor(el, which) {
	    this._writeImpl('<span id="' + which + '"/>');
	
	    var cursor = this.doc.getElementById(which);
	
	    if (cursor) {
	      cursor.parentNode.replaceChild(el, cursor);
	    }
	  };
	
	  /**
	   * Called when a script is started.
	   *
	   * @param {Object} tok The token
	   * @private
	   */
	
	
	  WriteStream.prototype._onScriptStart = function _onScriptStart(tok) {
	    tok.outerWrites = this.writeQueue;
	    this.writeQueue = [];
	    this.scriptStack.unshift(tok);
	  };
	
	  /**
	   * Called when a script is done.
	   *
	   * @param {Object} tok The token
	   * @private
	   */
	
	
	  WriteStream.prototype._onScriptDone = function _onScriptDone(tok) {
	    // Pop script and check nesting.
	    if (tok !== this.scriptStack[0]) {
	      this.options.error({ msg: 'Bad script nesting or script finished twice' });
	      return;
	    }
	
	    this.scriptStack.shift();
	
	    // Append outer writes to queue and process them.
	    this.write.apply(this, tok.outerWrites);
	
	    // Check for pending remote
	
	    // Assumption 2: if remote_script1 writes remote_script2 then
	    // the we notice remote_script1 finishes before remote_script2 starts.
	    // I think this is equivalent to assumption 1
	    if (!this.scriptStack.length && this.deferredRemote) {
	      this._onScriptStart(this.deferredRemote);
	      this.deferredRemote = null;
	    }
	  };
	
	  /**
	   * Build a script and insert it into the DOM.
	   * Done is called once script has executed.
	   *
	   * @param {Object} tok The token
	   * @param {Function} done The callback when complete
	   */
	
	
	  WriteStream.prototype._writeScriptToken = function _writeScriptToken(tok, done) {
	    var el = this._buildScript(tok);
	    var asyncRelease = this._shouldRelease(el);
	    var afterAsync = this.options.afterAsync;
	
	    if (tok.src) {
	      // Fix for attribute "SRC" (capitalized). IE does not recognize it.
	      el.src = tok.src;
	      this._scriptLoadHandler(el, !asyncRelease ? function () {
	        done();
	        afterAsync();
	      } : afterAsync);
	    }
	
	    try {
	      this._insertCursor(el, PROXY_SCRIPT);
	      if (!el.src || asyncRelease) {
	        done();
	      }
	    } catch (e) {
	      this.options.error(e);
	      done();
	    }
	  };
	
	  /**
	   * Build a script element from an atomic script token.
	   *
	   * @param {Object} tok The token
	   * @returns {Element}
	   */
	
	
	  WriteStream.prototype._buildScript = function _buildScript(tok) {
	    var el = this.doc.createElement(tok.tagName);
	
	    // Set attributes
	    utils.eachKey(tok.attrs, function (name, value) {
	      el.setAttribute(name, value);
	    });
	
	    // Set content
	    if (tok.content) {
	      el.text = tok.content;
	    }
	
	    return el;
	  };
	
	  /**
	   * Setup the script load handler on an element.
	   *
	   * @param {Object} el The element
	   * @param {Function} done The callback
	   * @private
	   */
	
	
	  WriteStream.prototype._scriptLoadHandler = function _scriptLoadHandler(el, done) {
	    function cleanup() {
	      el = el.onload = el.onreadystatechange = el.onerror = null;
	    }
	
	    var error = this.options.error;
	
	    function success() {
	      cleanup();
	      if (done != null) {
	        done();
	      }
	      done = null;
	    }
	
	    function failure(err) {
	      cleanup();
	      error(err);
	      if (done != null) {
	        done();
	      }
	      done = null;
	    }
	
	    function reattachEventListener(el, evt) {
	      var handler = el['on' + evt];
	      if (handler != null) {
	        el['_on' + evt] = handler;
	      }
	    }
	
	    reattachEventListener(el, 'load');
	    reattachEventListener(el, 'error');
	
	    _extends(el, {
	      onload: function onload() {
	        if (el._onload) {
	          try {
	            el._onload.apply(this, Array.prototype.slice.call(arguments, 0));
	          } catch (err) {
	            failure({ msg: 'onload handler failed ' + err + ' @ ' + el.src });
	          }
	        }
	        success();
	      },
	      onerror: function onerror() {
	        if (el._onerror) {
	          try {
	            el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));
	          } catch (err) {
	            failure({ msg: 'onerror handler failed ' + err + ' @ ' + el.src });
	            return;
	          }
	        }
	        failure({ msg: 'remote script failed ' + el.src });
	      },
	      onreadystatechange: function onreadystatechange() {
	        if (/^(loaded|complete)$/.test(el.readyState)) {
	          success();
	        }
	      }
	    });
	  };
	
	  /**
	   * Determines whether to release.
	   *
	   * @param {Object} el The element
	   * @returns {boolean}
	   * @private
	   */
	
	
	  WriteStream.prototype._shouldRelease = function _shouldRelease(el) {
	    var isScript = /^script$/i.test(el.nodeName);
	    return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));
	  };
	
	  return WriteStream;
	}();
	
	exports['default'] = WriteStream;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file prescribe
	 * @description Tiny, forgiving HTML parser
	 * @version vundefined
	 * @see {@link https://github.com/krux/prescribe/}
	 * @license MIT
	 * @author Derek Brans
	 * @copyright 2016 Krux Digital, Inc
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Prescribe"] = factory();
		else
			root["Prescribe"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _HtmlParser = __webpack_require__(1);
	
		var _HtmlParser2 = _interopRequireDefault(_HtmlParser);
	
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
		module.exports = _HtmlParser2['default'];
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
	
		var _supports = __webpack_require__(2);
	
		var supports = _interopRequireWildcard(_supports);
	
		var _streamReaders = __webpack_require__(3);
	
		var streamReaders = _interopRequireWildcard(_streamReaders);
	
		var _fixedReadTokenFactory = __webpack_require__(6);
	
		var _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);
	
		var _utils = __webpack_require__(5);
	
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
		/**
		 * Detection regular expressions.
		 *
		 * Order of detection matters: detection of one can only
		 * succeed if detection of previous didn't
	
		 * @type {Object}
		 */
		var detect = {
		  comment: /^<!--/,
		  endTag: /^<\//,
		  atomicTag: /^<\s*(script|style|noscript|iframe|textarea)[\s\/>]/i,
		  startTag: /^</,
		  chars: /^[^<]/
		};
	
		/**
		 * HtmlParser provides the capability to parse HTML and return tokens
		 * representing the tags and content.
		 */
	
		var HtmlParser = function () {
		  /**
		   * Constructor.
		   *
		   * @param {string} stream The initial parse stream contents.
		   * @param {Object} options The options
		   * @param {boolean} options.autoFix Set to true to automatically fix errors
		   */
		  function HtmlParser() {
		    var _this = this;
	
		    var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
		    _classCallCheck(this, HtmlParser);
	
		    this.stream = stream;
	
		    var fix = false;
		    var fixedTokenOptions = {};
	
		    for (var key in supports) {
		      if (supports.hasOwnProperty(key)) {
		        if (options.autoFix) {
		          fixedTokenOptions[key + 'Fix'] = true; // !supports[key];
		        }
		        fix = fix || fixedTokenOptions[key + 'Fix'];
		      }
		    }
	
		    if (fix) {
		      this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {
		        return _this._readTokenImpl();
		      });
		      this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {
		        return _this._peekTokenImpl();
		      });
		    } else {
		      this._readToken = this._readTokenImpl;
		      this._peekToken = this._peekTokenImpl;
		    }
		  }
	
		  /**
		   * Appends the given string to the parse stream.
		   *
		   * @param {string} str The string to append
		   */
	
	
		  HtmlParser.prototype.append = function append(str) {
		    this.stream += str;
		  };
	
		  /**
		   * Prepends the given string to the parse stream.
		   *
		   * @param {string} str The string to prepend
		   */
	
	
		  HtmlParser.prototype.prepend = function prepend(str) {
		    this.stream = str + this.stream;
		  };
	
		  /**
		   * The implementation of the token reading.
		   *
		   * @private
		   * @returns {?Token}
		   */
	
	
		  HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {
		    var token = this._peekTokenImpl();
		    if (token) {
		      this.stream = this.stream.slice(token.length);
		      return token;
		    }
		  };
	
		  /**
		   * The implementation of token peeking.
		   *
		   * @returns {?Token}
		   */
	
	
		  HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {
		    for (var type in detect) {
		      if (detect.hasOwnProperty(type)) {
		        if (detect[type].test(this.stream)) {
		          var token = streamReaders[type](this.stream);
	
		          if (token) {
		            if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {
		              return null;
		            } else {
		              token.text = this.stream.substr(0, token.length);
		              return token;
		            }
		          }
		        }
		      }
		    }
		  };
	
		  /**
		   * The public token peeking interface.  Delegates to the basic token peeking
		   * or a version that performs fixups depending on the `autoFix` setting in
		   * options.
		   *
		   * @returns {object}
		   */
	
	
		  HtmlParser.prototype.peekToken = function peekToken() {
		    return this._peekToken();
		  };
	
		  /**
		   * The public token reading interface.  Delegates to the basic token reading
		   * or a version that performs fixups depending on the `autoFix` setting in
		   * options.
		   *
		   * @returns {object}
		   */
	
	
		  HtmlParser.prototype.readToken = function readToken() {
		    return this._readToken();
		  };
	
		  /**
		   * Read tokens and hand to the given handlers.
		   *
		   * @param {Object} handlers The handlers to use for the different tokens.
		   */
	
	
		  HtmlParser.prototype.readTokens = function readTokens(handlers) {
		    var tok = void 0;
		    while (tok = this.readToken()) {
		      // continue until we get an explicit "false" return
		      if (handlers[tok.type] && handlers[tok.type](tok) === false) {
		        return;
		      }
		    }
		  };
	
		  /**
		   * Clears the parse stream.
		   *
		   * @returns {string} The contents of the parse stream before clearing.
		   */
	
	
		  HtmlParser.prototype.clear = function clear() {
		    var rest = this.stream;
		    this.stream = '';
		    return rest;
		  };
	
		  /**
		   * Returns the rest of the parse stream.
		   *
		   * @returns {string} The contents of the parse stream.
		   */
	
	
		  HtmlParser.prototype.rest = function rest() {
		    return this.stream;
		  };
	
		  return HtmlParser;
		}();
	
		exports['default'] = HtmlParser;
	
	
		HtmlParser.tokenToString = function (tok) {
		  return tok.toString();
		};
	
		HtmlParser.escapeAttributes = function (attrs) {
		  var escapedAttrs = {};
	
		  for (var name in attrs) {
		    if (attrs.hasOwnProperty(name)) {
		      escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);
		    }
		  }
	
		  return escapedAttrs;
		};
	
		HtmlParser.supports = supports;
	
		for (var key in supports) {
		  if (supports.hasOwnProperty(key)) {
		    HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;
		  }
		}
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
		'use strict';
	
		exports.__esModule = true;
		var tagSoup = false;
		var selfClose = false;
	
		var work = window.document.createElement('div');
	
		try {
		  var html = '<P><I></P></I>';
		  work.innerHTML = html;
		  exports.tagSoup = tagSoup = work.innerHTML !== html;
		} catch (e) {
		  exports.tagSoup = tagSoup = false;
		}
	
		try {
		  work.innerHTML = '<P><i><P></P></i></P>';
		  exports.selfClose = selfClose = work.childNodes.length === 2;
		} catch (e) {
		  exports.selfClose = selfClose = false;
		}
	
		work = null;
	
		exports.tagSoup = tagSoup;
		exports.selfClose = selfClose;
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
	
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
		exports.comment = comment;
		exports.chars = chars;
		exports.startTag = startTag;
		exports.atomicTag = atomicTag;
		exports.endTag = endTag;
	
		var _tokens = __webpack_require__(4);
	
		/**
		 * Regular Expressions for parsing tags and attributes
		 *
		 * @type {Object}
		 */
		var REGEXES = {
		  startTag: /^<([\-A-Za-z0-9_]+)((?:\s+[\w\-]+(?:\s*=?\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
		  endTag: /^<\/([\-A-Za-z0-9_]+)[^>]*>/,
		  attr: /(?:([\-A-Za-z0-9_]+)\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))|(?:([\-A-Za-z0-9_]+)(\s|$)+)/g,
		  fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i
		};
	
		/**
		 * Reads a comment token
		 *
		 * @param {string} stream The input stream
		 * @returns {CommentToken}
		 */
		function comment(stream) {
		  var index = stream.indexOf('-->');
		  if (index >= 0) {
		    return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);
		  }
		}
	
		/**
		 * Reads non-tag characters.
		 *
		 * @param {string} stream The input stream
		 * @returns {CharsToken}
		 */
		function chars(stream) {
		  var index = stream.indexOf('<');
		  return new _tokens.CharsToken(index >= 0 ? index : stream.length);
		}
	
		/**
		 * Reads start tag token.
		 *
		 * @param {string} stream The input stream
		 * @returns {StartTagToken}
		 */
		function startTag(stream) {
		  var endTagIndex = stream.indexOf('>');
		  if (endTagIndex !== -1) {
		    var match = stream.match(REGEXES.startTag);
		    if (match) {
		      var _ret = function () {
		        var attrs = {};
		        var booleanAttrs = {};
		        var rest = match[2];
	
		        match[2].replace(REGEXES.attr, function (match, name) {
		          if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {
		            attrs[name] = '';
		          } else if (arguments[5]) {
		            attrs[arguments[5]] = '';
		            booleanAttrs[arguments[5]] = true;
		          } else {
		            attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';
		          }
	
		          rest = rest.replace(match, '');
		        });
	
		        return {
		          v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''))
		        };
		      }();
	
		      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
		    }
		  }
		}
	
		/**
		 * Reads atomic tag token.
		 *
		 * @param {string} stream The input stream
		 * @returns {AtomicTagToken}
		 */
		function atomicTag(stream) {
		  var start = startTag(stream);
		  if (start) {
		    var rest = stream.slice(start.length);
		    // for optimization, we check first just for the end tag
		    if (rest.match(new RegExp('<\/\\s*' + start.tagName + '\\s*>', 'i'))) {
		      // capturing the content is inefficient, so we do it inside the if
		      var match = rest.match(new RegExp('([\\s\\S]*?)<\/\\s*' + start.tagName + '\\s*>', 'i'));
		      if (match) {
		        return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);
		      }
		    }
		  }
		}
	
		/**
		 * Reads an end tag token.
		 *
		 * @param {string} stream The input stream
		 * @returns {EndTagToken}
		 */
		function endTag(stream) {
		  var match = stream.match(REGEXES.endTag);
		  if (match) {
		    return new _tokens.EndTagToken(match[1], match[0].length);
		  }
		}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
		exports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;
	
		var _utils = __webpack_require__(5);
	
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
		/**
		 * Token is a base class for all token types parsed.  Note we don't actually
		 * use intheritance due to IE8's non-existent ES5 support.
		 */
		var Token =
		/**
		 * Constructor.
		 *
		 * @param {string} type The type of the Token.
		 * @param {Number} length The length of the Token text.
		 */
		exports.Token = function Token(type, length) {
		  _classCallCheck(this, Token);
	
		  this.type = type;
		  this.length = length;
		  this.text = '';
		};
	
		/**
		 * CommentToken represents comment tags.
		 */
	
	
		var CommentToken = exports.CommentToken = function () {
		  /**
		   * Constructor.
		   *
		   * @param {string} content The content of the comment
		   * @param {Number} length The length of the Token text.
		   */
		  function CommentToken(content, length) {
		    _classCallCheck(this, CommentToken);
	
		    this.type = 'comment';
		    this.length = length || (content ? content.length : 0);
		    this.text = '';
		    this.content = content;
		  }
	
		  CommentToken.prototype.toString = function toString() {
		    return '<!--' + this.content;
		  };
	
		  return CommentToken;
		}();
	
		/**
		 * CharsToken represents non-tag characters.
		 */
	
	
		var CharsToken = exports.CharsToken = function () {
		  /**
		   * Constructor.
		   *
		   * @param {Number} length The length of the Token text.
		   */
		  function CharsToken(length) {
		    _classCallCheck(this, CharsToken);
	
		    this.type = 'chars';
		    this.length = length;
		    this.text = '';
		  }
	
		  CharsToken.prototype.toString = function toString() {
		    return this.text;
		  };
	
		  return CharsToken;
		}();
	
		/**
		 * TagToken is a base class for all tag-based Tokens.
		 */
	
	
		var TagToken = exports.TagToken = function () {
		  /**
		   * Constructor.
		   *
		   * @param {string} type The type of the token.
		   * @param {string} tagName The tag name.
		   * @param {Number} length The length of the Token text.
		   * @param {Object} attrs The dictionary of attributes and values
		   * @param {Object} booleanAttrs If an entry has 'true' then the attribute
		   *                              is a boolean attribute
		   */
		  function TagToken(type, tagName, length, attrs, booleanAttrs) {
		    _classCallCheck(this, TagToken);
	
		    this.type = type;
		    this.length = length;
		    this.text = '';
		    this.tagName = tagName;
		    this.attrs = attrs;
		    this.booleanAttrs = booleanAttrs;
		    this.unary = false;
		    this.html5Unary = false;
		  }
	
		  /**
		   * Formats the given token tag.
		   *
		   * @param {TagToken} tok The TagToken to format.
		   * @param {?string} [content=null] The content of the token.
		   * @returns {string} The formatted tag.
		   */
	
	
		  TagToken.formatTag = function formatTag(tok) {
		    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
		    var str = '<' + tok.tagName;
		    for (var key in tok.attrs) {
		      if (tok.attrs.hasOwnProperty(key)) {
		        str += ' ' + key;
	
		        var val = tok.attrs[key];
		        if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {
		          str += '="' + (0, _utils.escapeQuotes)(val) + '"';
		        }
		      }
		    }
	
		    if (tok.rest) {
		      str += ' ' + tok.rest;
		    }
	
		    if (tok.unary && !tok.html5Unary) {
		      str += '/>';
		    } else {
		      str += '>';
		    }
	
		    if (content !== undefined && content !== null) {
		      str += content + '</' + tok.tagName + '>';
		    }
	
		    return str;
		  };
	
		  return TagToken;
		}();
	
		/**
		 * StartTagToken represents a start token.
		 */
	
	
		var StartTagToken = exports.StartTagToken = function () {
		  /**
		   * Constructor.
		   *
		   * @param {string} tagName The tag name.
		   * @param {Number} length The length of the Token text
		   * @param {Object} attrs The dictionary of attributes and values
		   * @param {Object} booleanAttrs If an entry has 'true' then the attribute
		   *                              is a boolean attribute
		   * @param {boolean} unary True if the tag is a unary tag
		   * @param {string} rest The rest of the content.
		   */
		  function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {
		    _classCallCheck(this, StartTagToken);
	
		    this.type = 'startTag';
		    this.length = length;
		    this.text = '';
		    this.tagName = tagName;
		    this.attrs = attrs;
		    this.booleanAttrs = booleanAttrs;
		    this.html5Unary = false;
		    this.unary = unary;
		    this.rest = rest;
		  }
	
		  StartTagToken.prototype.toString = function toString() {
		    return TagToken.formatTag(this);
		  };
	
		  return StartTagToken;
		}();
	
		/**
		 * AtomicTagToken represents an atomic tag.
		 */
	
	
		var AtomicTagToken = exports.AtomicTagToken = function () {
		  /**
		   * Constructor.
		   *
		   * @param {string} tagName The name of the tag.
		   * @param {Number} length The length of the tag text.
		   * @param {Object} attrs The attributes.
		   * @param {Object} booleanAttrs If an entry has 'true' then the attribute
		   *                              is a boolean attribute
		   * @param {string} content The content of the tag.
		   */
		  function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {
		    _classCallCheck(this, AtomicTagToken);
	
		    this.type = 'atomicTag';
		    this.length = length;
		    this.text = '';
		    this.tagName = tagName;
		    this.attrs = attrs;
		    this.booleanAttrs = booleanAttrs;
		    this.unary = false;
		    this.html5Unary = false;
		    this.content = content;
		  }
	
		  AtomicTagToken.prototype.toString = function toString() {
		    return TagToken.formatTag(this, this.content);
		  };
	
		  return AtomicTagToken;
		}();
	
		/**
		 * EndTagToken represents an end tag.
		 */
	
	
		var EndTagToken = exports.EndTagToken = function () {
		  /**
		   * Constructor.
		   *
		   * @param {string} tagName The name of the tag.
		   * @param {Number} length The length of the tag text.
		   */
		  function EndTagToken(tagName, length) {
		    _classCallCheck(this, EndTagToken);
	
		    this.type = 'endTag';
		    this.length = length;
		    this.text = '';
		    this.tagName = tagName;
		  }
	
		  EndTagToken.prototype.toString = function toString() {
		    return '</' + this.tagName + '>';
		  };
	
		  return EndTagToken;
		}();
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		'use strict';
	
		exports.__esModule = true;
		exports.escapeQuotes = escapeQuotes;
	
		/**
		 * Escape quotes in the given value.
		 *
		 * @param {string} value The value to escape.
		 * @param {string} [defaultValue=''] The default value to return if value is falsy.
		 * @returns {string}
		 */
		function escapeQuotes(value) {
		  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	
		  // There's no lookback in JS, so /(^|[^\\])"/ only matches the first of two `"`s.
		  // Instead, just match anything before a double-quote and escape if it's not already escaped.
		  return !value ? defaultValue : value.replace(/([^"]*)"/g, function (_, prefix) {
		    return (/\\/.test(prefix) ? prefix + '"' : prefix + '\\"'
		    );
		  });
		}
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		'use strict';
	
		exports.__esModule = true;
		exports['default'] = fixedReadTokenFactory;
		/**
		 * Empty Elements - HTML 4.01
		 *
		 * @type {RegExp}
		 */
		var EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;
	
		/**
		 * Elements that you can intentionally leave open (and which close themselves)
		 *
		 * @type {RegExp}
		 */
		var CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;
	
		/**
		 * Corrects a token.
		 *
		 * @param {Token} tok The token to correct
		 * @returns {Token} The corrected token
		 */
		function correct(tok) {
		  if (tok && tok.type === 'startTag') {
		    tok.unary = EMPTY.test(tok.tagName) || tok.unary;
		    tok.html5Unary = !/\/>$/.test(tok.text);
		  }
		  return tok;
		}
	
		/**
		 * Peeks at the next token in the parser.
		 *
		 * @param {HtmlParser} parser The parser
		 * @param {Function} readTokenImpl The underlying readToken implementation
		 * @returns {Token} The next token
		 */
		function peekToken(parser, readTokenImpl) {
		  var tmp = parser.stream;
		  var tok = correct(readTokenImpl());
		  parser.stream = tmp;
		  return tok;
		}
	
		/**
		 * Closes the last token.
		 *
		 * @param {HtmlParser} parser The parser
		 * @param {Array<Token>} stack The stack
		 */
		function closeLast(parser, stack) {
		  var tok = stack.pop();
	
		  // prepend close tag to stream.
		  parser.prepend('</' + tok.tagName + '>');
		}
	
		/**
		 * Create a new token stack.
		 *
		 * @returns {Array<Token>}
		 */
		function newStack() {
		  var stack = [];
	
		  stack.last = function () {
		    return this[this.length - 1];
		  };
	
		  stack.lastTagNameEq = function (tagName) {
		    var last = this.last();
		    return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();
		  };
	
		  stack.containsTagName = function (tagName) {
		    for (var i = 0, tok; tok = this[i]; i++) {
		      if (tok.tagName === tagName) {
		        return true;
		      }
		    }
		    return false;
		  };
	
		  return stack;
		}
	
		/**
		 * Return a readToken implementation that fixes input.
		 *
		 * @param {HtmlParser} parser The parser
		 * @param {Object} options Options for fixing
		 * @param {boolean} options.tagSoupFix True to fix tag soup scenarios
		 * @param {boolean} options.selfCloseFix True to fix self-closing tags
		 * @param {Function} readTokenImpl The underlying readToken implementation
		 * @returns {Function}
		 */
		function fixedReadTokenFactory(parser, options, readTokenImpl) {
		  var stack = newStack();
	
		  var handlers = {
		    startTag: function startTag(tok) {
		      var tagName = tok.tagName;
	
		      if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {
		        parser.prepend('<TBODY>');
		        prepareNextToken();
		      } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {
		        if (stack.lastTagNameEq(tagName)) {
		          closeLast(parser, stack);
		        } else {
		          parser.prepend('</' + tok.tagName + '>');
		          prepareNextToken();
		        }
		      } else if (!tok.unary) {
		        stack.push(tok);
		      }
		    },
		    endTag: function endTag(tok) {
		      var last = stack.last();
		      if (last) {
		        if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {
		          // cleanup tag soup
		          closeLast(parser, stack);
		        } else {
		          stack.pop();
		        }
		      } else if (options.tagSoupFix) {
		        // cleanup tag soup part 2: skip this token
		        readTokenImpl();
		        prepareNextToken();
		      }
		    }
		  };
	
		  function prepareNextToken() {
		    var tok = peekToken(parser, readTokenImpl);
		    if (tok && handlers[tok.type]) {
		      handlers[tok.type](tok);
		    }
		  }
	
		  return function fixedReadToken() {
		    prepareNextToken();
		    return correct(readTokenImpl());
		  };
		}
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.existy = existy;
	exports.isFunction = isFunction;
	exports.each = each;
	exports.eachKey = eachKey;
	exports.defaults = defaults;
	exports.toArray = toArray;
	exports.last = last;
	exports.isTag = isTag;
	exports.isScript = isScript;
	exports.isStyle = isStyle;
	/**
	 * Determine if the thing is not undefined and not null.
	 *
	 * @param {*} thing The thing to test
	 * @returns {boolean} True if the thing is not undefined and not null.
	 */
	function existy(thing) {
	  return thing !== void 0 && thing !== null;
	}
	
	/**
	 * Is this a function?
	 *
	 * @param {*} x The variable to test
	 * @returns {boolean} True if the variable is a function
	 */
	function isFunction(x) {
	  return 'function' === typeof x;
	}
	
	/**
	 * Loop over each item in an array-like value.
	 *
	 * @param {Array<*>} arr The array to loop over
	 * @param {Function} fn The function to call
	 * @param {?Object} target The object to bind to the function
	 */
	function each(arr, fn, target) {
	  var i = void 0;
	  var len = arr && arr.length || 0;
	  for (i = 0; i < len; i++) {
	    fn.call(target, arr[i], i);
	  }
	}
	
	/**
	 * Loop over each key/value pair in a hash.
	 *
	 * @param {Object} obj The object
	 * @param {Function} fn The function to call
	 * @param {?Object} target The object to bind to the function
	 */
	function eachKey(obj, fn, target) {
	  for (var key in obj) {
	    if (obj.hasOwnProperty(key)) {
	      fn.call(target, key, obj[key]);
	    }
	  }
	}
	
	/**
	 * Set default options where some option was not specified.
	 *
	 * @param {Object} options The destination
	 * @param {Object} _defaults The defaults
	 * @returns {Object}
	 */
	function defaults(options, _defaults) {
	  options = options || {};
	  eachKey(_defaults, function (key, val) {
	    if (!existy(options[key])) {
	      options[key] = val;
	    }
	  });
	  return options;
	}
	
	/**
	 * Convert value (e.g., a NodeList) to an array.
	 *
	 * @param {*} obj The object
	 * @returns {Array<*>}
	 */
	function toArray(obj) {
	  try {
	    return Array.prototype.slice.call(obj);
	  } catch (e) {
	    var _ret = function () {
	      var ret = [];
	      each(obj, function (val) {
	        ret.push(val);
	      });
	      return {
	        v: ret
	      };
	    }();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	}
	
	/**
	 * Get the last item in an array
	 *
	 * @param {Array<*>} array The array
	 * @returns {*} The last item in the array
	 */
	function last(array) {
	  return array[array.length - 1];
	}
	
	/**
	 * Test if token is a script tag.
	 *
	 * @param {Object} tok The token
	 * @param {String} tag The tag name
	 * @returns {boolean} True if the token is a script tag
	 */
	function isTag(tok, tag) {
	  return !tok || !(tok.type === 'startTag' || tok.type === 'atomicTag') || !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);
	}
	
	/**
	 * Test if token is a script tag.
	 *
	 * @param {Object} tok The token
	 * @returns {boolean} True if the token is a script tag
	 */
	function isScript(tok) {
	  return isTag(tok, 'script');
	}
	
	/**
	 * Test if token is a style tag.
	 *
	 * @param {Object} tok The token
	 * @returns {boolean} True if the token is a style tag
	 */
	function isStyle(tok) {
	  return isTag(tok, 'style');
	}

/***/ }
/******/ ])
});
;
//# sourceMappingURL=postscribe.js.map
          }

        },
        "core/src/lib/actions/helpers/getSourceByUrl.js": {
          "script": function(module, exports, require, turbine) {
/***************************************************************************************
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

'use strict';
var loadScript = require('@adobe/reactor-load-script');
var Promise = require('@adobe/reactor-promise');

var codeBySourceUrl = {};
var scriptStore = {};

var loadScriptOnlyOnce = function(url) {
  if (!scriptStore[url]) {
    scriptStore[url] = loadScript(url);
  }

  return scriptStore[url];
};

_satellite.__registerScript = function(sourceUrl, code) {
  codeBySourceUrl[sourceUrl] = code;
};

module.exports = function(sourceUrl) {
  if (codeBySourceUrl[sourceUrl]) {
    return Promise.resolve(codeBySourceUrl[sourceUrl]);
  } else {
    return new Promise(function(resolve) {
      loadScriptOnlyOnce(sourceUrl).then(function() {
        resolve(codeBySourceUrl[sourceUrl]);
      }, function() {
        resolve();
      });
    });
  }
};

          }

        }
      }
    },
    "adobe-analytics": {
      "displayName": "Adobe Analytics",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EP308220a2a4c4403f97fc1960100db40f/",
      "settings": {
        "orgId": "9E1005A551ED61CA0A490D45@AdobeOrg",
        "libraryCode": {
          "type": "preinstalled",
          "trackerVariableName": "s_adbadobenonacdc"
        },
        "trackerProperties": {
          "charSet": "UTF-8",
          "currencyCode": "USD",
          "trackInlineStats": false,
          "trackDownloadLinks": true,
          "trackExternalLinks": true,
          "linkInternalFilters": [
            "%adobe_linkInternalFilters%"
          ],
          "linkDownloadFileTypes": [
            "%adobe_linkDownloadFileTypes%"
          ]
        }
      },
      "modules": {
        "adobe-analytics/src/lib/sharedModules/getTracker.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2016 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by all applicable intellectual property
* laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

'use strict';

var cookie = require('@adobe/reactor-cookie');
var Promise = require('@adobe/reactor-promise');
var window = require('@adobe/reactor-window');
var augmenters = require('../helpers/augmenters');
var loadScript = require('@adobe/reactor-load-script');

var applyTrackerVariables = require('../helpers/applyTrackerVariables');
var loadLibrary = require('../helpers/loadLibrary');
var generateVersion = require('../helpers/generateVersion');

var version = generateVersion(turbine.buildInfo.turbineBuildDate);
var BEFORE_SETTINGS_LOAD_PHASE = 'beforeSettings';

var mcidInstance = turbine.getSharedModule('adobe-mcid', 'mcid-instance');

var checkEuCompliance = function(trackingCoookieName) {
  if (!trackingCoookieName) {
    return true;
  }

  var euCookieValue = cookie.get(trackingCoookieName);
  return euCookieValue === 'true';
};

var augmentTracker = function(tracker) {
  return Promise.all(augmenters.map(function(augmenterFn) {
    var result;

    // If a tracker augmenter fails, we don't want to fail too. We'll re-throw the error in a
    // timeout so it still hits the console but doesn't reject our promise.
    try {
      result = augmenterFn(tracker);
    } catch (e) {
      setTimeout(function() {
        throw e;
      });
    }

    return Promise.resolve(result);
  })).then(function() {
    return tracker;
  });
};

var linkVisitorId = function(tracker) {
  if (mcidInstance) {
    turbine.logger.info('Setting MCID instance on the tracker.');
    tracker.visitor = mcidInstance;
  }

  return tracker;
};

var updateTrackerVersion = function(tracker) {
  turbine.logger.info('Setting version on tracker: "' + version + '".');

  if (typeof tracker.tagContainerMarker !== 'undefined') {
    tracker.tagContainerMarker = version;
  } else if (typeof tracker.version === 'string'
    && tracker.version.substring(tracker.version.length - 5) !== ('-' + version)) {
    tracker.version += '-' + version;
  }

  return tracker;
};

var updateTrackerVariables = function(trackerProperties, customSetup, tracker) {
  if (customSetup.loadPhase === BEFORE_SETTINGS_LOAD_PHASE && customSetup.source) {
    turbine.logger.info('Calling custom script before settings.');
    customSetup.source.call(window, tracker);
  }

  applyTrackerVariables(tracker, trackerProperties || {});

  if (customSetup.loadPhase !== BEFORE_SETTINGS_LOAD_PHASE && customSetup.source) {
    turbine.logger.info('Calling custom script after settings.');
    customSetup.source.call(window, tracker);
  }

  return tracker;
};

var loadTrackerModules = function(properties, tracker) {
  var moduleProperties = properties.moduleProperties;
  if (moduleProperties &&
      moduleProperties.audienceManager &&
      moduleProperties.audienceManager.config &&
      window._satellite &&
      window._satellite.company &&
      window._satellite.company.orgId) {
    var visitorServiceConfig = {
      namespace: window._satellite.company.orgId
    };
    moduleProperties.audienceManager.config.visitorService = visitorServiceConfig;
    var libFileName = 'AppMeasurement_Module_AudienceManagement.js';
    var libFileUrl = turbine.getHostedLibFileUrl(libFileName);
    return loadScript(libFileUrl)
    .then( function() {
      tracker.loadModule('AudienceManagement');
      turbine.logger.info('Initializing AudienceManagement module');
      //turbine.logger.info(JSON.stringify(moduleProperties.audienceManager.config, null, 3));
      tracker.AudienceManagement.setup(moduleProperties.audienceManager.config);
      return tracker;
    });
  } else {
    return tracker;
  }
};

var initialize = function(settings) {
  if (checkEuCompliance(settings.trackingCookieName)) {
    return loadLibrary(settings)
      .then(augmentTracker)
      .then(linkVisitorId)
      .then(updateTrackerVersion)
      .then(updateTrackerVariables.bind(
        null,
        settings.trackerProperties,
        settings.customSetup || {}
      ))
      .then(loadTrackerModules.bind(null, settings));
  } else {
    return Promise.reject('EU compliance was not acknowledged by the user.');
  }
};

var promise = initialize(turbine.getExtensionSettings());
module.exports = function() {
  return promise;
};

          }
,
          "name": "get-tracker",
          "shared": true
        },
        "adobe-analytics/src/lib/sharedModules/augmentTracker.js": {
          "name": "augment-tracker",
          "shared": true,
          "script": function(module, exports, require, turbine) {
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2017 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

'use strict';

var augmenters = require('../helpers/augmenters');

module.exports = function(fn) {
  augmenters.push(fn);
};

          }

        },
        "adobe-analytics/src/lib/helpers/augmenters.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2017 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

'use strict';

module.exports = [];

          }

        },
        "adobe-analytics/src/lib/helpers/applyTrackerVariables.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2016 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by all applicable intellectual property
* laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

'use strict';

var queryString = require('@adobe/reactor-query-string');
var window = require('@adobe/reactor-window');

var eVarRegExp = /eVar([0-9]+)/;
var propRegExp = /prop([0-9]+)/;
var linkTrackVarsKeys = new RegExp('^(eVar[0-9]+)|(prop[0-9]+)|(hier[0-9]+)|campaign|purchaseID|' +
  'channel|server|state|zip|pageType$');

var onlyUnique = function(value, index, self) {
  return self.indexOf(value) === index;
};

var buildLinkTrackVars = function(tracker, newTrackerProperties, addEvents) {
  var linkTrackVarsValues = Object.keys(newTrackerProperties)
    .filter(linkTrackVarsKeys.test.bind(linkTrackVarsKeys));

  if (addEvents) {
    linkTrackVarsValues.push('events');
  }

  // Merge with the values already set on tracker.
  linkTrackVarsValues = linkTrackVarsValues.concat((tracker.linkTrackVars || '').split(','));

  return linkTrackVarsValues.filter(function(value, index) {
    return value !== 'None' && value && onlyUnique(value, index, linkTrackVarsValues);
  }).join(',');
};

var buildLinkTrackEvents = function(tracker, eventsData) {
  var linkTrackEventsValues = eventsData.map(function(event) {
    return event.name;
  });

  // Merge with the values already set on tracker.
  linkTrackEventsValues = linkTrackEventsValues.concat((tracker.linkTrackEvents || '').split(','));

  return linkTrackEventsValues.filter(function(value, index) {
    return value !== 'None'  && onlyUnique(value, index, linkTrackEventsValues);
  }).join(',');
};

var commaJoin = function(store, keyName, trackerProperties) {
  store[keyName] = trackerProperties[keyName].join(',');
};

var variablesTransform = function(store, keyName, trackerProperties) {
  var dynamicVariablePrefix = trackerProperties.dynamicVariablePrefix || 'D=';

  trackerProperties[keyName].forEach(function(variableData) {
    var value;
    if (variableData.type === 'value') {
      value = variableData.value;
    } else {
      var eVarData = eVarRegExp.exec(variableData.value);

      if (eVarData) {
        value = dynamicVariablePrefix + 'v' + eVarData[1];
      } else {
        var propData = propRegExp.exec(variableData.value);

        if (propData) {
          value = dynamicVariablePrefix + 'c' + propData[1];
        }
      }
    }

    store[variableData.name] = value;
  });
};

var transformers = {
  linkDownloadFileTypes: commaJoin,
  linkExternalFilters: commaJoin,
  linkInternalFilters: commaJoin,
  hierarchies: function(store, keyName, trackerProperties) {
    trackerProperties[keyName].forEach(function(hierarchyData) {
      store[hierarchyData.name] = hierarchyData.sections.join(hierarchyData.delimiter);
    });
  },
  props: variablesTransform,
  eVars: variablesTransform,
  campaign: function(store, keyName, trackerProperties) {
    if (trackerProperties[keyName].type === 'queryParam') {
      var queryParams = queryString.parse(window.location.search);
      store[keyName] = queryParams[trackerProperties[keyName].value];
    } else {
      store[keyName] = trackerProperties[keyName].value;
    }
  },
  events: function(store, keyName, trackerProperties) {
    var events = trackerProperties[keyName].map(function(data) {
      var entry = data.name;
      if (data.id) {
        entry = [entry, data.id].join(':');
      }
      if (data.value) {
        entry = [entry, data.value].join('=');
      }
      return entry;
    });
    store[keyName] = events.join(',');
  }
};

module.exports = function(tracker, trackerProperties) {
  var newProperties = {};
  trackerProperties = trackerProperties || {};

  Object.keys(trackerProperties).forEach(function(propertyName) {
    var transform = transformers[propertyName];
    var value = trackerProperties[propertyName];

    if (transform) {
      transform(newProperties, propertyName, trackerProperties);
    } else {
      newProperties[propertyName] = value;
    }
  });

  // New events are added to existing tracker events
  if (newProperties.events) {
    if (tracker.events && tracker.events.length > 0) {
      newProperties.events = tracker.events + ',' + newProperties.events;
    }
  }

  var hasEvents =
    trackerProperties && trackerProperties.events && trackerProperties.events.length > 0;
  var linkTrackVars = buildLinkTrackVars(tracker, newProperties, hasEvents);
  if (linkTrackVars) {
    newProperties.linkTrackVars = linkTrackVars;
  }

  var linkTrackEvents = buildLinkTrackEvents(tracker, trackerProperties.events || []);
  if (linkTrackEvents) {
    newProperties.linkTrackEvents = linkTrackEvents;
  }

  turbine.logger.info(
    'Applying the following properties on tracker: "' +
    JSON.stringify(newProperties) +
    '".'
  );

  Object.keys(newProperties).forEach(function(propertyName) {
    tracker[propertyName] = newProperties[propertyName];
  });
};

          }

        },
        "adobe-analytics/src/lib/helpers/loadLibrary.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2016 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by all applicable intellectual property
* laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

'use strict';

var loadScript = require('@adobe/reactor-load-script');
var window = require('@adobe/reactor-window');
var Promise = require('@adobe/reactor-promise');

var LIB_TYPES = {
  MANAGED: 'managed',
  PREINSTALLED: 'preinstalled',
  REMOTE: 'remote',
  CUSTOM: 'custom'
};

var loadAppMeasurementScript = function(url) {
  turbine.logger.info('Loading AppMeasurement script from: ' + url + '.');
  return loadScript(url);
};

var getReportSuites = function(reportSuitesData) {
  var reportSuiteValues = reportSuitesData.production;
  if (reportSuitesData[turbine.buildInfo.environment]) {
    reportSuiteValues = reportSuitesData[turbine.buildInfo.environment];
  }

  return reportSuiteValues.join(',');
};

var createTracker = function(settings, reportSuites) {
  if (!window.s_gi) {
    throw new Error(
      'Unable to create AppMeasurement tracker, `s_gi` function not found.' + window.AppMeasurement
    );
  }
  turbine.logger.info('Creating AppMeasurement tracker with these report suites: "' +
    reportSuites + '"');
  var tracker = window.s_gi(reportSuites);
  if (settings.libraryCode.scopeTrackerGlobally) {
    turbine.logger.info('Setting the tracker as window.s');
    window.s = tracker;
  }
  return tracker;
};

var loadManagedLibrary = function(settings) {
  var reportSuites = getReportSuites(settings.libraryCode.accounts);
  return loadAppMeasurementScript(turbine.getHostedLibFileUrl('AppMeasurement.js'))
    .then(createTracker.bind(null, settings, reportSuites));
};

var setReportSuitesOnTracker = function(settings, tracker) {
  if (settings.libraryCode.accounts) {
    if (!tracker.sa) {
      turbine.logger.warn('Cannot set report suites on tracker. `sa` method not available.');
    } else {
      var reportSuites = getReportSuites(settings.libraryCode.accounts);
      turbine.logger.info('Setting the following report suites on the tracker: "' +
        reportSuites + '"');
      tracker.sa(reportSuites);
    }
  }

  return tracker;
};

var poll = function(trackerVariableName) {
  turbine.logger.info('Waiting for the tracker to become accessible at: "' +
    trackerVariableName + '".');
  return new Promise(function(resolve, reject) {
    var i = 1;
    var intervalId = setInterval(function() {
      if (window[trackerVariableName]) {
        turbine.logger.info('Found tracker located at: "' + trackerVariableName + '".');
        resolve(window[trackerVariableName]);
        clearInterval(intervalId);
      }

      if (i >= 10) {
        clearInterval(intervalId);
        reject(new Error(
          'Bailing out. Cannot find the global variable name: "' + trackerVariableName + '".'
        ));
      }

      i++;
    }, 1000);
  });
};

var detectPreinstalledLibrary = function(settings) {
  return poll(settings.libraryCode.trackerVariableName)
    .then(setReportSuitesOnTracker.bind(null, settings));
};

var getTrackerFromVariable = function(trackerVariableName) {
  if (window[trackerVariableName]) {
    turbine.logger.info('Found tracker located at: "' + trackerVariableName + '".');
    return window[trackerVariableName];
  } else {
    throw new Error('Cannot find the global variable name: "' + trackerVariableName + '".');
  }
};

var loadRemoteLibrary = function(url, settings) {
  return loadAppMeasurementScript(url)
    .then(getTrackerFromVariable.bind(null, settings.libraryCode.trackerVariableName))
    .then(setReportSuitesOnTracker.bind(null, settings));
};

module.exports = function(settings) {
  var url;
  var libraryPromise;

  switch (settings.libraryCode.type) {
    case LIB_TYPES.MANAGED:
      libraryPromise = loadManagedLibrary(settings);
      break;

    case LIB_TYPES.PREINSTALLED:
      libraryPromise = detectPreinstalledLibrary(settings);
      break;

    case LIB_TYPES.CUSTOM:
      url = settings.libraryCode.source;

      libraryPromise = loadRemoteLibrary(url, settings);
      break;

    case LIB_TYPES.REMOTE:
      url = window.location.protocol === 'https:' ?
        settings.libraryCode.httpsUrl : settings.libraryCode.httpUrl;

      libraryPromise = loadRemoteLibrary(url, settings);
      break;

    default:
      throw new Error('Cannot load library. Type not supported.');
  }

  return libraryPromise;
};

          }

        },
        "adobe-analytics/src/lib/helpers/generateVersion.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2016 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by all applicable intellectual property
* laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

// The Launch code version is a 4 characters string.  The first character will always be L
// followed by year, month, and day codes.
// For example: JS-1.4.3-L53O = JS 1.4.3 code, Launch 2015 March 24th release (revision 1)
// More info: https://wiki.corp.adobe.com/pages/viewpage.action?spaceKey=tagmanager&title=DTM+Analytics+Code+Versions

'use strict';

var THIRD_OF_DAY = 8; //hours

var getDayField = function(date) {
  return date.getUTCDate().toString(36);
};

var getLastChar = function(str) {
  return str.substr(str.length - 1);
};

var getRevision = function(date) {
  // We are under the assumption that a Turbine version will be release at least 8h apart (max 3
  // releases per day).
  return Math.floor(date.getUTCHours() / THIRD_OF_DAY);
};

var getMonthField = function(date) {
  var monthNumber = date.getUTCMonth() + 1;
  var revision = getRevision(date);

  var monthField = (monthNumber + revision * 12).toString(36);

  return getLastChar(monthField);
};

var getYearField = function(date) {
  return (date.getUTCFullYear() - 2010).toString(36);
};

module.exports = function(dateString) {
  var date = new Date(dateString);

  if (isNaN(date)) {
    throw new Error('Invalid date provided');
  }

  return ('L' + getYearField(date) + getMonthField(date) + getDayField(date)).toUpperCase();
};

          }

        }
      }
    },
    "promise-polyfill": {
      "displayName": "Promise Polyfill",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EP25323084165d470d89410de73d1e4267/",
      "modules": {
        "promise-polyfill/src/lib/promise-polyfill.js": {
          "script": function(module, exports, require, turbine) {
var P = require('@adobe/reactor-promise');

if (typeof Promise === 'undefined') {
  window.Promise = P;
}
          }

        }
      }
    },
    "adobe-mcid": {
      "displayName": "Experience Cloud ID Service",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EPa7ef5ac82db64de8af1284050bf8d75d/",
      "settings": {
        "orgId": "%marketingCloudOrganizationID%",
        "variables": [
          {
            "name": "idSyncAttachIframeOnWindowLoad",
            "value": "true"
          },
          {
            "name": "marketingCloudServer",
            "value": "%marketingCloudServer%"
          },
          {
            "name": "marketingCloudServerSecure",
            "value": "%marketingCloudServerSecure%"
          },
          {
            "name": "trackingServer",
            "value": "%marketingCloudServer%"
          },
          {
            "name": "trackingServerSecure",
            "value": "%marketingCloudServerSecure%"
          },
          {
            "name": "idSyncDisableSyncs",
            "value": "%visitorService_idSyncDisableSyncs%"
          },
          {
            "name": "disableIdSyncs",
            "value": "%visitorService_idSyncDisableSyncs%"
          },
          {
            "name": "whitelistIframeDomains",
            "value": "['assets.vidyard.com','play.vidyard.com']"
          }
        ],
        "isIabContext": false,
        "doesOptInApply": true,
        "previousPermissions": "%previousPermissions%",
        "isOptInStorageEnabled": false,
        "preOptInApprovalInput": "%preOptIn%"
      },
      "modules": {
        "adobe-mcid/src/lib/sharedModules/mcidInstance.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2016 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by all applicable intellectual property
* laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

'use strict';
var document = require('@adobe/reactor-document');
var VisitorAPI = require('../codeLibrary/VisitorAPI');
var timeUnits = require('../../view/utils/timeUnits');

var transformArrayToObject = function(configs) {
  var initConfig = configs.reduce(function(obj, config) {
    var value = /^(true|false)$/i.test(config.value) ? JSON.parse(config.value) : config.value;

    obj[config.name] = value;

    return obj;
  }, {});

  return initConfig;
};

var initializeVisitorId = function(Visitor) {
  var extensionSettings = turbine.getExtensionSettings();
  if (typeof extensionSettings.orgId !== 'string') {
    throw new TypeError('Org ID is not a string.');
  }

  var initConfig = transformArrayToObject(extensionSettings.variables || []);
  var doesOptInApply = extensionSettings.doesOptInApply;
  if (doesOptInApply) {
    if (typeof doesOptInApply === 'boolean') {
      initConfig['doesOptInApply'] = doesOptInApply; 
    } else if (extensionSettings.optInCallback) {
      initConfig['doesOptInApply'] = extensionSettings.optInCallback; 
    }
  }

  var isOptInStorageEnabled = extensionSettings.isOptInStorageEnabled;
  if (isOptInStorageEnabled) {
    initConfig['isOptInStorageEnabled'] = isOptInStorageEnabled;
  }

  var optInCookieDomain = extensionSettings.optInCookieDomain;
  if (optInCookieDomain) {
    initConfig['optInCookieDomain'] = optInCookieDomain;
  }

  var optInStorageExpiry = extensionSettings.optInStorageExpiry;
  if (optInStorageExpiry) {
    var timeUnit = extensionSettings.timeUnit;
    if (timeUnit && timeUnits[timeUnit]) {
      var seconds = optInStorageExpiry * timeUnits[timeUnit];
      initConfig['optInStorageExpiry'] = seconds;
    }
  } else if (isOptInStorageEnabled === true) {
    // default is 13 months
    initConfig['optInStorageExpiry'] = 13 * 30 * 24 * 3600;
  }

  var previousPermissions = extensionSettings.previousPermissions;
  if (previousPermissions) {
    initConfig['previousPermissions'] = previousPermissions;
  }

  var preOptInApprovals = extensionSettings.preOptInApprovals;
  if (preOptInApprovals) {
    initConfig['preOptInApprovals'] = preOptInApprovals;
  } else {
    var preOptInApprovalInput = extensionSettings.preOptInApprovalInput;
    if (preOptInApprovalInput) {
      initConfig['preOptInApprovals'] = preOptInApprovalInput;
    }
  }

  var isIabContext = extensionSettings.isIabContext;
  if (isIabContext) {
    initConfig['isIabContext'] = isIabContext;
  }

  var instance = Visitor.getInstance(extensionSettings.orgId, initConfig);

  turbine.logger.info('Created instance using orgId: "' + extensionSettings.orgId + '"');
  turbine.logger.info('Set variables: ' + JSON.stringify(initConfig));

  // getMarketingCloudVisitorID is called automatically when the instance is created, but
  // we call it here so that we can log the ID once it has been retrieved from the server.
  // Calling getMarketingCloudVisitorID multiple times will not result in multiple requests
  // to the server.
  instance.getMarketingCloudVisitorID(function(id) {
    turbine.logger.info('Obtained Marketing Cloud Visitor Id: ' + id);
  }, true);

  return instance;
};

var excludePathsMatched = function(path) {
  var extensionSettings = turbine.getExtensionSettings();
  var pathExclusions = extensionSettings.pathExclusions || [];

  return pathExclusions.some(function(pathExclusion) {
    if (pathExclusion.valueIsRegex) {
      return new RegExp(pathExclusion.value, 'i').test(path);
    } else {
      return pathExclusion.value === path;
    }
  });
};

var visitorIdInstance = null;

// Overwrite the getVisitorId exposed in Turbine. This is largely for backward compatibility
// since DTM supported this method on _satellite.
_satellite.getVisitorId = function() { return visitorIdInstance; };

if (excludePathsMatched(document.location.pathname)) {
  turbine.logger.warn('MCID library not loaded. One of the path exclusions matches the ' +
    'current path.');
} else {
  visitorIdInstance = initializeVisitorId(VisitorAPI);
}

module.exports = visitorIdInstance;

          }
,
          "name": "mcid-instance",
          "shared": true
        },
        "adobe-mcid/src/lib/codeLibrary/VisitorAPI.js": {
          "script": function(module, exports, require, turbine) {
/* istanbul ignore next */
module.exports = function() {
var e=function(){"use strict";function e(t){"@babel/helpers - typeof";return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function n(){return{callbacks:{},add:function(e,t){this.callbacks[e]=this.callbacks[e]||[];var n=this.callbacks[e].push(t)-1,i=this;return function(){i.callbacks[e].splice(n,1)}},execute:function(e,t){if(this.callbacks[e]){t=void 0===t?[]:t,t=t instanceof Array?t:[t];try{for(;this.callbacks[e].length;){var n=this.callbacks[e].shift();"function"==typeof n?n.apply(null,t):n instanceof Array&&n[1].apply(n[0],t)}delete this.callbacks[e]}catch(e){}}},executeAll:function(e,t){(t||e&&!V.isObjectEmpty(e))&&Object.keys(this.callbacks).forEach(function(t){var n=void 0!==e[t]?e[t]:"";this.execute(t,n)},this)},hasCallbacks:function(){return Boolean(Object.keys(this.callbacks).length)}}}function i(e,t,n){var i=null==e?void 0:e[t];return void 0===i?n:i}function r(e){for(var t=/^\d+$/,n=0,i=e.length;n<i;n++)if(!t.test(e[n]))return!1;return!0}function a(e,t){for(;e.length<t.length;)e.push("0");for(;t.length<e.length;)t.push("0")}function o(e,t){for(var n=0;n<e.length;n++){var i=parseInt(e[n],10),r=parseInt(t[n],10);if(i>r)return 1;if(r>i)return-1}return 0}function s(e,t){if(e===t)return 0;var n=e.toString().split("."),i=t.toString().split(".");return r(n.concat(i))?(a(n,i),o(n,i)):NaN}function c(e){return e===Object(e)&&0===Object.keys(e).length}function u(e){return"function"==typeof e||e instanceof Array&&e.length}function l(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){return!0};this.log=Ie("log",e,t),this.warn=Ie("warn",e,t),this.error=Ie("error",e,t)}function d(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.cookieName,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=n.cookies;if(!t||!i)return{get:we,set:we,remove:we};var r={remove:function(){i.remove(t)},get:function(){var e=i.get(t),n={};try{n=JSON.parse(e)}catch(e){n={}}return n},set:function(e,n){n=n||{};var a=r.get(),o=Object.assign(a,e);i.set(t,JSON.stringify(o),{domain:n.optInCookieDomain||"",cookieLifetime:n.optInStorageExpiry||3419e4,expires:!0})}};return r}function f(e){this.name=this.constructor.name,this.message=e,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(e).stack}function p(){function e(e,t){var n=Ae(e);return n.length?n.every(function(e){return!!t[e]}):be(t)}function t(){M(b),O(le.COMPLETE),_(h.status,h.permissions),s&&m.set(h.permissions,{optInCookieDomain:c,optInStorageExpiry:u}),C.execute(He)}function n(e){return function(n,i){if(!Oe(n))throw new Error("[OptIn] Invalid category(-ies). Please use the `OptIn.Categories` enum.");return O(le.CHANGED),Object.assign(b,Me(Ae(n),e)),i||t(),h}}var i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=i.doesOptInApply,a=i.previousPermissions,o=i.preOptInApprovals,s=i.isOptInStorageEnabled,c=i.optInCookieDomain,u=i.optInStorageExpiry,l=i.isIabContext,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},p=f.cookies,g=Fe(a);Ne(g,"Invalid `previousPermissions`!"),Ne(o,"Invalid `preOptInApprovals`!");var m=d({cookieName:"adobeujs-optin"},{cookies:p}),h=this,_=ue(h),C=he(),I=Te(g),S=Te(o),v=s?m.get():{},D={},y=function(e,t){return Pe(e)||t&&Pe(t)?le.COMPLETE:le.PENDING}(I,v),A=function(e,t,n){var i=Me(me,!r);return r?Object.assign({},i,e,t,n):i}(S,I,v),b=ke(A),O=function(e){return y=e},M=function(e){return A=e};h.deny=n(!1),h.approve=n(!0),h.denyAll=h.deny.bind(h,me),h.approveAll=h.approve.bind(h,me),h.isApproved=function(t){return e(t,h.permissions)},h.isPreApproved=function(t){return e(t,S)},h.fetchPermissions=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=t?h.on(le.COMPLETE,e):we;return!r||r&&h.isComplete||!!o?e(h.permissions):t||C.add(He,function(){return e(h.permissions)}),n},h.complete=function(){h.status===le.CHANGED&&t()},h.registerPlugin=function(e){if(!e||!e.name||"function"!=typeof e.onRegister)throw new Error(Ue);D[e.name]||(D[e.name]=e,e.onRegister.call(e,h))},h.execute=Ve(D),h.memoizeContent=function(e){Re(e)&&m.set(e,{optInCookieDomain:c,optInStorageExpiry:u})},h.getMemoizedContent=function(e){var t=m.get();if(t)return t[e]},Object.defineProperties(h,{permissions:{get:function(){return A}},status:{get:function(){return y}},Categories:{get:function(){return de}},doesOptInApply:{get:function(){return!!r}},isPending:{get:function(){return h.status===le.PENDING}},isComplete:{get:function(){return h.status===le.COMPLETE}},__plugins:{get:function(){return Object.keys(D)}},isIabContext:{get:function(){return l}}})}function g(e,t){function n(){r=null,e.call(e,new f("The call took longer than you wanted!"))}function i(){r&&(clearTimeout(r),e.apply(e,arguments))}if(void 0===t)return e;var r=setTimeout(n,t);return i}function m(){if(window.__tcfapi)return window.__tcfapi;var e=window;if(e===window.top)return void De.error("__tcfapi not found");for(var t;!t;){e=e.parent;try{e.frames.__tcfapiLocator&&(t=e)}catch(e){}if(e===window.top)break}if(!t)return void De.error("__tcfapi not found");var n={};return window.__tcfapi=function(e,i,r,a){var o=Math.random()+"",s={__tcfapiCall:{command:e,parameter:a,version:i,callId:o}};n[o]=r,t.postMessage(s,"*")},window.addEventListener("message",function(e){var t=e.data;if("string"==typeof t)try{t=JSON.parse(e.data)}catch(e){}if(t.__tcfapiReturn){var i=t.__tcfapiReturn;"function"==typeof n[i.callId]&&(n[i.callId](i.returnValue,i.success),delete n[i.callId])}},!1),window.__tcfapi}function h(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=!0===e.vendor.consents[t],r=n.every(function(t){return!0===e.purpose.consents[t]});return i&&r}function _(){var e=this;e.name="iabPlugin",e.version="0.0.2";var t,n=he(),i={transparencyAndConsentData:null},r=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return i[e]=t};e.fetchConsentData=function(e){var t=e.callback,n=e.timeout,i=g(t,n);a({callback:i})},e.isApproved=function(e){var t=e.callback,n=e.category,r=e.timeout;if(i.transparencyAndConsentData)return t(null,h(i.transparencyAndConsentData,fe[n],pe[n]));var o=g(function(e,i){t(e,h(i,fe[n],pe[n]))},r);a({category:n,callback:o})},e.onRegister=function(n){t=n;var i=Object.keys(fe),r=function(e,t){!e&&t&&(i.forEach(function(e){var i=h(t,fe[e],pe[e]);n[i?"approve":"deny"](e,!0)}),n.complete())};e.fetchConsentData({callback:r})};var a=function(e){var a=e.callback;if(i.transparencyAndConsentData)return a(null,i.transparencyAndConsentData);n.add("FETCH_CONSENT_DATA",a),o(function(e,a){if(a){var o=ke(e),s=t.getMemoizedContent("iabConsentHash"),c=ve(o.tcString).toString(32);o.consentString=e.tcString,o.hasConsentChangedSinceLastCmpPull=s!==c,r("transparencyAndConsentData",o),t.memoizeContent({iabConsentHash:c})}n.execute("FETCH_CONSENT_DATA",[null,i.transparencyAndConsentData])})},o=function(e){var t=je(fe),n=m();"function"==typeof n&&n("getTCData",2,e,t)}}var C="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};Object.assign=Object.assign||function(e){for(var t,n,i=1;i<arguments.length;++i){n=arguments[i];for(t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e};var I,S,v={HANDSHAKE:"HANDSHAKE",GETSTATE:"GETSTATE",PARENTSTATE:"PARENTSTATE"},D={MCMID:"MCMID",MCAID:"MCAID",MCAAMB:"MCAAMB",MCAAMLH:"MCAAMLH",MCOPTOUT:"MCOPTOUT",CUSTOMERIDS:"CUSTOMERIDS"},y={MCMID:"getMarketingCloudVisitorID",MCAID:"getAnalyticsVisitorID",MCAAMB:"getAudienceManagerBlob",MCAAMLH:"getAudienceManagerLocationHint",MCOPTOUT:"isOptedOut",ALLFIELDS:"getVisitorValues"},A={CUSTOMERIDS:"getCustomerIDs"},b={MCMID:"getMarketingCloudVisitorID",MCAAMB:"getAudienceManagerBlob",MCAAMLH:"getAudienceManagerLocationHint",MCOPTOUT:"isOptedOut",MCAID:"getAnalyticsVisitorID",CUSTOMERIDS:"getCustomerIDs",ALLFIELDS:"getVisitorValues"},O={MC:"MCMID",A:"MCAID",AAM:"MCAAMB"},M={MCMID:"MCMID",MCOPTOUT:"MCOPTOUT",MCAID:"MCAID",MCAAMLH:"MCAAMLH",MCAAMB:"MCAAMB"},k={UNKNOWN:0,AUTHENTICATED:1,LOGGED_OUT:2},E={GLOBAL:"global"},T={MESSAGES:v,STATE_KEYS_MAP:D,ASYNC_API_MAP:y,SYNC_API_MAP:A,ALL_APIS:b,FIELDGROUP_TO_FIELD:O,FIELDS:M,AUTH_STATE:k,OPT_OUT:E},P=T.STATE_KEYS_MAP,L=function(e){function t(){}function n(t,n){var i=this;return function(){var r=e(0,t),a={};return a[t]=r,i.setStateAndPublish(a),n(r),r}}this.getMarketingCloudVisitorID=function(e){e=e||t;var i=this.findField(P.MCMID,e),r=n.call(this,P.MCMID,e);return void 0!==i?i:r()},this.getVisitorValues=function(e){this.getMarketingCloudVisitorID(function(t){e({MCMID:t})})}},R=T.MESSAGES,w=T.ASYNC_API_MAP,F=T.SYNC_API_MAP,N=function(){function e(){}function t(e,t){var n=this;return function(){return n.callbackRegistry.add(e,t),n.messageParent(R.GETSTATE),""}}function n(n){this[w[n]]=function(i){i=i||e;var r=this.findField(n,i),a=t.call(this,n,i);return void 0!==r?r:a()}}function i(t){this[F[t]]=function(){return this.findField(t,e)||{}}}Object.keys(w).forEach(n,this),Object.keys(F).forEach(i,this)},x=T.ASYNC_API_MAP,j=function(){Object.keys(x).forEach(function(e){this[x[e]]=function(t){this.callbackRegistry.add(e,t)}},this)},V=function(e,t){return t={exports:{}},e(t,t.exports),t.exports}(function(t,n){n.isObjectEmpty=function(e){return e===Object(e)&&0===Object.keys(e).length},n.isValueEmpty=function(e){return""===e||n.isObjectEmpty(e)};var i=function(){var e=navigator.appName,t=navigator.userAgent;return"Microsoft Internet Explorer"===e||t.indexOf("MSIE ")>=0||t.indexOf("Trident/")>=0&&t.indexOf("Windows NT 6")>=0};n.getIeVersion=function(){return document.documentMode?document.documentMode:i()?7:null},n.encodeAndBuildRequest=function(e,t){return e.map(encodeURIComponent).join(t)},n.isObject=function(t){return null!==t&&"object"===e(t)&&!1===Array.isArray(t)},n.defineGlobalNamespace=function(){return window.adobe=n.isObject(window.adobe)?window.adobe:{},window.adobe},n.pluck=function(e,t){return t.reduce(function(t,n){return e[n]&&(t[n]=e[n]),t},Object.create(null))},n.parseOptOut=function(e,t,n){t||(t=n,e.d_optout&&e.d_optout instanceof Array&&(t=e.d_optout.join(",")));var i=parseInt(e.d_ottl,10);return isNaN(i)&&(i=7200),{optOut:t,d_ottl:i}},n.normalizeBoolean=function(e){var t=e;return"true"===e?t=!0:"false"===e&&(t=!1),t}}),H=(V.isObjectEmpty,V.isValueEmpty,V.getIeVersion,V.encodeAndBuildRequest,V.isObject,V.defineGlobalNamespace,V.pluck,V.parseOptOut,V.normalizeBoolean,n),U=T.MESSAGES,B={0:"prefix",1:"orgID",2:"state"},G=function(e,t){this.parse=function(e){try{var t={};return e.data.split("|").forEach(function(e,n){if(void 0!==e){t[B[n]]=2!==n?e:JSON.parse(e)}}),t}catch(e){}},this.isInvalid=function(n){var i=this.parse(n);if(!i||Object.keys(i).length<2)return!0;var r=e!==i.orgID,a=!t||n.origin!==t,o=-1===Object.keys(U).indexOf(i.prefix);return r||a||o},this.send=function(n,i,r){var a=i+"|"+e;r&&r===Object(r)&&(a+="|"+JSON.stringify(r));try{n.postMessage(a,t)}catch(e){}}},Y=T.MESSAGES,q=function(e,t,n,i){function r(e){Object.assign(p,e)}function a(e){Object.assign(p.state,e),Object.assign(p.state.ALLFIELDS,e),p.callbackRegistry.executeAll(p.state)}function o(e){if(!h.isInvalid(e)){m=!1;var t=h.parse(e);p.setStateAndPublish(t.state)}}function s(e){!m&&g&&(m=!0,h.send(i,e))}function c(){r(new L(n._generateID)),p.getMarketingCloudVisitorID(),p.callbackRegistry.executeAll(p.state,!0),C.removeEventListener("message",u)}function u(e){if(!h.isInvalid(e)){var t=h.parse(e);m=!1,C.clearTimeout(p._handshakeTimeout),C.removeEventListener("message",u),r(new N(p)),C.addEventListener("message",o),p.setStateAndPublish(t.state),p.callbackRegistry.hasCallbacks()&&s(Y.GETSTATE)}}function l(){g&&postMessage?(C.addEventListener("message",u),s(Y.HANDSHAKE),p._handshakeTimeout=setTimeout(c,250)):c()}function d(){C.s_c_in||(C.s_c_il=[],C.s_c_in=0),p._c="Visitor",p._il=C.s_c_il,p._in=C.s_c_in,p._il[p._in]=p,C.s_c_in++}function f(){function e(e){0!==e.indexOf("_")&&"function"==typeof n[e]&&(p[e]=function(){})}Object.keys(n).forEach(e),p.getSupplementalDataID=n.getSupplementalDataID,p.isAllowed=function(){return!0}}var p=this,g=t.whitelistParentDomain;p.state={ALLFIELDS:{}},p.version=n.version,p.marketingCloudOrgID=e,p.cookieDomain=n.cookieDomain||"",p._instanceType="child";var m=!1,h=new G(e,g);p.callbackRegistry=H(),p.init=function(){d(),f(),r(new j(p)),l()},p.findField=function(e,t){if(void 0!==p.state[e])return t(p.state[e]),p.state[e]},p.messageParent=s,p.setStateAndPublish=a},W=T.MESSAGES,X=T.ALL_APIS,K=T.ASYNC_API_MAP,J=T.FIELDGROUP_TO_FIELD,z=function(e,t){function n(){var t={};return Object.keys(X).forEach(function(n){var i=X[n],r=e[i]();V.isValueEmpty(r)||(t[n]=r)}),t}function i(){var t=[];return e._loading&&Object.keys(e._loading).forEach(function(n){if(e._loading[n]){var i=J[n];t.push(i)}}),t.length?t:null}function r(t){return function n(r){var a=i();if(a){var o=K[a[0]];e[o](n,!0)}else t()}}function a(e,i){var r=n();t.send(e,i,r)}function o(e){c(e),a(e,W.HANDSHAKE)}function s(e){r(function(){a(e,W.PARENTSTATE)})()}function c(n){function i(i){r.call(e,i),t.send(n,W.PARENTSTATE,{CUSTOMERIDS:e.getCustomerIDs()})}var r=e.setCustomerIDs;e.setCustomerIDs=i}return function(e){if(!t.isInvalid(e)){(t.parse(e).prefix===W.HANDSHAKE?o:s)(e.source)}}},Q=function(e,t){function n(e){return function(n){i[e]=n,r++,r===a&&t(i)}}var i={},r=0,a=Object.keys(e).length;Object.keys(e).forEach(function(t){var i=e[t];if(i.fn){var r=i.args||[];r.unshift(n(t)),i.fn.apply(i.context||null,r)}})},$={get:function(e){e=encodeURIComponent(e);var t=(";"+document.cookie).split(" ").join(";"),n=t.indexOf(";"+e+"="),i=n<0?n:t.indexOf(";",n+1);return n<0?"":decodeURIComponent(t.substring(n+2+e.length,i<0?t.length:i))},set:function(e,t,n){var r=i(n,"cookieLifetime"),a=i(n,"expires"),o=i(n,"domain"),s=i(n,"secure"),c=s?"Secure":"";if(a&&"SESSION"!==r&&"NONE"!==r){var u=""!==t?parseInt(r||0,10):-60;if(u)a=new Date,a.setTime(a.getTime()+1e3*u);else if(1===a){a=new Date;var l=a.getYear();a.setYear(l+2+(l<1900?1900:0))}}else a=0;return e&&"NONE"!==r?(document.cookie=encodeURIComponent(e)+"="+encodeURIComponent(t)+"; path=/;"+(a?" expires="+a.toGMTString()+";":"")+(o?" domain="+o+";":"")+c,this.get(e)===t):0},remove:function(e,t){var n=i(t,"domain");n=n?" domain="+n+";":"",document.cookie=encodeURIComponent(e)+"=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;"+n}},Z=function(e){var t;!e&&C.location&&(e=C.location.hostname),t=e;var n,i=t.split(".");for(n=i.length-2;n>=0;n--)if(t=i.slice(n).join("."),$.set("test","cookie",{domain:t}))return $.remove("test",{domain:t}),t;return""},ee={compare:s,isLessThan:function(e,t){return s(e,t)<0},areVersionsDifferent:function(e,t){return 0!==s(e,t)},isGreaterThan:function(e,t){return s(e,t)>0},isEqual:function(e,t){return 0===s(e,t)}},te=!!C.postMessage,ne={postMessage:function(e,t,n){var i=1;t&&(te?n.postMessage(e,t.replace(/([^:]+:\/\/[^\/]+).*/,"$1")):t&&(n.location=t.replace(/#.*$/,"")+"#"+ +new Date+i+++"&"+e))},receiveMessage:function(e,t){var n;try{te&&(e&&(n=function(n){if("string"==typeof t&&n.origin!==t||"[object Function]"===Object.prototype.toString.call(t)&&!1===t(n.origin))return!1;e(n)}),C.addEventListener?C[e?"addEventListener":"removeEventListener"]("message",n):C[e?"attachEvent":"detachEvent"]("onmessage",n))}catch(e){}}},ie=function(e){var t,n,i="0123456789",r="",a="",o=8,s=10,c=10;if(1==e){for(i+="ABCDEF",t=0;16>t;t++)n=Math.floor(Math.random()*o),r+=i.substring(n,n+1),n=Math.floor(Math.random()*o),a+=i.substring(n,n+1),o=16;return r+"-"+a}for(t=0;19>t;t++)n=Math.floor(Math.random()*s),r+=i.substring(n,n+1),0===t&&9==n?s=3:(1==t||2==t)&&10!=s&&2>n?s=10:2<t&&(s=10),n=Math.floor(Math.random()*c),a+=i.substring(n,n+1),0===t&&9==n?c=3:(1==t||2==t)&&10!=c&&2>n?c=10:2<t&&(c=10);return r+a},re=function(e,t){return{corsMetadata:function(){var e="none",t=!0;return"undefined"!=typeof XMLHttpRequest&&XMLHttpRequest===Object(XMLHttpRequest)&&("withCredentials"in new XMLHttpRequest?e="XMLHttpRequest":"undefined"!=typeof XDomainRequest&&XDomainRequest===Object(XDomainRequest)&&(t=!1),Object.prototype.toString.call(C.HTMLElement).indexOf("Constructor")>0&&(t=!1)),{corsType:e,corsCookiesEnabled:t}}(),getCORSInstance:function(){return"none"===this.corsMetadata.corsType?null:new C[this.corsMetadata.corsType]},fireCORS:function(t,n,i){function r(e){var n;try{if((n=JSON.parse(e))!==Object(n))return void a.handleCORSError(t,null,"Response is not JSON")}catch(e){return void a.handleCORSError(t,e,"Error parsing response as JSON")}try{for(var i=t.callback,r=C,o=0;o<i.length;o++)r=r[i[o]];r(n)}catch(e){a.handleCORSError(t,e,"Error forming callback function")}}var a=this;n&&(t.loadErrorHandler=n);try{var o=this.getCORSInstance();o.open("get",t.corsUrl+"&ts="+(new Date).getTime(),!0),"XMLHttpRequest"===this.corsMetadata.corsType&&(o.withCredentials=!0,o.timeout=e.loadTimeout,o.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),o.onreadystatechange=function(){4===this.readyState&&200===this.status&&r(this.responseText)}),o.onerror=function(e){a.handleCORSError(t,e,"onerror")},o.ontimeout=function(e){a.handleCORSError(t,e,"ontimeout")},o.send(),e._log.requests.push(t.corsUrl)}catch(e){this.handleCORSError(t,e,"try-catch")}},handleCORSError:function(t,n,i){e.CORSErrors.push({corsData:t,error:n,description:i}),t.loadErrorHandler&&("ontimeout"===i?t.loadErrorHandler(!0):t.loadErrorHandler(!1))}}},ae={POST_MESSAGE_ENABLED:!!C.postMessage,DAYS_BETWEEN_SYNC_ID_CALLS:1,MILLIS_PER_DAY:864e5,ADOBE_MC:"adobe_mc",ADOBE_MC_SDID:"adobe_mc_sdid",VALID_VISITOR_ID_REGEX:/^[0-9a-fA-F\-]+$/,ADOBE_MC_TTL_IN_MIN:5,VERSION_REGEX:/vVersion\|((\d+\.)?(\d+\.)?(\*|\d+))(?=$|\|)/,FIRST_PARTY_SERVER_COOKIE:"s_ecid"},oe=function(e,t){var n=C.document;return{THROTTLE_START:3e4,MAX_SYNCS_LENGTH:649,throttleTimerSet:!1,id:null,onPagePixels:[],iframeHost:null,getIframeHost:function(e){if("string"==typeof e){var t=e.split("/");return t[0]+"//"+t[2]}},subdomain:null,url:null,getUrl:function(){var t,i="http://fast.",r="?d_nsid="+e.idSyncContainerID+"#"+encodeURIComponent(n.location.origin);return this.subdomain||(this.subdomain="nosubdomainreturned"),e.loadSSL&&(i=e.idSyncSSLUseAkamai?"https://fast.":"https://"),t=i+this.subdomain+".demdex.net/dest5.html"+r,this.iframeHost=this.getIframeHost(t),this.id="destination_publishing_iframe_"+this.subdomain+"_"+e.idSyncContainerID,t},checkDPIframeSrc:function(){var t="?d_nsid="+e.idSyncContainerID+"#"+encodeURIComponent(n.location.href);"string"==typeof e.dpIframeSrc&&e.dpIframeSrc.length&&(this.id="destination_publishing_iframe_"+(e._subdomain||this.subdomain||(new Date).getTime())+"_"+e.idSyncContainerID,this.iframeHost=this.getIframeHost(e.dpIframeSrc),this.url=e.dpIframeSrc+t)},idCallNotProcesssed:null,doAttachIframe:!1,startedAttachingIframe:!1,iframeHasLoaded:null,iframeIdChanged:null,newIframeCreated:null,originalIframeHasLoadedAlready:null,iframeLoadedCallbacks:[],regionChanged:!1,timesRegionChanged:0,sendingMessages:!1,messages:[],messagesPosted:[],messagesReceived:[],messageSendingInterval:ae.POST_MESSAGE_ENABLED?null:100,onPageDestinationsFired:[],jsonForComparison:[],jsonDuplicates:[],jsonWaiting:[],jsonProcessed:[],canSetThirdPartyCookies:!0,receivedThirdPartyCookiesNotification:!1,readyToAttachIframePreliminary:function(){return!(e.idSyncDisableSyncs||e.disableIdSyncs||e.idSyncDisable3rdPartySyncing||e.disableThirdPartyCookies||e.disableThirdPartyCalls)},readyToAttachIframe:function(){return this.readyToAttachIframePreliminary()&&(this.doAttachIframe||e._doAttachIframe)&&(this.subdomain&&"nosubdomainreturned"!==this.subdomain||e._subdomain)&&this.url&&!this.startedAttachingIframe},attachIframe:function(){function e(){r=n.createElement("iframe"),r.sandbox="allow-scripts allow-same-origin",r.title="Adobe ID Syncing iFrame",r.id=i.id,r.name=i.id+"_name",r.style.cssText="display: none; width: 0; height: 0;",r.src=i.url,i.newIframeCreated=!0,t(),n.body.appendChild(r)}function t(e){r.addEventListener("load",function(){r.className="aamIframeLoaded",i.iframeHasLoaded=!0,i.fireIframeLoadedCallbacks(e),i.requestToProcess()})}this.startedAttachingIframe=!0;var i=this,r=n.getElementById(this.id);r?"IFRAME"!==r.nodeName?(this.id+="_2",this.iframeIdChanged=!0,e()):(this.newIframeCreated=!1,"aamIframeLoaded"!==r.className?(this.originalIframeHasLoadedAlready=!1,t("The destination publishing iframe already exists from a different library, but hadn't loaded yet.")):(this.originalIframeHasLoadedAlready=!0,this.iframeHasLoaded=!0,this.iframe=r,this.fireIframeLoadedCallbacks("The destination publishing iframe already exists from a different library, and had loaded alresady."),this.requestToProcess())):e(),this.iframe=r},fireIframeLoadedCallbacks:function(e){this.iframeLoadedCallbacks.forEach(function(t){"function"==typeof t&&t({message:e||"The destination publishing iframe was attached and loaded successfully."})}),this.iframeLoadedCallbacks=[]},requestToProcess:function(t){function n(){r.jsonForComparison.push(t),r.jsonWaiting.push(t),r.processSyncOnPage(t)}var i,r=this;if(t===Object(t)&&t.ibs)if(i=JSON.stringify(t.ibs||[]),this.jsonForComparison.length){var a,o,s,c=!1;for(a=0,o=this.jsonForComparison.length;a<o;a++)if(s=this.jsonForComparison[a],i===JSON.stringify(s.ibs||[])){c=!0;break}c?this.jsonDuplicates.push(t):n()}else n();if((this.receivedThirdPartyCookiesNotification||!ae.POST_MESSAGE_ENABLED||this.iframeHasLoaded)&&this.jsonWaiting.length){var u=this.jsonWaiting.shift();this.process(u),this.requestToProcess()}e.idSyncDisableSyncs||e.disableIdSyncs||!this.iframeHasLoaded||!this.messages.length||this.sendingMessages||(this.throttleTimerSet||(this.throttleTimerSet=!0,setTimeout(function(){r.messageSendingInterval=ae.POST_MESSAGE_ENABLED?null:150},this.THROTTLE_START)),this.sendingMessages=!0,this.sendMessages())},getRegionAndCheckIfChanged:function(t,n){var i=e._getField("MCAAMLH"),r=t.d_region||t.dcs_region;return i?r&&(e._setFieldExpire("MCAAMLH",n),e._setField("MCAAMLH",r),parseInt(i,10)!==r&&(this.regionChanged=!0,this.timesRegionChanged++,e._setField("MCSYNCSOP",""),e._setField("MCSYNCS",""),i=r)):(i=r)&&(e._setFieldExpire("MCAAMLH",n),e._setField("MCAAMLH",i)),i||(i=""),i},processSyncOnPage:function(e){var t,n,i,r;if((t=e.ibs)&&t instanceof Array&&(n=t.length))for(i=0;i<n;i++)r=t[i],r.syncOnPage&&this.checkFirstPartyCookie(r,"","syncOnPage")},process:function(e){var t,n,i,r,a,o=encodeURIComponent,s=!1;if((t=e.ibs)&&t instanceof Array&&(n=t.length))for(s=!0,i=0;i<n;i++)r=t[i],a=[o("ibs"),o(r.id||""),o(r.tag||""),V.encodeAndBuildRequest(r.url||[],","),o(r.ttl||""),"","",r.fireURLSync?"true":"false"],r.syncOnPage||(this.canSetThirdPartyCookies?this.addMessage(a.join("|")):r.fireURLSync&&this.checkFirstPartyCookie(r,a.join("|")));s&&this.jsonProcessed.push(e)},checkFirstPartyCookie:function(t,n,i){var r="syncOnPage"===i,a=r?"MCSYNCSOP":"MCSYNCS";e._readVisitor();var o,s,c=e._getField(a),u=!1,l=!1,d=Math.ceil((new Date).getTime()/ae.MILLIS_PER_DAY);c?(o=c.split("*"),s=this.pruneSyncData(o,t.id,d),u=s.dataPresent,l=s.dataValid,u&&l||this.fireSync(r,t,n,o,a,d)):(o=[],this.fireSync(r,t,n,o,a,d))},pruneSyncData:function(e,t,n){var i,r,a,o=!1,s=!1;for(r=0;r<e.length;r++)i=e[r],a=parseInt(i.split("-")[1],10),i.match("^"+t+"-")?(o=!0,n<a?s=!0:(e.splice(r,1),r--)):n>=a&&(e.splice(r,1),r--);return{dataPresent:o,dataValid:s}},manageSyncsSize:function(e){if(e.join("*").length>this.MAX_SYNCS_LENGTH)for(e.sort(function(e,t){return parseInt(e.split("-")[1],10)-parseInt(t.split("-")[1],10)});e.join("*").length>this.MAX_SYNCS_LENGTH;)e.shift()},fireSync:function(t,n,i,r,a,o){var s=this;if(t){if("img"===n.tag){var c,u,l,d,f=n.url,p=e.loadSSL?"https:":"http:";for(c=0,u=f.length;c<u;c++){l=f[c],d=/^\/\//.test(l);var g=new Image;g.addEventListener("load",function(t,n,i,r){return function(){s.onPagePixels[t]=null,e._readVisitor();var o,c=e._getField(a),u=[];if(c){o=c.split("*");var l,d,f;for(l=0,d=o.length;l<d;l++)f=o[l],f.match("^"+n.id+"-")||u.push(f)}s.setSyncTrackingData(u,n,i,r)}}(this.onPagePixels.length,n,a,o)),g.src=(d?p:"")+l,this.onPagePixels.push(g)}}}else this.addMessage(i),this.setSyncTrackingData(r,n,a,o)},addMessage:function(t){var n=encodeURIComponent,i=n(e._enableErrorReporting?"---destpub-debug---":"---destpub---");this.messages.push((ae.POST_MESSAGE_ENABLED?"":i)+t)},setSyncTrackingData:function(t,n,i,r){t.push(n.id+"-"+(r+Math.ceil(n.ttl/60/24))),this.manageSyncsSize(t),e._setField(i,t.join("*"))},sendMessages:function(){var e,t=this,n="",i=encodeURIComponent;this.regionChanged&&(n=i("---destpub-clear-dextp---"),this.regionChanged=!1),this.messages.length?ae.POST_MESSAGE_ENABLED?(e=n+i("---destpub-combined---")+this.messages.join("%01"),this.postMessage(e),this.messages=[],this.sendingMessages=!1):(e=this.messages.shift(),this.postMessage(n+e),setTimeout(function(){t.sendMessages()},this.messageSendingInterval)):this.sendingMessages=!1},postMessage:function(e){ne.postMessage(e,this.url,this.iframe.contentWindow),this.messagesPosted.push(e)},receiveMessage:function(e){var t,n=/^---destpub-to-parent---/;"string"==typeof e&&n.test(e)&&(t=e.replace(n,"").split("|"),"canSetThirdPartyCookies"===t[0]&&(this.canSetThirdPartyCookies="true"===t[1],this.receivedThirdPartyCookiesNotification=!0,this.requestToProcess()),this.messagesReceived.push(e))},processIDCallData:function(i){(null==this.url||i.subdomain&&"nosubdomainreturned"===this.subdomain)&&("string"==typeof e._subdomain&&e._subdomain.length?this.subdomain=e._subdomain:this.subdomain=i.subdomain||"",this.url=this.getUrl()),i.ibs instanceof Array&&i.ibs.length&&(this.doAttachIframe=!0),this.readyToAttachIframe()&&(e.idSyncAttachIframeOnWindowLoad?(t.windowLoaded||"complete"===n.readyState||"loaded"===n.readyState)&&this.attachIframe():this.attachIframeASAP()),"function"==typeof e.idSyncIDCallResult?e.idSyncIDCallResult(i):this.requestToProcess(i),"function"==typeof e.idSyncAfterIDCallResult&&e.idSyncAfterIDCallResult(i)},canMakeSyncIDCall:function(t,n){return e._forceSyncIDCall||!t||n-t>ae.DAYS_BETWEEN_SYNC_ID_CALLS},attachIframeASAP:function(){function e(){t.startedAttachingIframe||(n.body?t.attachIframe():setTimeout(e,30))}var t=this;e()}}},se={audienceManagerServer:{},audienceManagerServerSecure:{},cookieDomain:{},cookieLifetime:{},cookieName:{},doesOptInApply:{},disableThirdPartyCalls:{},discardTrackingServerECID:{},idSyncAfterIDCallResult:{},idSyncAttachIframeOnWindowLoad:{},idSyncContainerID:{},idSyncDisable3rdPartySyncing:{},disableThirdPartyCookies:{},idSyncDisableSyncs:{},disableIdSyncs:{},idSyncIDCallResult:{},idSyncSSLUseAkamai:{},isCoopSafe:{},isIabContext:{},isOptInStorageEnabled:{},loadSSL:{},loadTimeout:{},marketingCloudServer:{},marketingCloudServerSecure:{},optInCookieDomain:{},optInStorageExpiry:{},overwriteCrossDomainMCIDAndAID:{},preOptInApprovals:{},previousPermissions:{},resetBeforeVersion:{},sdidParamExpiry:{},serverState:{},sessionCookieName:{},secureCookie:{},takeTimeoutMetrics:{},trackingServer:{},trackingServerSecure:{},whitelistIframeDomains:{},whitelistParentDomain:{}},ce={getConfigNames:function(){return Object.keys(se)},getConfigs:function(){return se},normalizeConfig:function(e){return"function"!=typeof e?e:e()}},ue=function(e){var t={};return e.on=function(e,n,i){if(!n||"function"!=typeof n)throw new Error("[ON] Callback should be a function.");t.hasOwnProperty(e)||(t[e]=[]);var r=t[e].push({callback:n,context:i})-1;return function(){t[e].splice(r,1),t[e].length||delete t[e]}},e.off=function(e,n){t.hasOwnProperty(e)&&(t[e]=t[e].filter(function(e){if(e.callback!==n)return e}))},e.publish=function(e){if(t.hasOwnProperty(e)){var n=[].slice.call(arguments,1);t[e].slice(0).forEach(function(e){e.callback.apply(e.context,n)})}},e.publish},le={PENDING:"pending",CHANGED:"changed",COMPLETE:"complete"},de={AAM:"aam",ADCLOUD:"adcloud",ANALYTICS:"aa",CAMPAIGN:"campaign",ECID:"ecid",LIVEFYRE:"livefyre",TARGET:"target",MEDIA_ANALYTICS:"mediaaa"},fe=(I={},t(I,de.AAM,565),t(I,de.ECID,565),I),pe=(S={},t(S,de.AAM,[1,10]),t(S,de.ECID,[1,10]),S),ge=["videoaa","iabConsentHash"],me=function(e){return Object.keys(e).map(function(t){return e[t]})}(de),he=function(){var e={};return e.callbacks=Object.create(null),e.add=function(t,n){if(!u(n))throw new Error("[callbackRegistryFactory] Make sure callback is a function or an array of functions.");e.callbacks[t]=e.callbacks[t]||[];var i=e.callbacks[t].push(n)-1;return function(){e.callbacks[t].splice(i,1)}},e.execute=function(t,n){if(e.callbacks[t]){n=void 0===n?[]:n,n=n instanceof Array?n:[n];try{for(;e.callbacks[t].length;){var i=e.callbacks[t].shift();"function"==typeof i?i.apply(null,n):i instanceof Array&&i[1].apply(i[0],n)}delete e.callbacks[t]}catch(e){}}},e.executeAll=function(t,n){(n||t&&!c(t))&&Object.keys(e.callbacks).forEach(function(n){var i=void 0!==t[n]?t[n]:"";e.execute(n,i)},e)},e.hasCallbacks=function(){return Boolean(Object.keys(e.callbacks).length)},e},_e=function(){},Ce=function(e){var t=window,n=t.console;return!!n&&"function"==typeof n[e]},Ie=function(e,t,n){return n()?function(){if(Ce(e)){for(var n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];console[e].apply(console,[t].concat(i))}}:_e},Se=l,ve=function(){for(var e=[],t=0;t<256;t++){for(var n=t,i=0;i<8;i++)n=1&n?3988292384^n>>>1:n>>>1;e.push(n)}return function(t,n){t=unescape(encodeURIComponent(t)),n||(n=0),n^=-1;for(var i=0;i<t.length;i++){var r=255&(n^t.charCodeAt(i));n=n>>>8^e[r]}return(n^=-1)>>>0}}(),De=new Se("[ADOBE OPT-IN]"),ye=function(t,n){return e(t)===n},Ae=function(e,t){return e instanceof Array?e:ye(e,"string")?[e]:t||[]},be=function(e){var t=Object.keys(e);return!!t.length&&t.every(function(t){return!0===e[t]})},Oe=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!(!e||Ee(e))&&Ae(e).every(function(e){return me.indexOf(e)>-1||t&&ge.indexOf(e)>-1})},Me=function(e,t){return e.reduce(function(e,n){return e[n]=t,e},{})},ke=function(e){return JSON.parse(JSON.stringify(e))},Ee=function(e){return"[object Array]"===Object.prototype.toString.call(e)&&!e.length},Te=function(e){if(Re(e))return e;try{return JSON.parse(e)}catch(e){return{}}},Pe=function(e){return void 0===e||(Re(e)?Oe(Object.keys(e),!0):Le(e))},Le=function(e){try{var t=JSON.parse(e);return!!e&&ye(e,"string")&&Oe(Object.keys(t),!0)}catch(e){return!1}},Re=function(e){return null!==e&&ye(e,"object")&&!1===Array.isArray(e)},we=function(){},Fe=function(e){return ye(e,"function")?e():e},Ne=function(e,t){Pe(e)||De.error("".concat(t))},xe=function(e){return Object.keys(e).map(function(t){return e[t]})},je=function(e){return xe(e).filter(function(e,t,n){return n.indexOf(e)===t})},Ve=function(e){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=t.command,i=t.params,r=void 0===i?{}:i,a=t.callback,o=void 0===a?we:a;if(!n||-1===n.indexOf("."))throw new Error("[OptIn.execute] Please provide a valid command.");try{var s=n.split("."),c=e[s[0]],u=s[1];if(!c||"function"!=typeof c[u])throw new Error("Make sure the plugin and API name exist.");var l=Object.assign(r,{callback:o});c[u].call(c,l)}catch(e){De.error("[execute] Something went wrong: "+e.message)}}};f.prototype=Object.create(Error.prototype),f.prototype.constructor=f;var He="fetchPermissions",Ue="[OptIn#registerPlugin] Plugin is invalid.";p.Categories=de,p.TimeoutError=f;var Be=Object.freeze({OptIn:p,IabPlugin:_}),Ge=function(e,t){e.publishDestinations=function(n){var i=arguments[1],r=arguments[2];try{r="function"==typeof r?r:n.callback}catch(e){r=function(){}}var a=t;if(!a.readyToAttachIframePreliminary())return void r({error:"The destination publishing iframe is disabled in the Visitor library."});if("string"==typeof n){
if(!n.length)return void r({error:"subdomain is not a populated string."});if(!(i instanceof Array&&i.length))return void r({error:"messages is not a populated array."});var o=!1;if(i.forEach(function(e){"string"==typeof e&&e.length&&(a.addMessage(e),o=!0)}),!o)return void r({error:"None of the messages are populated strings."})}else{if(!V.isObject(n))return void r({error:"Invalid parameters passed."});var s=n;if("string"!=typeof(n=s.subdomain)||!n.length)return void r({error:"config.subdomain is not a populated string."});var c=s.urlDestinations;if(!(c instanceof Array&&c.length))return void r({error:"config.urlDestinations is not a populated array."});var u=[];c.forEach(function(e){V.isObject(e)&&(e.hideReferrer?e.message&&a.addMessage(e.message):u.push(e))});!function e(){u.length&&setTimeout(function(){var t=new Image,n=u.shift();t.src=n.url,a.onPageDestinationsFired.push(n),e()},100)}()}a.iframe?(r({message:"The destination publishing iframe is already attached and loaded."}),a.requestToProcess()):!e.subdomain&&e._getField("MCMID")?(a.subdomain=n,a.doAttachIframe=!0,a.url=a.getUrl(),a.readyToAttachIframe()?(a.iframeLoadedCallbacks.push(function(e){r({message:"Attempted to attach and load the destination publishing iframe through this API call. Result: "+(e.message||"no result")})}),a.attachIframe()):r({error:"Encountered a problem in attempting to attach and load the destination publishing iframe through this API call."})):a.iframeLoadedCallbacks.push(function(e){r({message:"Attempted to attach and load the destination publishing iframe through normal Visitor API processing. Result: "+(e.message||"no result")})})}},Ye=function e(t){function n(e,t){return e>>>t|e<<32-t}for(var i,r,a=Math.pow,o=a(2,32),s="",c=[],u=8*t.length,l=e.h=e.h||[],d=e.k=e.k||[],f=d.length,p={},g=2;f<64;g++)if(!p[g]){for(i=0;i<313;i+=g)p[i]=g;l[f]=a(g,.5)*o|0,d[f++]=a(g,1/3)*o|0}for(t+="Â€";t.length%64-56;)t+="\0";for(i=0;i<t.length;i++){if((r=t.charCodeAt(i))>>8)return;c[i>>2]|=r<<(3-i)%4*8}for(c[c.length]=u/o|0,c[c.length]=u,r=0;r<c.length;){var m=c.slice(r,r+=16),h=l;for(l=l.slice(0,8),i=0;i<64;i++){var _=m[i-15],C=m[i-2],I=l[0],S=l[4],v=l[7]+(n(S,6)^n(S,11)^n(S,25))+(S&l[5]^~S&l[6])+d[i]+(m[i]=i<16?m[i]:m[i-16]+(n(_,7)^n(_,18)^_>>>3)+m[i-7]+(n(C,17)^n(C,19)^C>>>10)|0);l=[v+((n(I,2)^n(I,13)^n(I,22))+(I&l[1]^I&l[2]^l[1]&l[2]))|0].concat(l),l[4]=l[4]+v|0}for(i=0;i<8;i++)l[i]=l[i]+h[i]|0}for(i=0;i<8;i++)for(r=3;r+1;r--){var D=l[i]>>8*r&255;s+=(D<16?0:"")+D.toString(16)}return s},qe=function(e,t){return"SHA-256"!==t&&"SHA256"!==t&&"sha256"!==t&&"sha-256"!==t||(e=Ye(e)),e},We=function(e){return String(e).trim().toLowerCase()},Xe=Be.OptIn;V.defineGlobalNamespace(),window.adobe.OptInCategories=Xe.Categories;var Ke=function(t,n,i){function r(){I._customerIDsHashChanged=!1}function a(e){var t=e;return function(e){var n=e||b.location.href;try{var i=I._extractParamFromUri(n,t);if(i)return B.parsePipeDelimetedKeyValues(i)}catch(e){}}}function o(e){function t(e,t,n){e&&e.match(ae.VALID_VISITOR_ID_REGEX)&&(n===E&&(A=!0),t(e))}t(e[E],I.setMarketingCloudVisitorID,E),I._setFieldExpire(F,-1),t(e[R],I.setAnalyticsVisitorID)}function s(e){e=e||{},I._supplementalDataIDCurrent=e.supplementalDataIDCurrent||"",I._supplementalDataIDCurrentConsumed=e.supplementalDataIDCurrentConsumed||{},I._supplementalDataIDLast=e.supplementalDataIDLast||"",I._supplementalDataIDLastConsumed=e.supplementalDataIDLastConsumed||{}}function c(e){function t(e,t,n){return n=n?n+="|":n,n+=e+"="+encodeURIComponent(t)}function n(e,n){var i=n[0],r=n[1];return null!=r&&r!==N&&(e=t(i,r,e)),e}var i=e.reduce(n,"");return function(e){var t=B.getTimestampInSeconds();return e=e?e+="|":e,e+="TS="+t}(i)}function u(e){var t=e.minutesToLive,n="";return(I.idSyncDisableSyncs||I.disableIdSyncs)&&(n=n||"Error: id syncs have been disabled"),"string"==typeof e.dpid&&e.dpid.length||(n=n||"Error: config.dpid is empty"),"string"==typeof e.url&&e.url.length||(n=n||"Error: config.url is empty"),void 0===t?t=20160:(t=parseInt(t,10),(isNaN(t)||t<=0)&&(n=n||"Error: config.minutesToLive needs to be a positive number")),{error:n,ttl:t}}function l(){return!!I.configs.doesOptInApply&&!(S.optIn.isComplete&&d())}function d(){return I.configs.doesOptInApply&&I.configs.isIabContext?S.optIn.isApproved(S.optIn.Categories.ECID)&&y:S.optIn.isApproved(S.optIn.Categories.ECID)}function f(){[["getMarketingCloudVisitorID"],["setCustomerIDs",void 0],["syncIdentity",void 0],["getAnalyticsVisitorID"],["getAudienceManagerLocationHint"],["getLocationHint"],["getAudienceManagerBlob"]].forEach(function(e){var t=e[0],n=2===e.length?e[1]:"",i=I[t];I[t]=function(e){return d()&&I.isAllowed()?i.apply(I,arguments):("function"==typeof e&&I._callCallback(e,[n]),n)}})}function p(){var e=I._getAudienceManagerURLData(),t=e.url;return I._loadData(k,t,null,e)}function g(e,t){if(y=!0,e)throw new Error("[IAB plugin] : "+e);t&&t.gdprApplies&&(v=t.consentString,D=t.hasConsentChangedSinceLastCmpPull?1:0),p(),_()}function m(e,t){if(y=!0,e)throw new Error("[IAB plugin] : "+e);t.gdprApplies&&(v=t.consentString,D=t.hasConsentChangedSinceLastCmpPull?1:0),I.init(),_()}function h(){S.optIn.isComplete&&(S.optIn.isApproved(S.optIn.Categories.ECID)?I.configs.isIabContext?S.optIn.execute({command:"iabPlugin.fetchConsentData",callback:m}):(I.init(),_()):I.configs.isIabContext?S.optIn.execute({command:"iabPlugin.fetchConsentData",callback:g}):(f(),_()))}function _(){S.optIn.off("complete",h)}if(!i||i.split("").reverse().join("")!==t)throw new Error("Please use `Visitor.getInstance` to instantiate Visitor.");var I=this,S=window.adobe,v="",D=0,y=!1,A=!1;I.version="5.0.0";var b=C,O=b.Visitor;O.version=I.version,O.AuthState=T.AUTH_STATE,O.OptOut=T.OPT_OUT,b.s_c_in||(b.s_c_il=[],b.s_c_in=0),I._c="Visitor",I._il=b.s_c_il,I._in=b.s_c_in,I._il[I._in]=I,b.s_c_in++,I._instanceType="regular",I._log={requests:[]},I.marketingCloudOrgID=t,I.cookieName="AMCV_"+t,I.sessionCookieName="AMCVS_"+t,I.cookieDomain=Z(),I.loadSSL=!0,I.loadTimeout=3e4,I.CORSErrors=[],I.marketingCloudServer=I.audienceManagerServer="dpm.demdex.net",I.sdidParamExpiry=30;var M=null,k="MC",E="MCMID",P="MCIDTS",L="A",R="MCAID",w="AAM",F="MCAAMB",N="NONE",x=function(e){return!Object.prototype[e]},j=re(I);I.FIELDS=T.FIELDS,I.cookieRead=function(e){return $.get(e)},I.cookieWrite=function(e,t,n){var i=I.cookieLifetime?(""+I.cookieLifetime).toUpperCase():"",r=!1;return I.configs&&I.configs.secureCookie&&"https:"===location.protocol&&(r=!0),$.set(e,""+t,{expires:n,domain:I.cookieDomain,cookieLifetime:i,secure:r})},I.resetState=function(e){e?I._mergeServerState(e):s()},I._isAllowedDone=!1,I._isAllowedFlag=!1,I.isAllowed=function(){return I._isAllowedDone||(I._isAllowedDone=!0,(I.cookieRead(I.cookieName)||I.cookieWrite(I.cookieName,"T",1))&&(I._isAllowedFlag=!0)),"T"===I.cookieRead(I.cookieName)&&I._helpers.removeCookie(I.cookieName),I._isAllowedFlag},I.setMarketingCloudVisitorID=function(e){I._setMarketingCloudFields(e)},I._use1stPartyMarketingCloudServer=!1,I.getMarketingCloudVisitorID=function(e,t){I.marketingCloudServer&&I.marketingCloudServer.indexOf(".demdex.net")<0&&(I._use1stPartyMarketingCloudServer=!0);var n=I._getAudienceManagerURLData("_setMarketingCloudFields"),i=n.url;return I._getRemoteField(E,i,e,t,n)};var H=function(e,t){var n={};I.getMarketingCloudVisitorID(function(){t.forEach(function(e){n[e]=I._getField(e,!0)}),-1!==t.indexOf("MCOPTOUT")?I.isOptedOut(function(t){n.MCOPTOUT=t,e(n)},null,!0):e(n)},!0)};I.getVisitorValues=function(e,t){var n={MCMID:{fn:I.getMarketingCloudVisitorID,args:[!0],context:I},MCOPTOUT:{fn:I.isOptedOut,args:[void 0,!0],context:I},MCAID:{fn:I.getAnalyticsVisitorID,args:[!0],context:I},MCAAMLH:{fn:I.getAudienceManagerLocationHint,args:[!0],context:I},MCAAMB:{fn:I.getAudienceManagerBlob,args:[!0],context:I}},i=t&&t.length?V.pluck(n,t):n;t&&-1===t.indexOf("MCAID")?H(e,t):Q(i,e)},I._currentCustomerIDs={},I._customerIDsHashChanged=!1,I._newCustomerIDsHash="",I.setCustomerIDs=function(t,n){if(!I.isOptedOut()&&t){if(!V.isObject(t)||V.isObjectEmpty(t))return!1;I._readVisitor();var i,a,o,s;for(i in t)if(x(i)&&(I._currentCustomerIDs.dataSources=I._currentCustomerIDs.dataSources||{},a=t[i],n=a.hasOwnProperty("hashType")?a.hashType:n,a))if("object"===e(a)){var c={};if(a.id){if(n){if(!(s=qe(We(a.id),n)))return;a.id=s,c.hashType=n}c.id=a.id}void 0!=a.authState&&(c.authState=a.authState),I._currentCustomerIDs.dataSources[i]=c}else if(n){if(!(s=qe(We(a),n)))return;I._currentCustomerIDs.dataSources[i]={id:s,hashType:n}}else I._currentCustomerIDs.dataSources[i]={id:a};var u=I.getCustomerIDs(!0),l=I._getField("MCCIDH"),d="";l||(l=0);for(o in u){var f=u[o];if(!V.isObjectEmpty(f))for(i in f)x(i)&&(a=f[i],d+=(d?"|":"")+i+"|"+(a.id?a.id:"")+(a.authState?a.authState:""))}I._newCustomerIDsHash=String(I._hash(d)),I._newCustomerIDsHash!==l&&(I._customerIDsHashChanged=!0,I._mapCustomerIDs(r))}},I.syncIdentity=function(t,n){if(!I.isOptedOut()&&t){if(!V.isObject(t)||V.isObjectEmpty(t))return!1;I._readVisitor();var i,a,o,s,c;for(i in t)if(x(i)&&(I._currentCustomerIDs.nameSpaces=I._currentCustomerIDs.nameSpaces||{},a=t[i],n=a.hasOwnProperty("hashType")?a.hashType:n,a&&"object"===e(a))){var u={};if(a.id){if(n){if(!(o=qe(We(a.id),n)))return;a.id=o,u.hashType=n}u.id=a.id}void 0!=a.authState&&(u.authState=a.authState),a.dataSource&&(I._currentCustomerIDs.dataSources=I._currentCustomerIDs.dataSources||{},s=a.dataSource,I._currentCustomerIDs.dataSources[s]=u),I._currentCustomerIDs.nameSpaces[i]=u}var l=I.getCustomerIDs(!0),d=I._getField("MCCIDH"),f="";d||(d="0");for(c in l){var p=l[c];if(!V.isObjectEmpty(p))for(i in p)x(i)&&(a=p[i],f+=(f?"|":"")+i+"|"+(a.id?a.id:"")+(a.authState?a.authState:""))}I._newCustomerIDsHash=String(I._hash(f)),I._newCustomerIDsHash!==d&&(I._customerIDsHashChanged=!0,I._mapCustomerIDs(r))}},I.getCustomerIDs=function(e){I._readVisitor();var t,n,i={dataSources:{},nameSpaces:{}},r=I._currentCustomerIDs.dataSources;for(t in r)x(t)&&(n=r[t],n.id&&(i.dataSources[t]||(i.dataSources[t]={}),i.dataSources[t].id=n.id,void 0!=n.authState?i.dataSources[t].authState=n.authState:i.dataSources[t].authState=O.AuthState.UNKNOWN,n.hashType&&(i.dataSources[t].hashType=n.hashType)));var a=I._currentCustomerIDs.nameSpaces;for(t in a)x(t)&&(n=a[t],n.id&&(i.nameSpaces[t]||(i.nameSpaces[t]={}),i.nameSpaces[t].id=n.id,void 0!=n.authState?i.nameSpaces[t].authState=n.authState:i.nameSpaces[t].authState=O.AuthState.UNKNOWN,n.hashType&&(i.nameSpaces[t].hashType=n.hashType)));return e?i:i.dataSources},I.setAnalyticsVisitorID=function(e){I._setAnalyticsFields(e)},I.getAnalyticsVisitorID=function(e,t,n){if(!B.isTrackingServerPopulated()&&!n)return I._callCallback(e,[""]),"";var i="";if(n||(i=I.getMarketingCloudVisitorID(function(t){I.getAnalyticsVisitorID(e,!0)})),i||n){var r=n?I.marketingCloudServer:I.trackingServer,a="";I.loadSSL&&(n?I.marketingCloudServerSecure&&(r=I.marketingCloudServerSecure):I.trackingServerSecure&&(r=I.trackingServerSecure));var o={};if(r){var s="http"+(I.loadSSL?"s":"")+"://"+r+"/id",c="d_visid_ver="+I.version+"&mcorgid="+encodeURIComponent(I.marketingCloudOrgID)+(i?"&mid="+encodeURIComponent(i):"")+(I.idSyncDisable3rdPartySyncing||I.disableThirdPartyCookies?"&d_coppa=true":""),u=["s_c_il",I._in,"_set"+(n?"MarketingCloud":"Analytics")+"Fields"];a=s+"?"+c+"&callback=s_c_il%5B"+I._in+"%5D._set"+(n?"MarketingCloud":"Analytics")+"Fields",o.corsUrl=s+"?"+c,o.callback=u}return o.url=a,I._getRemoteField(n?E:R,a,e,t,o)}return""},I.getAudienceManagerLocationHint=function(e,t){if(I.getMarketingCloudVisitorID(function(t){I.getAudienceManagerLocationHint(e,!0)})){var n=I._getField(R);if(!n&&B.isTrackingServerPopulated()&&(n=I.getAnalyticsVisitorID(function(t){I.getAudienceManagerLocationHint(e,!0)})),n||!B.isTrackingServerPopulated()){var i=I._getAudienceManagerURLData(),r=i.url;return I._getRemoteField("MCAAMLH",r,e,t,i)}}return""},I.getLocationHint=I.getAudienceManagerLocationHint,I.getAudienceManagerBlob=function(e,t){if(I.getMarketingCloudVisitorID(function(t){I.getAudienceManagerBlob(e,!0)})){var n=I._getField(R);if(!n&&B.isTrackingServerPopulated()&&(n=I.getAnalyticsVisitorID(function(t){I.getAudienceManagerBlob(e,!0)})),n||!B.isTrackingServerPopulated()){var i=I._getAudienceManagerURLData(),r=i.url;return I._customerIDsHashChanged&&I._setFieldExpire(F,-1),I._getRemoteField(F,r,e,t,i)}}return""},I._supplementalDataIDCurrent="",I._supplementalDataIDCurrentConsumed={},I._supplementalDataIDLast="",I._supplementalDataIDLastConsumed={},I.getSupplementalDataID=function(e,t){I._supplementalDataIDCurrent||t||(I._supplementalDataIDCurrent=I._generateID(1));var n=I._supplementalDataIDCurrent;return I._supplementalDataIDLast&&!I._supplementalDataIDLastConsumed[e]?(n=I._supplementalDataIDLast,I._supplementalDataIDLastConsumed[e]=!0):n&&(I._supplementalDataIDCurrentConsumed[e]&&(I._supplementalDataIDLast=I._supplementalDataIDCurrent,I._supplementalDataIDLastConsumed=I._supplementalDataIDCurrentConsumed,I._supplementalDataIDCurrent=n=t?"":I._generateID(1),I._supplementalDataIDCurrentConsumed={}),n&&(I._supplementalDataIDCurrentConsumed[e]=!0)),n};var U=!1;I._liberatedOptOut=null,I.getOptOut=function(e,t){var n=I._getAudienceManagerURLData("_setMarketingCloudFields"),i=n.url;if(d())return I._getRemoteField("MCOPTOUT",i,e,t,n);if(I._registerCallback("liberatedOptOut",e),null!==I._liberatedOptOut)return I._callAllCallbacks("liberatedOptOut",[I._liberatedOptOut]),U=!1,I._liberatedOptOut;if(U)return null;U=!0;var r="liberatedGetOptOut";return n.corsUrl=n.corsUrl.replace(/\.demdex\.net\/id\?/,".demdex.net/optOutStatus?"),n.callback=[r],C[r]=function(e){if(e===Object(e)){var t,n,i=V.parseOptOut(e,t,N);t=i.optOut,n=1e3*i.d_ottl,I._liberatedOptOut=t,setTimeout(function(){I._liberatedOptOut=null},n)}I._callAllCallbacks("liberatedOptOut",[t]),U=!1},j.fireCORS(n),null},I.isOptedOut=function(e,t,n){t||(t=O.OptOut.GLOBAL);var i=I.getOptOut(function(n){var i=n===O.OptOut.GLOBAL||n.indexOf(t)>=0;I._callCallback(e,[i])},n);return i?i===O.OptOut.GLOBAL||i.indexOf(t)>=0:null},I._fields=null,I._fieldsExpired=null,I._hash=function(e){var t,n,i=0;if(e)for(t=0;t<e.length;t++)n=e.charCodeAt(t),i=(i<<5)-i+n,i&=i;return i},I._generateID=ie,I._generateLocalMID=function(){var e=I._generateID(0);return q.isClientSideMarketingCloudVisitorID=!0,e},I._callbackList=null,I._callCallback=function(e,t){try{"function"==typeof e?e.apply(b,t):e[1].apply(e[0],t)}catch(e){}},I._registerCallback=function(e,t){t&&(null==I._callbackList&&(I._callbackList={}),void 0==I._callbackList[e]&&(I._callbackList[e]=[]),I._callbackList[e].push(t))},I._callAllCallbacks=function(e,t){if(null!=I._callbackList){var n=I._callbackList[e];if(n)for(;n.length>0;)I._callCallback(n.shift(),t)}},I._addQuerystringParam=function(e,t,n,i){var r=encodeURIComponent(t)+"="+encodeURIComponent(n),a=B.parseHash(e),o=B.hashlessUrl(e);if(-1===o.indexOf("?"))return o+"?"+r+a;var s=o.split("?"),c=s[0]+"?",u=s[1];return c+B.addQueryParamAtLocation(u,r,i)+a},I._extractParamFromUri=function(e,t){var n=new RegExp("[\\?&#]"+t+"=([^&#]*)"),i=n.exec(e);if(i&&i.length)return decodeURIComponent(i[1])},I._parseAdobeMcFromUrl=a(ae.ADOBE_MC),I._parseAdobeMcSdidFromUrl=a(ae.ADOBE_MC_SDID),I._attemptToPopulateSdidFromUrl=function(e){var n=I._parseAdobeMcSdidFromUrl(e),i=1e9;n&&n.TS&&(i=B.getTimestampInSeconds()-n.TS),n&&n.SDID&&n.MCORGID===t&&i<I.sdidParamExpiry&&(I._supplementalDataIDCurrent=n.SDID,I._supplementalDataIDCurrentConsumed.SDID_URL_PARAM=!0)},I._attemptToPopulateIdsFromUrl=function(){var e=I._parseAdobeMcFromUrl();if(e&&e.TS){var n=B.getTimestampInSeconds(),i=n-e.TS;if(Math.floor(i/60)>ae.ADOBE_MC_TTL_IN_MIN||e.MCORGID!==t)return;o(e)}},I._mergeServerState=function(e){if(e)try{if(e=function(e){return B.isObject(e)?e:JSON.parse(e)}(e),e[I.marketingCloudOrgID]){var t=e[I.marketingCloudOrgID];!function(e){B.isObject(e)&&I.setCustomerIDs(e)}(t.customerIDs),s(t.sdid)}}catch(e){throw new Error("`serverState` has an invalid format.")}},I._timeout=null,I._loadData=function(e,t,n,i){t=I._addQuerystringParam(t,"d_fieldgroup",e,1),i.url=I._addQuerystringParam(i.url,"d_fieldgroup",e,1),i.corsUrl=I._addQuerystringParam(i.corsUrl,"d_fieldgroup",e,1),q.fieldGroupObj[e]=!0,i===Object(i)&&i.corsUrl&&"XMLHttpRequest"===j.corsMetadata.corsType&&j.fireCORS(i,n,e)},I._clearTimeout=function(e){null!=I._timeout&&I._timeout[e]&&(clearTimeout(I._timeout[e]),I._timeout[e]=0)},I._settingsDigest=0,I._getSettingsDigest=function(){if(!I._settingsDigest){var e=I.version;I.audienceManagerServer&&(e+="|"+I.audienceManagerServer),I.audienceManagerServerSecure&&(e+="|"+I.audienceManagerServerSecure),I._settingsDigest=I._hash(e)}return I._settingsDigest},I._readVisitorDone=!1,I._readVisitor=function(){if(!I._readVisitorDone){I._readVisitorDone=!0;var e,t,n,i,r,a,o=I._getSettingsDigest(),s=!1,c=I.cookieRead(I.cookieName),u=new Date;if(c||A||I.discardTrackingServerECID||(c=I.cookieRead(ae.FIRST_PARTY_SERVER_COOKIE)),null==I._fields&&(I._fields={}),c&&"T"!==c)for(c=c.split("|"),c[0].match(/^[\-0-9]+$/)&&(parseInt(c[0],10)!==o&&(s=!0),c.shift()),c.length%2==1&&c.pop(),e=0;e<c.length;e+=2)t=c[e].split("-"),n=t[0],i=c[e+1],t.length>1?(r=parseInt(t[1],10),a=t[1].indexOf("s")>0):(r=0,a=!1),s&&("MCCIDH"===n&&(i=""),r>0&&(r=u.getTime()/1e3-60)),n&&i&&(I._setField(n,i,1),r>0&&(I._fields["expire"+n]=r+(a?"s":""),(u.getTime()>=1e3*r||a&&!I.cookieRead(I.sessionCookieName))&&(I._fieldsExpired||(I._fieldsExpired={}),I._fieldsExpired[n]=!0)));!I._getField(R)&&B.isTrackingServerPopulated()&&(c=I.cookieRead("s_vi"))&&(c=c.split("|"),c.length>1&&c[0].indexOf("v1")>=0&&(i=c[1],e=i.indexOf("["),e>=0&&(i=i.substring(0,e)),i&&i.match(ae.VALID_VISITOR_ID_REGEX)&&I._setField(R,i)))}},I._appendVersionTo=function(e){var t="vVersion|"+I.version,n=e?I._getCookieVersion(e):null;return n?ee.areVersionsDifferent(n,I.version)&&(e=e.replace(ae.VERSION_REGEX,t)):e+=(e?"|":"")+t,e},I._writeVisitor=function(){var e,t,n=I._getSettingsDigest();for(e in I._fields)x(e)&&I._fields[e]&&"expire"!==e.substring(0,6)&&(t=I._fields[e],n+=(n?"|":"")+e+(I._fields["expire"+e]?"-"+I._fields["expire"+e]:"")+"|"+t);n=I._appendVersionTo(n),I.cookieWrite(I.cookieName,n,1)},I._getField=function(e,t){return null==I._fields||!t&&I._fieldsExpired&&I._fieldsExpired[e]?null:I._fields[e]},I._setField=function(e,t,n){null==I._fields&&(I._fields={}),I._fields[e]=t,n||I._writeVisitor()},I._getFieldList=function(e,t){var n=I._getField(e,t);return n?n.split("*"):null},I._setFieldList=function(e,t,n){I._setField(e,t?t.join("*"):"",n)},I._getFieldMap=function(e,t){var n=I._getFieldList(e,t);if(n){var i,r={};for(i=0;i<n.length;i+=2)r[n[i]]=n[i+1];return r}return null},I._setFieldMap=function(e,t,n){var i,r=null;if(t){r=[];for(i in t)x(i)&&(r.push(i),r.push(t[i]))}I._setFieldList(e,r,n)},I._setFieldExpire=function(e,t,n){var i=new Date;i.setTime(i.getTime()+1e3*t),null==I._fields&&(I._fields={}),I._fields["expire"+e]=Math.floor(i.getTime()/1e3)+(n?"s":""),t<0?(I._fieldsExpired||(I._fieldsExpired={}),I._fieldsExpired[e]=!0):I._fieldsExpired&&(I._fieldsExpired[e]=!1),n&&(I.cookieRead(I.sessionCookieName)||I.cookieWrite(I.sessionCookieName,"1"))},I._findVisitorID=function(t){return t&&("object"===e(t)&&(t=t.d_mid?t.d_mid:t.visitorID?t.visitorID:t.id?t.id:t.uuid?t.uuid:""+t),t&&"NOTARGET"===(t=t.toUpperCase())&&(t=N),t&&(t===N||t.match(ae.VALID_VISITOR_ID_REGEX))||(t="")),t},I._setFields=function(t,n){if(I._clearTimeout(t),null!=I._loading&&(I._loading[t]=!1),q.fieldGroupObj[t]&&q.setState(t,!1),t===k){!0!==q.isClientSideMarketingCloudVisitorID&&(q.isClientSideMarketingCloudVisitorID=!1);var i=I._getField(E);if(!i||I.overwriteCrossDomainMCIDAndAID){if(!(i="object"===e(n)&&n.mid?n.mid:I._findVisitorID(n))){if(I._use1stPartyMarketingCloudServer&&!I.tried1stPartyMarketingCloudServer)return I.tried1stPartyMarketingCloudServer=!0,void I.getAnalyticsVisitorID(null,!1,!0);i=I._generateLocalMID()}I._setField(E,i)}i&&i!==N||(i=""),"object"===e(n)&&((n.d_region||n.dcs_region||n.d_blob||n.blob)&&I._setFields(w,n),I._use1stPartyMarketingCloudServer&&n.mid&&I._setFields(L,{id:n.id})),I._callAllCallbacks(E,[i])}if(t===w&&"object"===e(n)){var r=604800;void 0!=n.id_sync_ttl&&n.id_sync_ttl&&(r=parseInt(n.id_sync_ttl,10));var a=Y.getRegionAndCheckIfChanged(n,r);I._callAllCallbacks("MCAAMLH",[a]);var o=I._getField(F);(n.d_blob||n.blob)&&(o=n.d_blob,o||(o=n.blob),I._setFieldExpire(F,r),I._setField(F,o)),o||(o=""),I._callAllCallbacks(F,[o]),!n.error_msg&&I._newCustomerIDsHash&&I._setField("MCCIDH",I._newCustomerIDsHash)}if(t===L){var s=I._getField(R);s&&!I.overwriteCrossDomainMCIDAndAID||(s=I._findVisitorID(n),s?s!==N&&I._setFieldExpire(F,-1):s=N,I._setField(R,s)),s&&s!==N||(s=""),I._callAllCallbacks(R,[s])}if(I.idSyncDisableSyncs||I.disableIdSyncs)Y.idCallNotProcesssed=!0;else{Y.idCallNotProcesssed=!1;var c={};c.ibs=n.ibs,c.subdomain=n.subdomain,Y.processIDCallData(c)}if(n===Object(n)){var u,l;d()&&I.isAllowed()&&(u=I._getField("MCOPTOUT"));var f=V.parseOptOut(n,u,N);u=f.optOut,l=f.d_ottl,I._setFieldExpire("MCOPTOUT",l,!0),I._setField("MCOPTOUT",u),I._callAllCallbacks("MCOPTOUT",[u])}},I._loading=null,I._getRemoteField=function(e,t,n,i,r){var a,o="",s=B.isFirstPartyAnalyticsVisitorIDCall(e),c={MCAAMLH:!0,MCAAMB:!0};if(d()&&I.isAllowed()){I._readVisitor(),o=I._getField(e,!0===c[e]);if(function(){return(!o||I._fieldsExpired&&I._fieldsExpired[e])&&(!I.disableThirdPartyCalls||s)}()){if(e===E||"MCOPTOUT"===e?a=k:"MCAAMLH"===e||e===F?a=w:e===R&&(a=L),a)return!t||null!=I._loading&&I._loading[a]||(null==I._loading&&(I._loading={}),I._loading[a]=!0,I._loadData(a,t,function(t){if(!I._getField(e)){t&&q.setState(a,!0);var n="";e===E?n=I._generateLocalMID():a===w&&(n={error_msg:"timeout"}),I._setFields(a,n)}},r)),I._registerCallback(e,n),o||(t||I._setFields(a,{id:N}),"")}else o||(e===E?(I._registerCallback(e,n),o=I._generateLocalMID(),I.setMarketingCloudVisitorID(o)):e===R?(I._registerCallback(e,n),o="",I.setAnalyticsVisitorID(o)):(o="",i=!0))}return e!==E&&e!==R||o!==N||(o="",i=!0),n&&i&&I._callCallback(n,[o]),o},I._setMarketingCloudFields=function(e){I._readVisitor(),I._setFields(k,e)},I._mapCustomerIDs=function(e){I.getAudienceManagerBlob(e,!0)},I._setAnalyticsFields=function(e){I._readVisitor(),I._setFields(L,e)},I._setAudienceManagerFields=function(e){I._readVisitor(),I._setFields(w,e)},I._getAudienceManagerURLData=function(e){var t=I.audienceManagerServer,n="",i=I._getField(E),r=I._getField(F,!0),a=I._getField(R),o=a&&a!==N?"&d_cid_ic=AVID%01"+encodeURIComponent(a):"";if(I.loadSSL&&I.audienceManagerServerSecure&&(t=I.audienceManagerServerSecure),t){var s,c,u,l=I.getCustomerIDs(!0);if(l)for(c in l){var d=l[c];if(!V.isObjectEmpty(d)){var f="nameSpaces"===c?"&d_cid_ns=":"&d_cid_ic=";for(s in d)x(s)&&(u=d[s],o+=f+encodeURIComponent(s)+"%01"+encodeURIComponent(u.id?u.id:"")+(u.authState?"%01"+u.authState:""))}}e||(e="_setAudienceManagerFields");var p="http"+(I.loadSSL?"s":"")+"://"+t+"/id",g="d_visid_ver="+I.version+(v&&-1!==p.indexOf("demdex.net")?"&gdpr=1&gdpr_consent="+v:"")+(D&&-1!==p.indexOf("demdex.net")?"&d_cf="+D:"")+"&d_rtbd=json&d_ver=2"+(!i&&I._use1stPartyMarketingCloudServer?"&d_verify=1":"")+"&d_orgid="+encodeURIComponent(I.marketingCloudOrgID)+"&d_nsid="+(I.idSyncContainerID||0)+(i?"&d_mid="+encodeURIComponent(i):"")+(I.idSyncDisable3rdPartySyncing||I.disableThirdPartyCookies?"&d_coppa=true":"")+(!0===M?"&d_coop_safe=1":!1===M?"&d_coop_unsafe=1":"")+(r?"&d_blob="+encodeURIComponent(r):"")+o;D=0;var m=["s_c_il",I._in,e];return n=p+"?"+g+"&d_cb=s_c_il%5B"+I._in+"%5D."+e,{url:n,corsUrl:p+"?"+g,callback:m}}return{url:n}},I.appendVisitorIDsTo=function(e){try{var t=[[E,I._getField(E)],[R,I._getField(R)],["MCORGID",I.marketingCloudOrgID]];return I._addQuerystringParam(e,ae.ADOBE_MC,c(t))}catch(t){return e}},I.appendSupplementalDataIDTo=function(e,t){if(!(t=t||I.getSupplementalDataID(B.generateRandomString(),!0)))return e;try{var n=c([["SDID",t],["MCORGID",I.marketingCloudOrgID]]);return I._addQuerystringParam(e,ae.ADOBE_MC_SDID,n)}catch(t){return e}};var B={parseHash:function(e){var t=e.indexOf("#");return t>0?e.substr(t):""},hashlessUrl:function(e){var t=e.indexOf("#");return t>0?e.substr(0,t):e},addQueryParamAtLocation:function(e,t,n){var i=e.split("&");return n=null!=n?n:i.length,i.splice(n,0,t),i.join("&")},isFirstPartyAnalyticsVisitorIDCall:function(e,t,n){if(e!==R)return!1;var i;return t||(t=I.trackingServer),n||(n=I.trackingServerSecure),!("string"!=typeof(i=I.loadSSL?n:t)||!i.length)&&(i.indexOf("2o7.net")<0&&i.indexOf("omtrdc.net")<0)},isObject:function(e){return Boolean(e&&e===Object(e))},removeCookie:function(e){$.remove(e,{domain:I.cookieDomain})},isTrackingServerPopulated:function(){return!!I.trackingServer||!!I.trackingServerSecure},getTimestampInSeconds:function(){return Math.round((new Date).getTime()/1e3)},parsePipeDelimetedKeyValues:function(e){return e.split("|").reduce(function(e,t){var n=t.split("=");return e[n[0]]=decodeURIComponent(n[1]),e},{})},generateRandomString:function(e){e=e||5;for(var t="",n="abcdefghijklmnopqrstuvwxyz0123456789";e--;)t+=n[Math.floor(Math.random()*n.length)];return t},normalizeBoolean:function(e){return"true"===e||"false"!==e&&e},parseBoolean:function(e){return"true"===e||"false"!==e&&null},replaceMethodsWithFunction:function(e,t){for(var n in e)e.hasOwnProperty(n)&&"function"==typeof e[n]&&(e[n]=t);return e}};I._helpers=B;var Y=oe(I,O);I._destinationPublishing=Y,I.timeoutMetricsLog=[];var q={isClientSideMarketingCloudVisitorID:null,MCIDCallTimedOut:null,AnalyticsIDCallTimedOut:null,AAMIDCallTimedOut:null,fieldGroupObj:{},setState:function(e,t){switch(e){case k:!1===t?!0!==this.MCIDCallTimedOut&&(this.MCIDCallTimedOut=!1):this.MCIDCallTimedOut=t;break;case L:!1===t?!0!==this.AnalyticsIDCallTimedOut&&(this.AnalyticsIDCallTimedOut=!1):this.AnalyticsIDCallTimedOut=t;break;case w:!1===t?!0!==this.AAMIDCallTimedOut&&(this.AAMIDCallTimedOut=!1):this.AAMIDCallTimedOut=t}}};I.isClientSideMarketingCloudVisitorID=function(){return q.isClientSideMarketingCloudVisitorID},I.MCIDCallTimedOut=function(){return q.MCIDCallTimedOut},I.AnalyticsIDCallTimedOut=function(){return q.AnalyticsIDCallTimedOut},I.AAMIDCallTimedOut=function(){return q.AAMIDCallTimedOut},I.idSyncGetOnPageSyncInfo=function(){return I._readVisitor(),I._getField("MCSYNCSOP")},I.idSyncByURL=function(e){if(!I.isOptedOut()){var t=u(e||{});if(t.error)return t.error;var n,i,r=e.url,a=encodeURIComponent,o=Y;return r=r.replace(/^https:/,"").replace(/^http:/,""),n=V.encodeAndBuildRequest(["",e.dpid,e.dpuuid||""],","),i=["ibs",a(e.dpid),"img",a(r),t.ttl,"",n],o.addMessage(i.join("|")),o.requestToProcess(),"Successfully queued"}},I.idSyncByDataSource=function(e){if(!I.isOptedOut())return e===Object(e)&&"string"==typeof e.dpuuid&&e.dpuuid.length?(e.url="//dpm.demdex.net/ibs:dpid="+e.dpid+"&dpuuid="+e.dpuuid,I.idSyncByURL(e)):"Error: config or config.dpuuid is empty"},Ge(I,Y),I._getCookieVersion=function(e){e=e||I.cookieRead(I.cookieName);var t=ae.VERSION_REGEX.exec(e);return t&&t.length>1?t[1]:null},I._resetAmcvCookie=function(e){var t=I._getCookieVersion();t&&!ee.isLessThan(t,e)||B.removeCookie(I.cookieName)},I.setAsCoopSafe=function(){M=!0},I.setAsCoopUnsafe=function(){M=!1},function(){if(I.configs=Object.create(null),B.isObject(n))for(var e in n)x(e)&&(I[e]=n[e],I.configs[e]=n[e])}(),f();var W;I.init=function(){l()&&(S.optIn.fetchPermissions(h,!0),!S.optIn.isApproved(S.optIn.Categories.ECID))||W||(W=!0,function(){if(B.isObject(n)){I.idSyncContainerID=I.idSyncContainerID||0,M="boolean"==typeof I.isCoopSafe?I.isCoopSafe:B.parseBoolean(I.isCoopSafe),I.resetBeforeVersion&&I._resetAmcvCookie(I.resetBeforeVersion),I._attemptToPopulateIdsFromUrl(),I._attemptToPopulateSdidFromUrl(),I._readVisitor();var e=I._getField(P),t=Math.ceil((new Date).getTime()/ae.MILLIS_PER_DAY);I.idSyncDisableSyncs||I.disableIdSyncs||!Y.canMakeSyncIDCall(e,t)||(I._setFieldExpire(F,-1),I._setField(P,t)),I.getMarketingCloudVisitorID(),I.getAudienceManagerLocationHint(),I.getAudienceManagerBlob(),I._mergeServerState(I.serverState)}else I._attemptToPopulateIdsFromUrl(),I._attemptToPopulateSdidFromUrl()}(),function(){if(!I.idSyncDisableSyncs&&!I.disableIdSyncs){Y.checkDPIframeSrc();var e=function(){var e=Y;e.readyToAttachIframe()&&e.attachIframe()};b.addEventListener("load",function(){O.windowLoaded=!0,e()});try{ne.receiveMessage(function(e){Y.receiveMessage(e.data)},Y.iframeHost)}catch(e){}}}(),function(){I.whitelistIframeDomains&&ae.POST_MESSAGE_ENABLED&&(I.whitelistIframeDomains=I.whitelistIframeDomains instanceof Array?I.whitelistIframeDomains:[I.whitelistIframeDomains],I.whitelistIframeDomains.forEach(function(e){var n=new G(t,e),i=z(I,n);ne.receiveMessage(i,e)}))}())}};Ke.config=ce,C.Visitor=Ke;var Je=Ke,ze=function(e){if(V.isObject(e))return Object.keys(e).filter(function(t){return""!==e[t]}).reduce(function(t,n){var i=ce.normalizeConfig(e[n]),r=V.normalizeBoolean(i);return t[n]=r,t},Object.create(null))},Qe=Be.OptIn,$e=Be.IabPlugin;return Je.getInstance=function(e,t){if(!e)throw new Error("Visitor requires Adobe Marketing Cloud Org ID.");e.indexOf("@")<0&&(e+="@AdobeOrg");var n=function(){var t=C.s_c_il;if(t)for(var n=0;n<t.length;n++){var i=t[n];if(i&&"Visitor"===i._c&&i.marketingCloudOrgID===e)return i}}();if(n)return n;var i=ze(t);!function(e){C.adobe.optIn=C.adobe.optIn||function(){var t=V.pluck(e,["doesOptInApply","previousPermissions","preOptInApprovals","isOptInStorageEnabled","optInStorageExpiry","isIabContext"]),n=e.optInCookieDomain||e.cookieDomain;n=n||Z(),n=n===window.location.hostname?"":n,t.optInCookieDomain=n;var i=new Qe(t,{cookies:$});if(t.isIabContext&&t.doesOptInApply){var r=new $e;i.registerPlugin(r)}return i}()}(i||{});var r=e,a=r.split("").reverse().join(""),o=new Je(e,null,a);V.isObject(i)&&i.cookieDomain&&(o.cookieDomain=i.cookieDomain),function(){C.s_c_il.splice(--C.s_c_in,1)}();var s=V.getIeVersion();if("number"==typeof s&&s<10)return o._helpers.replaceMethodsWithFunction(o,function(){});var c=function(){try{return C.self!==C.parent}catch(e){return!0}}()&&!function(e){return e.cookieWrite("TEST_AMCV_COOKIE","T",1),"T"===e.cookieRead("TEST_AMCV_COOKIE")&&(e._helpers.removeCookie("TEST_AMCV_COOKIE"),!0)}(o)&&C.parent?new q(e,i,o,C.parent):new Je(e,i,a);return o=null,c.init(),c},function(){function e(){Je.windowLoaded=!0}C.addEventListener?C.addEventListener("load",e):C.attachEvent&&C.attachEvent("onload",e),Je.codeLoadEnd=(new Date).getTime()}(),Je}();
  return Visitor;
}();

          }

        },
        "adobe-mcid/src/view/utils/timeUnits.js": {
          "script": function(module, exports, require, turbine) {
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2018 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by all applicable intellectual property
* laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

var timeUnits = {
  Hours: 3600,
  Days: 24 * 3600,
  Weeks: 7 * 24 * 3600,
  Months: 30 * 24 * 3600,
  Years: 365 * 24 * 3600
};

module.exports = timeUnits;

          }

        }
      }
    },
    "simple-custom-code-action": {
      "displayName": "Simple Custom Code Action",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EP86e6334f2499473c8a9195688326c2df/",
      "modules": {
        "simple-custom-code-action/src/lib/actions/customCode.js": {
          "name": "custom-code",
          "displayName": "Custom Code",
          "script": function(module, exports, require, turbine) {
'use strict';

module.exports = function (settings) {
  var
    loadScript = require('@adobe/reactor-load-script');

  if (!settings.file) {
    return;
  }

  loadScript(settings.file)
  .then(function () {
    // TODO: notify that it has loaded or allow some additional code to fire
  }, function (e) {
    console.error(e);
  });

};

          }

        }
      }
    },
    "adobe-target-v2": {
      "displayName": "Adobe Target v2",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EPe0317ac342d64783ada9726d04d0601b/",
      "settings": {
        "targetSettings": {
          "enabled": true,
          "timeout": 10000,
          "version": "2.5.0",
          "endpoint": "/rest/v1/delivery",
          "imsOrgId": "9E1005A551ED61CA0A490D45@AdobeOrg",
          "clientCode": "adobe",
          "secureOnly": false,
          "serverState": {
          },
          "optinEnabled": true,
          "serverDomain": "adobe.tt.omtrdc.net",
          "urlSizeLimit": 2048,
          "viewsEnabled": true,
          "optoutEnabled": false,
          "globalMboxName": "adobe-global-mbox",
          "bodyHiddenStyle": "body {opacity: 0}",
          "pageLoadEnabled": true,
          "analyticsLogging": "server_side",
          "deviceIdLifetime": 63244800000,
          "bodyHidingEnabled": true,
          "decisioningMethod": "server-side",
          "sessionIdLifetime": 1860000,
          "visitorApiTimeout": 2000,
          "authoringScriptUrl": "//cdn.tt.omtrdc.net/cdn/target-vec.js",
          "overrideMboxEdgeServer": false,
          "selectorsPollingTimeout": 5000,
          "defaultContentHiddenStyle": "visibility: hidden;",
          "defaultContentVisibleStyle": "visibility: visible;",
          "overrideMboxEdgeServerTimeout": 1860000,
          "supplementalDataIdParamTimeout": 30
        }
      },
      "modules": {
        "adobe-target-v2/lib/loadTarget.js": {
          "name": "load-target",
          "displayName": "Load Target",
          "script": function(module, exports, require, turbine) {
"use strict";

/* eslint-disable import/no-extraneous-dependencies */
var win = require("@adobe/reactor-window");
var doc = require("@adobe/reactor-document");

var _require = require("./modules/load-target"),
    initLibrarySettings = _require.initLibrarySettings,
    overridePublicApi = _require.overridePublicApi;

var _require2 = require("./modules/optin"),
    shouldUseOptIn = _require2.shouldUseOptIn,
    isTargetApproved = _require2.isTargetApproved;

var handleRequest = require("./analyticsIntegration");

module.exports = function () {
  var targetSettings = initLibrarySettings();

  if (!targetSettings || !targetSettings.enabled) {
    overridePublicApi(win);
    return;
  }

  var _require3 = require("./modules/libs/at-launch"),
      init = _require3.init; //eslint-disable-line

  init(win, doc, targetSettings);

  if (!shouldUseOptIn() || isTargetApproved()) {
    handleRequest();
  }
};
          }

        },
        "adobe-target-v2/lib/firePageLoad.js": {
          "name": "fire-page-load",
          "displayName": "Fire Page Load Request",
          "script": function(module, exports, require, turbine) {
"use strict";

/* eslint-disable import/no-extraneous-dependencies */
var win = require("@adobe/reactor-window");

var _require = require("./modules/libs/at-launch"),
    initConfig = _require.initConfig,
    initDelivery = _require.initDelivery;

var initPageLoadSettings = require("./modules/page-load");
var messages = require("./messages");

function isLibraryPresent() {
  return win.adobe && win.adobe.target && win.adobe.target.VERSION;
}

module.exports = function (settings) {
  var targetSettings = initPageLoadSettings(settings);

  if (!isLibraryPresent()) {
    if (win.console) {
      turbine.logger.warn(messages.NO_REQUEST);
    }

    return;
  }

  initConfig(targetSettings);
  initDelivery();
};
          }

        },
        "adobe-target-v2/lib/addParams.js": {
          "name": "add-params",
          "displayName": "Add Params to All Requests",
          "script": function(module, exports, require, turbine) {
"use strict";

var _require = require("./modules/params-store"),
    mergeParams = _require.mergeParams;

module.exports = function (settings) {
  mergeParams(settings.params);
};
          }

        },
        "adobe-target-v2/lib/modules/load-target.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

/* eslint-disable import/no-extraneous-dependencies */
var win = require("@adobe/reactor-window");
var doc = require("@adobe/reactor-document");
var Promise = require("@adobe/reactor-promise");
var messages = require("../messages");

var _require = require("./params-store"),
    getParams = _require.getParams,
    getPageLoadParams = _require.getPageLoadParams;

var _require2 = require("../targetSettings"),
    targetSettings = _require2.targetSettings;

var overrideProps = require("./object-override");

var _require3 = require("../librarySettings"),
    TARGET_DEFAULT_SETTINGS = _require3.TARGET_DEFAULT_SETTINGS;

var OVERRIDABLE_SETTINGS = ["enabled", "clientCode", "imsOrgId", "serverDomain", "cookieDomain", "timeout", "defaultContentHiddenStyle", "defaultContentVisibleStyle", "bodyHiddenStyle", "bodyHidingEnabled", "selectorsPollingTimeout", "visitorApiTimeout", "overrideMboxEdgeServer", "overrideMboxEdgeServerTimeout", "optoutEnabled", "optinEnabled", "secureOnly", "supplementalDataIdParamTimeout", "authoringScriptUrl", "urlSizeLimit", "endpoint", "pageLoadEnabled", "viewsEnabled", "analyticsLogging", "serverState", "globalMboxName", "decisioningMethod"];

function isStandardMode(document) {
  var compatMode = document.compatMode,
      documentMode = document.documentMode;

  var standardMode = compatMode && compatMode === "CSS1Compat";
  var ie9OrModernBrowser = documentMode ? documentMode >= 9 : true;

  return standardMode && ie9OrModernBrowser;
}

function overridePublicApi(window) {
  /* eslint-disable no-param-reassign */
  var noop = function noop() {};
  var noopPromise = function noopPromise() {
    return Promise.resolve();
  };
  window.adobe = window.adobe || {};
  window.adobe.target = {
    VERSION: "",
    event: {},
    getOffer: noop,
    getOffers: noopPromise,
    applyOffer: noop,
    applyOffers: noopPromise,
    sendNotifications: noop,
    trackEvent: noop,
    triggerView: noop,
    registerExtension: noop,
    init: noop
  };
  window.mboxCreate = noop;
  window.mboxDefine = noop;
  window.mboxUpdate = noop;
  /* eslint-disable no-param-reassign */
}

function isLibraryPresent() {
  return win.adobe && win.adobe.target && typeof win.adobe.target.getOffer !== "undefined";
}

function initLibrarySettings() {
  if (isLibraryPresent()) {
    turbine.logger.warn(messages.ALREADY_INITIALIZED);
    return null;
  }

  targetSettings.mboxParams = getParams();
  targetSettings.globalMboxParams = getPageLoadParams();

  overrideProps(targetSettings, win.targetGlobalSettings || {}, OVERRIDABLE_SETTINGS);
  overrideProps(targetSettings, TARGET_DEFAULT_SETTINGS || {}, ["version"]);

  if (!isStandardMode(doc)) {
    targetSettings.enabled = false;

    turbine.logger.warn(messages.DELIVERY_DISABLED);
  }

  return targetSettings;
}

module.exports = {
  initLibrarySettings: initLibrarySettings,
  overridePublicApi: overridePublicApi
};
          }

        },
        "adobe-target-v2/lib/modules/optin.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint-disable import/no-extraneous-dependencies */
var win = require("@adobe/reactor-window");

var ADOBE = win.adobe;
var IS_APPROVED = "isApproved";
var OPTIN_ENABLED = "optinEnabled";
var OPT_IN = "optIn";
var FETCH_PERMISSIONS = "fetchPermissions";
var CATEGORIES = "Categories";
var TARGET = "TARGET";

var _require = require("../targetSettings"),
    targetSettings = _require.targetSettings;

function isNil(value) {
  var type = typeof value === "undefined" ? "undefined" : _typeof(value);
  return type === "undefined" || value === null;
}
function isFunction(value) {
  var type = typeof value === "undefined" ? "undefined" : _typeof(value);
  return value !== null && (type === "object" || type === "function");
}

function isOptInAPIAvailable(optIn) {
  return isFunction(optIn[FETCH_PERMISSIONS]) && isFunction(optIn[IS_APPROVED]);
}

function optInEnabled(adobe, optedInEnabled) {
  if (!optedInEnabled) {
    return false;
  }
  if (isNil(adobe)) {
    return false;
  }
  if (isNil(adobe[OPT_IN])) {
    return false;
  }
  return isOptInAPIAvailable(adobe[OPT_IN]);
}

function isCategoryOptedIn(optInApi, category) {
  return optInApi[IS_APPROVED](category);
}

function isTargetApproved() {
  var optInApi = ADOBE[OPT_IN];
  var targetCategory = optInApi[CATEGORIES][TARGET];
  return isCategoryOptedIn(optInApi, targetCategory);
}

function shouldUseOptIn() {
  var optedInEnabled = targetSettings[OPTIN_ENABLED];
  return optInEnabled(ADOBE, optedInEnabled);
}

module.exports = {
  shouldUseOptIn: shouldUseOptIn,
  isTargetApproved: isTargetApproved
};
          }

        },
        "adobe-target-v2/lib/analyticsIntegration.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

/* eslint-disable import/no-extraneous-dependencies */
var doc = require("@adobe/reactor-document");
var Promise = require("@adobe/reactor-promise");

var _require = require("./modules/event-util"),
    addEventListener = _require.addEventListener,
    removeEventListener = _require.removeEventListener;

var _require2 = require("./targetSettings"),
    extensionSettings = _require2.extensionSettings;

var augmentTracker = turbine.getSharedModule("adobe-analytics", "augment-tracker");
var REQUEST_SUCCEEDED = "at-request-succeeded";
var REQUEST_FAILED = "at-request-failed";

function handleTracker(tracker, promise) {
  return new Promise(function (resolve) {
    if (!tracker) {
      resolve();
      return;
    }

    promise.then(function (abortPromise) {
      if (abortPromise) {
        tracker.abort = true;
      }
      resolve();
    });
  });
}

function requestHandler(func) {
  if (!func) {
    return;
  }

  var promise = new Promise(function (resolve) {
    var timerId = setTimeout(function () {
      resolve(false);
    }, extensionSettings.targetSettings.timeout);

    var requestSuccess = function requestSuccess(e) {
      if (e.detail && e.detail.redirect === true) {
        resolve(true);
      } else {
        resolve(false);
      }

      clearTimeout(timerId);
      removeEventListener(doc, e, requestSuccess);
    };
    var requestFail = function requestFail(e) {
      resolve(false);
      clearTimeout(timerId);
      removeEventListener(doc, e, requestFail);
    };

    addEventListener(doc, REQUEST_SUCCEEDED, requestSuccess);
    addEventListener(doc, REQUEST_FAILED, requestFail);
  });

  func(function (tracker) {
    return handleTracker(tracker, promise);
  });
}

module.exports = function () {
  requestHandler(augmentTracker);
};
          }

        },
        "adobe-target-v2/lib/modules/libs/at-launch.js": {
          "script": function(module, exports, require, turbine) {
/**
 * @license
 * at.js 2.5.0 | (c) Adobe Systems Incorporated | All rights reserved
 * zepto.js | (c) 2010-2016 Thomas Fuchs | zeptojs.com/license
 */
"use strict";

var define;

function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}

var assign = _interopDefault(require("@adobe/reactor-object-assign"));
var cookie = _interopDefault(require("@adobe/reactor-cookie"));
var queryString = _interopDefault(require("@adobe/reactor-query-string"));
var Promise$1 = _interopDefault(require("@adobe/reactor-promise"));
var loadScript = _interopDefault(require("@adobe/reactor-load-script"));

function isNil(value) {
  return value == null;
}

var isArray = Array.isArray;

var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
function baseGetTag(value) {
  return objectToString(value);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function(obj) {
      return obj &&
        typeof Symbol === "function" &&
        obj.constructor === Symbol &&
        obj !== Symbol.prototype
        ? "symbol"
        : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function isObject(value) {
  var type = _typeof(value);
  var notNull = value != null;
  return notNull && (type === "object" || type === "function");
}

var funcTag = "[object Function]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  return baseGetTag(value) === funcTag;
}

function identity(value) {
  return value;
}

function castFunction(value) {
  return isFunction(value) ? value : identity;
}

function keys(object) {
  if (isNil(object)) {
    return [];
  }
  return Object.keys(object);
}

var arrayEach = function arrayEach(iteratee, collection) {
  return collection.forEach(iteratee);
};

var baseEach = function baseEach(iteratee, collection) {
  arrayEach(function(key) {
    return iteratee(collection[key], key);
  }, keys(collection));
};

var arrayFilter = function arrayFilter(predicate, collection) {
  return collection.filter(predicate);
};
var baseFilter = function baseFilter(predicate, collection) {
  var result = {};
  baseEach(function(value, key) {
    if (predicate(value, key)) {
      result[key] = value;
    }
  }, collection);
  return result;
};
function filter(predicate, collection) {
  if (isNil(collection)) {
    return [];
  }
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(castFunction(predicate), collection);
}

function first(array) {
  return array && array.length ? array[0] : undefined;
}

function flatten(array) {
  if (isNil(array)) {
    return [];
  }
  return [].concat.apply([], array);
}

function flow(funcs) {
  var _this = this;
  var length = funcs ? funcs.length : 0;
  var index = length;
  while ((index -= 1)) {
    if (!isFunction(funcs[index])) {
      throw new TypeError("Expected a function");
    }
  }
  return function() {
    var i = 0;
    for (
      var _len = arguments.length, args = new Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      args[_key] = arguments[_key];
    }
    var result = length ? funcs[i].apply(_this, args) : args[0];
    while ((i += 1) < length) {
      result = funcs[i].call(_this, result);
    }
    return result;
  };
}

function forEach(iteratee, collection) {
  if (isNil(collection)) {
    return;
  }
  var func = isArray(collection) ? arrayEach : baseEach;
  func(castFunction(iteratee), collection);
}

function isObjectLike(value) {
  var notNull = value != null;
  return notNull && _typeof(value) === "object";
}

var stringTag = "[object String]";
function isString(value) {
  return (
    typeof value === "string" ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) === stringTag)
  );
}

function hash(string) {
  if (!isString(string)) {
    return -1;
  }
  var result = 0;
  var length = string.length;
  for (var i = 0; i < length; i += 1) {
    result = ((result << 5) - result + string.charCodeAt(i)) & 0xffffffff;
  }
  return result;
}

var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return (
    typeof value === "number" &&
    value > -1 &&
    value % 1 === 0 &&
    value <= MAX_SAFE_INTEGER
  );
}

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

var arrayMap = function arrayMap(iteratee, collection) {
  return collection.map(iteratee);
};

function baseValues(props, object) {
  return arrayMap(function(key) {
    return object[key];
  }, props);
}
function copyArray(source) {
  var index = 0;
  var length = source.length;
  var array = Array(length);
  while (index < length) {
    array[index] = source[index];
    index += 1;
  }
  return array;
}
function stringToArray(str) {
  return str.split("");
}
function toArray(value) {
  if (isNil(value)) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  return baseValues(keys(value), value);
}

var objectProto$1 = Object.prototype;
var hasOwnProperty = objectProto$1.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (
    isArrayLike(value) &&
    (isArray(value) || isString(value) || isFunction(value.splice))
  ) {
    return !value.length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

var stringProto = String.prototype;
var nativeStringTrim = stringProto.trim;
function trim(string) {
  return isNil(string) ? "" : nativeStringTrim.call(string);
}

function isBlank(value) {
  return isString(value) ? !trim(value) : isEmpty(value);
}

var isNotBlank = function isNotBlank(value) {
  return !isBlank(value);
};

var numberTag = "[object Number]";
function isNumber(value) {
  return (
    typeof value === "number" ||
    (isObjectLike(value) && baseGetTag(value) === numberTag)
  );
}

var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function getPrototype(value) {
  return Object.getPrototypeOf(Object(value));
}
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$1.call(proto, "constructor") && proto.constructor;
  return (
    typeof Ctor === "function" &&
    Ctor instanceof Ctor &&
    funcToString.call(Ctor) === objectCtorString
  );
}

function join(joiner, collection) {
  if (!isArray(collection)) {
    return "";
  }
  return collection.join(joiner || "");
}

var baseMap = function baseMap(iteratee, collection) {
  var result = {};
  baseEach(function(value, key) {
    result[key] = iteratee(value, key);
  }, collection);
  return result;
};
function map(iteratee, collection) {
  if (isNil(collection)) {
    return [];
  }
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(castFunction(iteratee), collection);
}

function now() {
  return new Date().getTime();
}

var arrayReduce = function arrayReduce(iteratee, accumulator, collection) {
  return collection.reduce(iteratee, accumulator);
};
var baseReduce = function baseReduce(iteratee, accumulator, collection) {
  var localAcc = accumulator;
  baseEach(function(value, key) {
    localAcc = iteratee(localAcc, value, key);
  }, collection);
  return localAcc;
};
function reduce(iteratee, accumulator, collection) {
  if (isNil(collection)) {
    return accumulator;
  }
  var func = isArray(collection) ? arrayReduce : baseReduce;
  return func(castFunction(iteratee), accumulator, collection);
}

var arrayProto = Array.prototype;
var nativeReverse = arrayProto.reverse;
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}

function split(separator, string) {
  if (isBlank(string)) {
    return [];
  }
  return string.split(separator || "");
}

function random(lower, upper) {
  return lower + Math.floor(Math.random() * (upper - lower + 1));
}
function uuid() {
  var d = now();
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = (d + random(0, 16)) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
  });
}

function delay(func) {
  var wait =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return setTimeout(func, Number(wait) || 0);
}
function cancelDelay(id) {
  clearTimeout(id);
}

var DECISIONING_METHOD = {
  ON_DEVICE: "on-device",
  SERVER_SIDE: "server-side",
  HYBRID: "hybrid"
};

var noop = function noop() {
  return undefined;
};
var noopPromise = function noopPromise(value) {
  return Promise.resolve(value);
};

var commonjsGlobal =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {};

function createCommonjsModule(fn, module) {
  return (module = { exports: {} }), fn(module, module.exports), module.exports;
}

var performanceNow = createCommonjsModule(function(module) {
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (
      typeof performance !== "undefined" &&
      performance !== null &&
      performance.now
    ) {
      module.exports = function() {
        return performance.now();
      };
    } else if (
      typeof process !== "undefined" &&
      process !== null &&
      process.hrtime
    ) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function getNanoSeconds() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }.call(commonjsGlobal));
});

function parseURI(str, opts) {
  if (!str) return undefined;
  opts = opts || {};
  var o = {
    key: [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  var m = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
  var uri = {};
  var i = 14;
  while (i--) {
    uri[o.key[i]] = m[i] || "";
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2;
  });
  return uri;
}
var parseUri = parseURI;

var TYPE = "type";
var CONTENT = "content";
var HEIGHT = "height";
var WIDTH = "width";
var LEFT = "left";
var TOP = "top";
var FROM = "from";
var TO = "to";
var PRIORITY = "priority";
var SELECTOR = "selector";
var CSS_SELECTOR = "cssSelector";
var SET_HTML = "setHtml";
var SET_CONTENT = "setContent";
var SET_TEXT = "setText";
var SET_JSON = "setJson";
var SET_ATTRIBUTE = "setAttribute";
var SET_IMAGE_SOURCE = "setImageSource";
var SET_STYLE = "setStyle";
var REARRANGE = "rearrange";
var RESIZE = "resize";
var MOVE = "move";
var REMOVE = "remove";
var CUSTOM_CODE = "customCode";
var REDIRECT = "redirect";
var TRACK_CLICK = "trackClick";
var SIGNAL_CLICK = "signalClick";
var INSERT_BEFORE = "insertBefore";
var INSERT_AFTER = "insertAfter";
var APPEND_HTML = "appendHtml";
var APPEND_CONTENT = "appendContent";
var PREPEND_HTML = "prependHtml";
var PREPEND_CONTENT = "prependContent";
var REPLACE_HTML = "replaceHtml";
var REPLACE_CONTENT = "replaceContent";
var DEBUG = "mboxDebug";
var DISABLE = "mboxDisable";
var AUTHORING = "mboxEdit";
var CHECK = "at_check";
var TRUE = "true";
var MBOX_LENGTH = 250;
var DATA_SRC = "data-at-src";
var JSON$1 = "json";
var HTML = "html";
var DYNAMIC = "dynamic";
var SCRIPT = "script";
var SRC = "src";
var ID = "id";
var CLASS = "class";
var CLICK = "click";
var HEAD_TAG = "head";
var SCRIPT_TAG = "script";
var STYLE_TAG = "style";
var LINK_TAG = "link";
var IMAGE_TAG = "img";
var DIV_TAG = "div";
var DELIVERY_DISABLED =
  'Adobe Target content delivery is disabled. Ensure that you can save cookies to your current domain, there is no "mboxDisable" cookie and there is no "mboxDisable" parameter in query string.';
var ALREADY_INITIALIZED = "Adobe Target has already been initialized.";
var OPTIONS_REQUIRED = "options argument is required";
var REQUEST_REQUIRED = "request option is required";
var RESPONE_REQUIRED = "response option is required";
var EXECUTE_OR_PREFETCH_REQUIRED = "execute or prefetch is required";
var EXECUTE_OR_PREFETCH_NOT_ALLOWED = "execute or prefetch is not allowed";
var NOTIFICATIONS_REQUIRED = "notifications are required";
var MBOX_REQUIRED = "mbox option is required";
var MBOX_TOO_LONG = "mbox option is too long";
var SUCCESS_REQUIRED = "success option is required";
var ERROR_REQUIRED = "error option is required";
var OFFER_REQUIRED = "offer option is required";
var UNEXPECTED_ERROR = "Unexpected error";
var REQUEST_FAILED = "request failed";
var REQUEST_SUCCEEDED = "request succeeded";
var ACTION_RENDERED = "Action rendered successfully";
var ACTION_RENDERING = "Rendering action";
var EMPTY_CONTENT = "Action has no content";
var EMPTY_ATTRIBUTE = "Action has no attributes";
var EMPTY_PROPERTY = "Action has no CSS properties";
var EMPTY_SIZES = "Action has no height or width";
var EMPTY_COORDINATES = "Action has no left, top or position";
var EMPTY_REARRANGE = "Action has no from or to";
var EMPTY_URL = "Action has no url";
var EMPTY_IMAGE_URL = "Action has no image url";
var REARRANGE_MISSING = "Rearrange elements are missing";
var LOADING_IMAGE = "Loading image";
var TRACK_EVENT_SUCCESS = "Track event request succeeded";
var TRACK_EVENT_ERROR = "Track event request failed";
var NO_ACTIONS = "No actions to be rendered";
var REDIRECT_ACTION = "Redirect action";
var REMOTE_SCRIPT = "Script load";
var ERROR = "error";
var WARNING = "warning";
var UNKNOWN = "unknown";
var VALID = "valid";
var SUCCESS = "success";
var RENDER = "render";
var METRIC = "metric";
var MBOX = "mbox";
var OFFER = "offer";
var NAME = "name";
var STATUS = "status";
var PARAMS = "params";
var ACTIONS = "actions";
var RESPONSE_TOKENS = "responseTokens";
var DATA = "data";
var RESPONSE = "response";
var REQUEST = "request";
var PROVIDER = "provider";
var PAGE_LOAD = "pageLoad";
var FLICKER_CONTROL_CLASS = "at-flicker-control";
var MARKER_CSS_CLASS = "at-element-marker";
var CLICK_TRACKING_CSS_CLASS = "at-element-click-tracking";
var ENABLED = "enabled";
var CLIENT_CODE = "clientCode";
var IMS_ORG_ID = "imsOrgId";
var SERVER_DOMAIN = "serverDomain";
var TIMEOUT = "timeout";
var GLOBAL_MBOX_NAME = "globalMboxName";
var GLOBAL_MBOX_AUTO_CREATE = "globalMboxAutoCreate";
var VERSION = "version";
var DEFAULT_CONTENT_HIDDEN_STYLE = "defaultContentHiddenStyle";
var DEFAULT_CONTENT_VISIBLE_STYLE = "defaultContentVisibleStyle";
var BODY_HIDDEN_STYLE = "bodyHiddenStyle";
var BODY_HIDING_ENABLED = "bodyHidingEnabled";
var DEVICE_ID_LIFETIME = "deviceIdLifetime";
var SESSION_ID_LIFETIME = "sessionIdLifetime";
var SELECTORS_POLLING_TIMEOUT = "selectorsPollingTimeout";
var VISITOR_API_TIMEOUT = "visitorApiTimeout";
var OVERRIDE_MBOX_EDGE_SERVER = "overrideMboxEdgeServer";
var OVERRIDE_MBOX_EDGE_SERVER_TIMEOUT = "overrideMboxEdgeServerTimeout";
var OPTOUT_ENABLED = "optoutEnabled";
var SECURE_ONLY = "secureOnly";
var SUPPLEMENTAL_DATA_ID_PARAM_TIMEOUT = "supplementalDataIdParamTimeout";
var AUTHORING_SCRIPT_URL = "authoringScriptUrl";
var SCHEME = "scheme";
var COOKIE_DOMAIN = "cookieDomain";
var MBOX_PARAMS = "mboxParams";
var GLOBAL_MBOX_PARAMS = "globalMboxParams";
var URL_SIZE_LIMIT = "urlSizeLimit";
var SESSION_ID_PARAM = "mboxSession";
var DEVICE_ID_COOKIE = "PC";
var EDGE_CLUSTER_COOKIE = "mboxEdgeCluster";
var SESSION_ID_COOKIE = "session";
var TRACES_SUFFIX = "Traces";
var SETTINGS = "settings";
var CLIENT_TRACES = "client" + TRACES_SUFFIX;
var SERVER_TRACES = "server" + TRACES_SUFFIX;
var TRACES = "___target_traces";
var GLOBAL_SETTINGS = "targetGlobalSettings";
var DATA_PROVIDER = "dataProvider";
var DATA_PROVIDERS = DATA_PROVIDER + "s";
var ENDPOINT = "endpoint";
var VIEWS_ENABLED = "viewsEnabled";
var PAGE_LOAD_ENABLED = "pageLoadEnabled";
var AUTH_STATE = "authState";
var AUTHENTICATED_STATE = "authenticatedState";
var INTEGRATION_CODE = "integrationCode";
var PRIMARY = "primary";
var PAGE = "page";
var VIEW = "view";
var VIEWS = "views";
var OPTIONS = "options";
var METRICS = "metrics";
var VIEW_NAME = "viewName";
var DISPLAY_EVENT = "display";
var CONTENT_TYPE = "Content-Type";
var TEXT_PLAIN = "text/plain";
var RENDERING_VIEW_FAILED = "View rendering failed";
var VIEW_DELIVERY_ERROR = "View delivery error";
var VIEW_NAME_ERROR = "View name should be a non-empty string";
var PAGE_LOAD_DISABLED = "Page load disabled";
var USING_SERVER_STATE = "Using server state";
var ADOBE = "adobe";
var OPTIN = "optIn";
var IS_APPROVED = "isApproved";
var FETCH_PERMISSIONS = "fetchPermissions";
var CATEGORIES = "Categories";
var TARGET = "TARGET";
var ANALYTICS = "ANALYTICS";
var OPTIN_ENABLED = "optinEnabled";
var ERROR_TARGET_NOT_OPTED_IN = "Adobe Target is not opted in";
var ANALYTICS_LOGGING = "analyticsLogging";
var SERVER_STATE = "serverState";
var CSP_SCRIPT_NONCE = "cspScriptNonce";
var CSP_STYLE_NONCE = "cspStyleNonce";
var CACHE_UPDATED_EVENT = "cache-updated-event";
var NO_OFFERS_EVENT = "no-offers-event";
var REDIRECT_OFFER_EVENT = "redirect-offer-event";
var DECISIONING_METHOD_SETTING = "decisioningMethod";
var POLLING_INTERVAL_SETTING = "pollingInterval";
var ARTIFACT_LOCATION_SETTING = "artifactLocation";
var ARTIFACT_FORMAT_SETTING = "artifactFormat";
var ARTIFACT_PAYLOAD_SETTING = "artifactPayload";
var TARGET_ENVIRONMENT_SETTING = "environment";
var CDN_ENVIRONMENT_SETTING = "cdnEnvironment";
var TELEMETRY_ENABLED_SETTING = "telemetryEnabled";
var CDN_BASEPATH_SETTING = "cdnBasePath";
var WEB_CHANNEL = "web";

var FILE_PROTOCOL = "file:";
var IP_V4_REGEX = /^(?!0)(?!.*\.$)((1?\d?\d|25[0-5]|2[0-4]\d)(\.|$)){4}$/;
var STANDARD_DOMAIN_REGEX = /^(com|edu|gov|net|mil|org|nom|co|name|info|biz)$/i;
var config = {};
var OVERRIDABLE_SETTINGS = [
  ENABLED,
  CLIENT_CODE,
  IMS_ORG_ID,
  SERVER_DOMAIN,
  COOKIE_DOMAIN,
  TIMEOUT,
  MBOX_PARAMS,
  GLOBAL_MBOX_PARAMS,
  DEFAULT_CONTENT_HIDDEN_STYLE,
  DEFAULT_CONTENT_VISIBLE_STYLE,
  DEVICE_ID_LIFETIME,
  BODY_HIDDEN_STYLE,
  BODY_HIDING_ENABLED,
  SELECTORS_POLLING_TIMEOUT,
  VISITOR_API_TIMEOUT,
  OVERRIDE_MBOX_EDGE_SERVER,
  OVERRIDE_MBOX_EDGE_SERVER_TIMEOUT,
  OPTOUT_ENABLED,
  OPTIN_ENABLED,
  SECURE_ONLY,
  SUPPLEMENTAL_DATA_ID_PARAM_TIMEOUT,
  AUTHORING_SCRIPT_URL,
  URL_SIZE_LIMIT,
  ENDPOINT,
  PAGE_LOAD_ENABLED,
  VIEWS_ENABLED,
  ANALYTICS_LOGGING,
  SERVER_STATE,
  DECISIONING_METHOD_SETTING,
  POLLING_INTERVAL_SETTING,
  ARTIFACT_LOCATION_SETTING,
  ARTIFACT_FORMAT_SETTING,
  ARTIFACT_PAYLOAD_SETTING,
  TARGET_ENVIRONMENT_SETTING,
  CDN_ENVIRONMENT_SETTING,
  TELEMETRY_ENABLED_SETTING,
  CDN_BASEPATH_SETTING,
  CSP_SCRIPT_NONCE,
  CSP_STYLE_NONCE,
  GLOBAL_MBOX_NAME
];
function overrideSettingsIfRequired(settings, globalSettings) {
  if (!settings[ENABLED]) {
    return;
  }
  if (!isNil(globalSettings[GLOBAL_MBOX_AUTO_CREATE])) {
    settings[PAGE_LOAD_ENABLED] = globalSettings[GLOBAL_MBOX_AUTO_CREATE];
  }
  forEach(function(field) {
    if (!isNil(globalSettings[field])) {
      settings[field] = globalSettings[field];
    }
  }, OVERRIDABLE_SETTINGS);
}
function isIE10OrModernBrowser(doc) {
  var documentMode = doc.documentMode;
  return documentMode ? documentMode >= 10 : true;
}
function isStandardMode(doc) {
  var compatMode = doc.compatMode;
  return compatMode && compatMode === "CSS1Compat";
}
function isIPv4(domain) {
  return IP_V4_REGEX.test(domain);
}
function getCookieDomain(domain) {
  if (isIPv4(domain)) {
    return domain;
  }
  var parts = reverse(split(".", domain));
  var len = parts.length;
  if (len >= 3) {
    if (STANDARD_DOMAIN_REGEX.test(parts[1])) {
      return parts[2] + "." + parts[1] + "." + parts[0];
    }
  }
  if (len === 1) {
    return parts[0];
  }
  return parts[1] + "." + parts[0];
}
function overrideFromGlobalSettings(win, doc, settings) {
  var fileProtocol = win.location.protocol === FILE_PROTOCOL;
  var cookieDomain = "";
  if (!fileProtocol) {
    cookieDomain = getCookieDomain(win.location.hostname);
  }
  settings[COOKIE_DOMAIN] = cookieDomain;
  settings[ENABLED] = isStandardMode(doc) && isIE10OrModernBrowser(doc);
  overrideSettingsIfRequired(settings, win[GLOBAL_SETTINGS] || {});
}
function initConfig(settings) {
  overrideFromGlobalSettings(window, document, settings);
  var fileProtocol = window.location.protocol === FILE_PROTOCOL;
  config = assign({}, settings);
  config[DEVICE_ID_LIFETIME] = settings[DEVICE_ID_LIFETIME] / 1000;
  config[SESSION_ID_LIFETIME] = settings[SESSION_ID_LIFETIME] / 1000;
  config[SCHEME] = config[SECURE_ONLY] || fileProtocol ? "https:" : "";
}
function getConfig() {
  return config;
}

var parse = queryString.parse,
  stringify = queryString.stringify;
var ANCHOR = document.createElement("a");
var CACHE = {};
function parseQueryString(value) {
  try {
    return parse(value);
  } catch (e) {
    return {};
  }
}
function stringifyQueryString(value) {
  try {
    return stringify(value);
  } catch (e) {
    return "";
  }
}
function decode(value) {
  try {
    return decodeURIComponent(value);
  } catch (e) {
    return value;
  }
}
function encode(value) {
  try {
    return encodeURIComponent(value);
  } catch (e) {
    return value;
  }
}
function parseUri$1(url) {
  if (CACHE[url]) {
    return CACHE[url];
  }
  ANCHOR.href = url;
  var parsedUri = parseUri(ANCHOR.href);
  parsedUri.queryKey = parseQueryString(parsedUri.query);
  CACHE[url] = parsedUri;
  return CACHE[url];
}

var getCookie = cookie.get,
  setCookie = cookie.set,
  removeCookie = cookie.remove;
var MBOX_COOKIE = "mbox";
function createCookie(name, value, expires) {
  return {
    name: name,
    value: value,
    expires: expires
  };
}
function deserialize(str) {
  var parts = split("#", str);
  if (isEmpty(parts) || parts.length < 3) {
    return null;
  }
  if (isNaN(parseInt(parts[2], 10))) {
    return null;
  }
  return createCookie(decode(parts[0]), decode(parts[1]), Number(parts[2]));
}
function getInternalCookies(cookieValue) {
  if (isBlank(cookieValue)) {
    return [];
  }
  return split("|", cookieValue);
}
function readCookies() {
  var cookies = map(deserialize, getInternalCookies(getCookie(MBOX_COOKIE)));
  var nowInSeconds = Math.ceil(now() / 1000);
  var isExpired = function isExpired(val) {
    return isObject(val) && nowInSeconds <= val.expires;
  };
  return reduce(
    function(acc, val) {
      acc[val.name] = val;
      return acc;
    },
    {},
    filter(isExpired, cookies)
  );
}

function getTargetCookie(name) {
  var cookiesMap = readCookies();
  var cookie = cookiesMap[name];
  return isObject(cookie) ? cookie.value : "";
}
function serialize(cookie) {
  return join("#", [encode(cookie.name), encode(cookie.value), cookie.expires]);
}
function getExpires(cookie) {
  return cookie.expires;
}
function getMaxExpires(cookies) {
  var expires = map(getExpires, cookies);
  return Math.max.apply(null, expires);
}
function saveCookies(cookiesMap, domain) {
  var cookies = toArray(cookiesMap);
  var maxExpires = Math.abs(getMaxExpires(cookies) * 1000 - now());
  var serializedCookies = join("|", map(serialize, cookies));
  var expires = new Date(now() + maxExpires);
  setCookie(MBOX_COOKIE, serializedCookies, {
    domain: domain,
    expires: expires
  });
}
function setTargetCookie(options) {
  var name = options.name,
    value = options.value,
    expires = options.expires,
    domain = options.domain;
  var cookiesMap = readCookies();
  cookiesMap[name] = createCookie(
    name,
    value,
    Math.ceil(expires + now() / 1000)
  );
  saveCookies(cookiesMap, domain);
}

function isCookiePresent(name) {
  return isNotBlank(getCookie(name));
}
function isParamPresent(win, name) {
  var location = win.location;
  var search = location.search;
  var params = parseQueryString(search);
  return isNotBlank(params[name]);
}
function isRefParamPresent(doc, name) {
  var referrer = doc.referrer;
  var parsedUri = parseUri$1(referrer);
  var refParams = parsedUri.queryKey;
  return isNil(refParams) ? false : isNotBlank(refParams[name]);
}
function exists(win, doc, name) {
  return (
    isCookiePresent(name) ||
    isParamPresent(win, name) ||
    isRefParamPresent(doc, name)
  );
}

function isCookieEnabled() {
  var config = getConfig();
  var cookieDomain = config[COOKIE_DOMAIN];
  setCookie(CHECK, TRUE, {
    domain: cookieDomain
  });
  var result = getCookie(CHECK) === TRUE;
  removeCookie(CHECK);
  return result;
}
function isDeliveryDisabled() {
  return exists(window, document, DISABLE);
}
function isDeliveryEnabled() {
  var config = getConfig();
  var enabled = config[ENABLED];
  return enabled && isCookieEnabled() && !isDeliveryDisabled();
}
function isDebugEnabled() {
  return exists(window, document, DEBUG);
}
function isAuthoringEnabled() {
  return exists(window, document, AUTHORING);
}

var ADOBE_TARGET_PREFIX = "AT:";
function exists$1(win, method) {
  var console = win.console;
  return !isNil(console) && isFunction(console[method]);
}
function warn(win, args) {
  var console = win.console;
  if (!exists$1(win, "warn")) {
    return;
  }
  console.warn.apply(console, [ADOBE_TARGET_PREFIX].concat(args));
}
function debug(win, args) {
  var console = win.console;
  if (!exists$1(win, "debug")) {
    return;
  }
  if (isDebugEnabled()) {
    console.debug.apply(console, [ADOBE_TARGET_PREFIX].concat(args));
  }
}

function logWarn() {
  for (
    var _len = arguments.length, args = new Array(_len), _key = 0;
    _key < _len;
    _key++
  ) {
    args[_key] = arguments[_key];
  }
  warn(window, args);
}
function logDebug() {
  for (
    var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
    _key2 < _len2;
    _key2++
  ) {
    args[_key2] = arguments[_key2];
  }
  debug(window, args);
}

var TRACES_FORMAT_VERSION = "1";
function getSettings(config) {
  return reduce(
    function(acc, key) {
      acc[key] = config[key];
      return acc;
    },
    {},
    OVERRIDABLE_SETTINGS
  );
}
function initialize(win, config, debugEnabled) {
  var result = win[TRACES] || [];
  win[TRACES] = result;
  if (!debugEnabled) {
    return;
  }
  var oldPush = result.push;
  result[VERSION] = TRACES_FORMAT_VERSION;
  result[SETTINGS] = getSettings(config);
  result[CLIENT_TRACES] = [];
  result[SERVER_TRACES] = [];
  result.push = function push(trace) {
    result[SERVER_TRACES].push(
      assign(
        {
          timestamp: now()
        },
        trace
      )
    );
    oldPush.call(this, trace);
  };
}
function saveTrace(win, namespace, trace, debugEnabled) {
  if (namespace === SERVER_TRACES) {
    win[TRACES].push(trace);
  }
  if (!debugEnabled) {
    return;
  }
  if (namespace !== SERVER_TRACES) {
    win[TRACES][namespace].push(
      assign(
        {
          timestamp: now()
        },
        trace
      )
    );
  }
}

function initTraces() {
  initialize(window, getConfig(), isDebugEnabled());
}
function addServerTrace(trace) {
  saveTrace(window, SERVER_TRACES, trace, isDebugEnabled());
}
function addClientTrace(trace) {
  saveTrace(window, CLIENT_TRACES, trace, isDebugEnabled());
}

var $ = (function(window) {
  var Zepto = (function() {
    var undefined$1,
      key,
      $,
      classList,
      emptyArray = [],
      _concat = emptyArray.concat,
      _filter = emptyArray.filter,
      _slice = emptyArray.slice,
      document = window.document,
      elementDisplay = {},
      classCache = {},
      cssNumber = {
        "column-count": 1,
        columns: 1,
        "font-weight": 1,
        "line-height": 1,
        opacity: 1,
        "z-index": 1,
        zoom: 1
      },
      fragmentRE = /^\s*<(\w+|!)[^>]*>/,
      singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rootNodeRE = /^(?:body|html)$/i,
      capitalRE = /([A-Z])/g,
      methodAttributes = [
        "val",
        "css",
        "html",
        "text",
        "data",
        "width",
        "height",
        "offset"
      ],
      adjacencyOperators = ["after", "prepend", "before", "append"],
      table = document.createElement("table"),
      tableRow = document.createElement("tr"),
      containers = {
        tr: document.createElement("tbody"),
        tbody: table,
        thead: table,
        tfoot: table,
        td: tableRow,
        th: tableRow,
        "*": document.createElement("div")
      },
      readyRE = /complete|loaded|interactive/,
      simpleSelectorRE = /^[\w-]*$/,
      class2type = {},
      toString = class2type.toString,
      zepto = {},
      camelize,
      uniq,
      tempParent = document.createElement("div"),
      propMap = {
        tabindex: "tabIndex",
        readonly: "readOnly",
        for: "htmlFor",
        class: "className",
        maxlength: "maxLength",
        cellspacing: "cellSpacing",
        cellpadding: "cellPadding",
        rowspan: "rowSpan",
        colspan: "colSpan",
        usemap: "useMap",
        frameborder: "frameBorder",
        contenteditable: "contentEditable"
      },
      isArray =
        Array.isArray ||
        function(object) {
          return object instanceof Array;
        };
    zepto.matches = function(element, selector) {
      if (!selector || !element || element.nodeType !== 1) return false;
      var matchesSelector =
        element.matches ||
        element.webkitMatchesSelector ||
        element.mozMatchesSelector ||
        element.oMatchesSelector ||
        element.matchesSelector;
      if (matchesSelector) return matchesSelector.call(element, selector);
      var match,
        parent = element.parentNode,
        temp = !parent;
      if (temp) (parent = tempParent).appendChild(element);
      match = ~zepto.qsa(parent, selector).indexOf(element);
      temp && tempParent.removeChild(element);
      return match;
    };
    function type(obj) {
      return obj == null
        ? String(obj)
        : class2type[toString.call(obj)] || "object";
    }
    function isFunction(value) {
      return type(value) == "function";
    }
    function isWindow(obj) {
      return obj != null && obj == obj.window;
    }
    function isDocument(obj) {
      return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
    }
    function isObject(obj) {
      return type(obj) == "object";
    }
    function isPlainObject(obj) {
      return (
        isObject(obj) &&
        !isWindow(obj) &&
        Object.getPrototypeOf(obj) == Object.prototype
      );
    }
    function likeArray(obj) {
      var length = !!obj && "length" in obj && obj.length,
        type = $.type(obj);
      return (
        "function" != type &&
        !isWindow(obj) &&
        ("array" == type ||
          length === 0 ||
          (typeof length == "number" && length > 0 && length - 1 in obj))
      );
    }
    function compact(array) {
      return _filter.call(array, function(item) {
        return item != null;
      });
    }
    function flatten(array) {
      return array.length > 0 ? $.fn.concat.apply([], array) : array;
    }
    camelize = function camelize(str) {
      return str.replace(/-+(.)?/g, function(match, chr) {
        return chr ? chr.toUpperCase() : "";
      });
    };
    function dasherize(str) {
      return str
        .replace(/::/g, "/")
        .replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2")
        .replace(/([a-z\d])([A-Z])/g, "$1_$2")
        .replace(/_/g, "-")
        .toLowerCase();
    }
    uniq = function uniq(array) {
      return _filter.call(array, function(item, idx) {
        return array.indexOf(item) == idx;
      });
    };
    function classRE(name) {
      return name in classCache
        ? classCache[name]
        : (classCache[name] = new RegExp("(^|\\s)" + name + "(\\s|$)"));
    }
    function maybeAddPx(name, value) {
      return typeof value == "number" && !cssNumber[dasherize(name)]
        ? value + "px"
        : value;
    }
    function defaultDisplay(nodeName) {
      var element, display;
      if (!elementDisplay[nodeName]) {
        element = document.createElement(nodeName);
        document.body.appendChild(element);
        display = getComputedStyle(element, "").getPropertyValue("display");
        element.parentNode.removeChild(element);
        display == "none" && (display = "block");
        elementDisplay[nodeName] = display;
      }
      return elementDisplay[nodeName];
    }
    function _children(element) {
      return "children" in element
        ? _slice.call(element.children)
        : $.map(element.childNodes, function(node) {
            if (node.nodeType == 1) return node;
          });
    }
    function Z(dom, selector) {
      var i,
        len = dom ? dom.length : 0;
      for (i = 0; i < len; i++) {
        this[i] = dom[i];
      }
      this.length = len;
      this.selector = selector || "";
    }
    zepto.fragment = function(html, name, properties) {
      var dom, nodes, container;
      if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));
      if (!dom) {
        if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>");
        if (name === undefined$1) name = fragmentRE.test(html) && RegExp.$1;
        if (!(name in containers)) name = "*";
        container = containers[name];
        container.innerHTML = "" + html;
        dom = $.each(_slice.call(container.childNodes), function() {
          container.removeChild(this);
        });
      }
      if (isPlainObject(properties)) {
        nodes = $(dom);
        $.each(properties, function(key, value) {
          if (methodAttributes.indexOf(key) > -1) nodes[key](value);
          else nodes.attr(key, value);
        });
      }
      return dom;
    };
    zepto.Z = function(dom, selector) {
      return new Z(dom, selector);
    };
    zepto.isZ = function(object) {
      return object instanceof zepto.Z;
    };
    zepto.init = function(selector, context) {
      var dom;
      if (!selector) return zepto.Z();
      else if (typeof selector == "string") {
        selector = selector.trim();
        if (selector[0] == "<" && fragmentRE.test(selector))
          (dom = zepto.fragment(selector, RegExp.$1, context)),
            (selector = null);
        else if (context !== undefined$1) return $(context).find(selector);
        else dom = zepto.qsa(document, selector);
      } else if (isFunction(selector)) return $(document).ready(selector);
      else if (zepto.isZ(selector)) return selector;
      else {
        if (isArray(selector)) dom = compact(selector);
        else if (isObject(selector)) (dom = [selector]), (selector = null);
        else if (fragmentRE.test(selector))
          (dom = zepto.fragment(selector.trim(), RegExp.$1, context)),
            (selector = null);
        else if (context !== undefined$1) return $(context).find(selector);
        else dom = zepto.qsa(document, selector);
      }
      return zepto.Z(dom, selector);
    };
    $ = function $(selector, context) {
      return zepto.init(selector, context);
    };
    function extend(target, source, deep) {
      for (key in source) {
        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
          if (isPlainObject(source[key]) && !isPlainObject(target[key]))
            target[key] = {};
          if (isArray(source[key]) && !isArray(target[key])) target[key] = [];
          extend(target[key], source[key], deep);
        } else if (source[key] !== undefined$1) target[key] = source[key];
      }
    }
    $.extend = function(target) {
      var deep,
        args = _slice.call(arguments, 1);
      if (typeof target == "boolean") {
        deep = target;
        target = args.shift();
      }
      args.forEach(function(arg) {
        extend(target, arg, deep);
      });
      return target;
    };
    zepto.qsa = function(element, selector) {
      var found,
        maybeID = selector[0] == "#",
        maybeClass = !maybeID && selector[0] == ".",
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,
        isSimple = simpleSelectorRE.test(nameOnly);
      return element.getElementById && isSimple && maybeID
        ? (found = element.getElementById(nameOnly))
          ? [found]
          : []
        : element.nodeType !== 1 &&
          element.nodeType !== 9 &&
          element.nodeType !== 11
        ? []
        : _slice.call(
            isSimple && !maybeID && element.getElementsByClassName
              ? maybeClass
                ? element.getElementsByClassName(nameOnly)
                : element.getElementsByTagName(selector)
              : element.querySelectorAll(selector)
          );
    };
    function filtered(nodes, selector) {
      return selector == null ? $(nodes) : $(nodes).filter(selector);
    }
    $.contains = document.documentElement.contains
      ? function(parent, node) {
          return parent !== node && parent.contains(node);
        }
      : function(parent, node) {
          while (node && (node = node.parentNode)) {
            if (node === parent) return true;
          }
          return false;
        };
    function funcArg(context, arg, idx, payload) {
      return isFunction(arg) ? arg.call(context, idx, payload) : arg;
    }
    function setAttribute(node, name, value) {
      value == null
        ? node.removeAttribute(name)
        : node.setAttribute(name, value);
    }
    function className(node, value) {
      var klass = node.className || "",
        svg = klass && klass.baseVal !== undefined$1;
      if (value === undefined$1) return svg ? klass.baseVal : klass;
      svg ? (klass.baseVal = value) : (node.className = value);
    }
    function deserializeValue(value) {
      try {
        return value
          ? value == "true" ||
              (value == "false"
                ? false
                : value == "null"
                ? null
                : +value + "" == value
                ? +value
                : /^[\[\{]/.test(value)
                ? $.parseJSON(value)
                : value)
          : value;
      } catch (e) {
        return value;
      }
    }
    $.type = type;
    $.isFunction = isFunction;
    $.isWindow = isWindow;
    $.isArray = isArray;
    $.isPlainObject = isPlainObject;
    $.isEmptyObject = function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    };
    $.isNumeric = function(val) {
      var num = Number(val),
        type = _typeof(val);
      return (
        (val != null &&
          type != "boolean" &&
          (type != "string" || val.length) &&
          !isNaN(num) &&
          isFinite(num)) ||
        false
      );
    };
    $.inArray = function(elem, array, i) {
      return emptyArray.indexOf.call(array, elem, i);
    };
    $.camelCase = camelize;
    $.trim = function(str) {
      return str == null ? "" : String.prototype.trim.call(str);
    };
    $.uuid = 0;
    $.support = {};
    $.expr = {};
    $.noop = function() {};
    $.map = function(elements, callback) {
      var value,
        values = [],
        i,
        key;
      if (likeArray(elements))
        for (i = 0; i < elements.length; i++) {
          value = callback(elements[i], i);
          if (value != null) values.push(value);
        }
      else
        for (key in elements) {
          value = callback(elements[key], key);
          if (value != null) values.push(value);
        }
      return flatten(values);
    };
    $.each = function(elements, callback) {
      var i, key;
      if (likeArray(elements)) {
        for (i = 0; i < elements.length; i++) {
          if (callback.call(elements[i], i, elements[i]) === false)
            return elements;
        }
      } else {
        for (key in elements) {
          if (callback.call(elements[key], key, elements[key]) === false)
            return elements;
        }
      }
      return elements;
    };
    $.grep = function(elements, callback) {
      return _filter.call(elements, callback);
    };
    if (window.JSON) $.parseJSON = JSON.parse;
    $.each(
      "Boolean Number String Function Array Date RegExp Object Error".split(
        " "
      ),
      function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      }
    );
    $.fn = {
      constructor: zepto.Z,
      length: 0,
      forEach: emptyArray.forEach,
      reduce: emptyArray.reduce,
      push: emptyArray.push,
      sort: emptyArray.sort,
      splice: emptyArray.splice,
      indexOf: emptyArray.indexOf,
      concat: function concat() {
        var i,
          value,
          args = [];
        for (i = 0; i < arguments.length; i++) {
          value = arguments[i];
          args[i] = zepto.isZ(value) ? value.toArray() : value;
        }
        return _concat.apply(zepto.isZ(this) ? this.toArray() : this, args);
      },
      map: function map(fn) {
        return $(
          $.map(this, function(el, i) {
            return fn.call(el, i, el);
          })
        );
      },
      slice: function slice() {
        return $(_slice.apply(this, arguments));
      },
      ready: function ready(callback) {
        if (readyRE.test(document.readyState) && document.body) callback($);
        else
          document.addEventListener(
            "DOMContentLoaded",
            function() {
              callback($);
            },
            false
          );
        return this;
      },
      get: function get(idx) {
        return idx === undefined$1
          ? _slice.call(this)
          : this[idx >= 0 ? idx : idx + this.length];
      },
      toArray: function toArray() {
        return this.get();
      },
      size: function size() {
        return this.length;
      },
      remove: function remove() {
        return this.each(function() {
          if (this.parentNode != null) this.parentNode.removeChild(this);
        });
      },
      each: function each(callback) {
        var len = this.length,
          idx = 0,
          el;
        while (idx < len) {
          el = this[idx];
          if (callback.call(el, idx, el) === false) {
            break;
          }
          idx++;
        }
        return this;
      },
      filter: function filter(selector) {
        if (isFunction(selector)) return this.not(this.not(selector));
        return $(
          _filter.call(this, function(element) {
            return zepto.matches(element, selector);
          })
        );
      },
      add: function add(selector, context) {
        return $(uniq(this.concat($(selector, context))));
      },
      is: function is(selector) {
        return this.length > 0 && zepto.matches(this[0], selector);
      },
      not: function not(selector) {
        var nodes = [];
        if (isFunction(selector) && selector.call !== undefined$1)
          this.each(function(idx) {
            if (!selector.call(this, idx)) nodes.push(this);
          });
        else {
          var excludes =
            typeof selector == "string"
              ? this.filter(selector)
              : likeArray(selector) && isFunction(selector.item)
              ? _slice.call(selector)
              : $(selector);
          this.forEach(function(el) {
            if (excludes.indexOf(el) < 0) nodes.push(el);
          });
        }
        return $(nodes);
      },
      has: function has(selector) {
        return this.filter(function() {
          return isObject(selector)
            ? $.contains(this, selector)
            : $(this)
                .find(selector)
                .size();
        });
      },
      eq: function eq(idx) {
        return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
      },
      first: function first() {
        var el = this[0];
        return el && !isObject(el) ? el : $(el);
      },
      last: function last() {
        var el = this[this.length - 1];
        return el && !isObject(el) ? el : $(el);
      },
      find: function find(selector) {
        var result,
          $this = this;
        if (!selector) result = $();
        else if (_typeof(selector) == "object")
          result = $(selector).filter(function() {
            var node = this;
            return emptyArray.some.call($this, function(parent) {
              return $.contains(parent, node);
            });
          });
        else if (this.length == 1) result = $(zepto.qsa(this[0], selector));
        else
          result = this.map(function() {
            return zepto.qsa(this, selector);
          });
        return result;
      },
      closest: function closest(selector, context) {
        var nodes = [],
          collection = _typeof(selector) == "object" && $(selector);
        this.each(function(_, node) {
          while (
            node &&
            !(collection
              ? collection.indexOf(node) >= 0
              : zepto.matches(node, selector))
          ) {
            node = node !== context && !isDocument(node) && node.parentNode;
          }
          if (node && nodes.indexOf(node) < 0) nodes.push(node);
        });
        return $(nodes);
      },
      parents: function parents(selector) {
        var ancestors = [],
          nodes = this;
        while (nodes.length > 0) {
          nodes = $.map(nodes, function(node) {
            if (
              (node = node.parentNode) &&
              !isDocument(node) &&
              ancestors.indexOf(node) < 0
            ) {
              ancestors.push(node);
              return node;
            }
          });
        }
        return filtered(ancestors, selector);
      },
      parent: function parent(selector) {
        return filtered(uniq(this.pluck("parentNode")), selector);
      },
      children: function children(selector) {
        return filtered(
          this.map(function() {
            return _children(this);
          }),
          selector
        );
      },
      contents: function contents() {
        return this.map(function() {
          return this.contentDocument || _slice.call(this.childNodes);
        });
      },
      siblings: function siblings(selector) {
        return filtered(
          this.map(function(i, el) {
            return _filter.call(_children(el.parentNode), function(child) {
              return child !== el;
            });
          }),
          selector
        );
      },
      empty: function empty() {
        return this.each(function() {
          this.innerHTML = "";
        });
      },
      pluck: function pluck(property) {
        return $.map(this, function(el) {
          return el[property];
        });
      },
      show: function show() {
        return this.each(function() {
          this.style.display == "none" && (this.style.display = "");
          if (getComputedStyle(this, "").getPropertyValue("display") == "none")
            this.style.display = defaultDisplay(this.nodeName);
        });
      },
      replaceWith: function replaceWith(newContent) {
        return this.before(newContent).remove();
      },
      wrap: function wrap(structure) {
        var func = isFunction(structure);
        if (this[0] && !func)
          var dom = $(structure).get(0),
            clone = dom.parentNode || this.length > 1;
        return this.each(function(index) {
          $(this).wrapAll(
            func
              ? structure.call(this, index)
              : clone
              ? dom.cloneNode(true)
              : dom
          );
        });
      },
      wrapAll: function wrapAll(structure) {
        if (this[0]) {
          $(this[0]).before((structure = $(structure)));
          var children;
          while ((children = structure.children()).length) {
            structure = children.first();
          }
          $(structure).append(this);
        }
        return this;
      },
      wrapInner: function wrapInner(structure) {
        var func = isFunction(structure);
        return this.each(function(index) {
          var self = $(this),
            contents = self.contents(),
            dom = func ? structure.call(this, index) : structure;
          contents.length ? contents.wrapAll(dom) : self.append(dom);
        });
      },
      unwrap: function unwrap() {
        this.parent().each(function() {
          $(this).replaceWith($(this).children());
        });
        return this;
      },
      clone: function clone() {
        return this.map(function() {
          return this.cloneNode(true);
        });
      },
      hide: function hide() {
        return this.css("display", "none");
      },
      toggle: function toggle(setting) {
        return this.each(function() {
          var el = $(this);
          (setting === undefined$1
          ? el.css("display") == "none"
          : setting)
            ? el.show()
            : el.hide();
        });
      },
      prev: function prev(selector) {
        return $(this.pluck("previousElementSibling")).filter(selector || "*");
      },
      next: function next(selector) {
        return $(this.pluck("nextElementSibling")).filter(selector || "*");
      },
      html: function html(_html) {
        return 0 in arguments
          ? this.each(function(idx) {
              var originHtml = this.innerHTML;
              $(this)
                .empty()
                .append(funcArg(this, _html, idx, originHtml));
            })
          : 0 in this
          ? this[0].innerHTML
          : null;
      },
      text: function text(_text) {
        return 0 in arguments
          ? this.each(function(idx) {
              var newText = funcArg(this, _text, idx, this.textContent);
              this.textContent = newText == null ? "" : "" + newText;
            })
          : 0 in this
          ? this.pluck("textContent").join("")
          : null;
      },
      attr: function attr(name, value) {
        var result;
        return typeof name == "string" && !(1 in arguments)
          ? 0 in this &&
            this[0].nodeType == 1 &&
            (result = this[0].getAttribute(name)) != null
            ? result
            : undefined$1
          : this.each(function(idx) {
              if (this.nodeType !== 1) return;
              if (isObject(name))
                for (key in name) {
                  setAttribute(this, key, name[key]);
                }
              else
                setAttribute(
                  this,
                  name,
                  funcArg(this, value, idx, this.getAttribute(name))
                );
            });
      },
      removeAttr: function removeAttr(name) {
        return this.each(function() {
          this.nodeType === 1 &&
            name.split(" ").forEach(function(attribute) {
              setAttribute(this, attribute);
            }, this);
        });
      },
      prop: function prop(name, value) {
        name = propMap[name] || name;
        return 1 in arguments
          ? this.each(function(idx) {
              this[name] = funcArg(this, value, idx, this[name]);
            })
          : this[0] && this[0][name];
      },
      removeProp: function removeProp(name) {
        name = propMap[name] || name;
        return this.each(function() {
          delete this[name];
        });
      },
      data: function data(name, value) {
        var attrName = "data-" + name.replace(capitalRE, "-$1").toLowerCase();
        var data =
          1 in arguments ? this.attr(attrName, value) : this.attr(attrName);
        return data !== null ? deserializeValue(data) : undefined$1;
      },
      val: function val(value) {
        if (0 in arguments) {
          if (value == null) value = "";
          return this.each(function(idx) {
            this.value = funcArg(this, value, idx, this.value);
          });
        } else {
          return (
            this[0] &&
            (this[0].multiple
              ? $(this[0])
                  .find("option")
                  .filter(function() {
                    return this.selected;
                  })
                  .pluck("value")
              : this[0].value)
          );
        }
      },
      offset: function offset(coordinates) {
        if (coordinates)
          return this.each(function(index) {
            var $this = $(this),
              coords = funcArg(this, coordinates, index, $this.offset()),
              parentOffset = $this.offsetParent().offset(),
              props = {
                top: coords.top - parentOffset.top,
                left: coords.left - parentOffset.left
              };
            if ($this.css("position") == "static")
              props["position"] = "relative";
            $this.css(props);
          });
        if (!this.length) return null;
        if (
          document.documentElement !== this[0] &&
          !$.contains(document.documentElement, this[0])
        )
          return {
            top: 0,
            left: 0
          };
        var obj = this[0].getBoundingClientRect();
        return {
          left: obj.left + window.pageXOffset,
          top: obj.top + window.pageYOffset,
          width: Math.round(obj.width),
          height: Math.round(obj.height)
        };
      },
      css: function css(property, value) {
        if (arguments.length < 2) {
          var element = this[0];
          if (typeof property == "string") {
            if (!element) return;
            return (
              element.style[camelize(property)] ||
              getComputedStyle(element, "").getPropertyValue(property)
            );
          } else if (isArray(property)) {
            if (!element) return;
            var props = {};
            var computedStyle = getComputedStyle(element, "");
            $.each(property, function(_, prop) {
              props[prop] =
                element.style[camelize(prop)] ||
                computedStyle.getPropertyValue(prop);
            });
            return props;
          }
        }
        var css = "";
        if (type(property) == "string") {
          if (!value && value !== 0)
            this.each(function() {
              this.style.removeProperty(dasherize(property));
            });
          else css = dasherize(property) + ":" + maybeAddPx(property, value);
        } else {
          for (key in property) {
            if (!property[key] && property[key] !== 0)
              this.each(function() {
                this.style.removeProperty(dasherize(key));
              });
            else
              css +=
                dasherize(key) + ":" + maybeAddPx(key, property[key]) + ";";
          }
        }
        return this.each(function() {
          this.style.cssText += ";" + css;
        });
      },
      index: function index(element) {
        return element
          ? this.indexOf($(element)[0])
          : this.parent()
              .children()
              .indexOf(this[0]);
      },
      hasClass: function hasClass(name) {
        if (!name) return false;
        return emptyArray.some.call(
          this,
          function(el) {
            return this.test(className(el));
          },
          classRE(name)
        );
      },
      addClass: function addClass(name) {
        if (!name) return this;
        return this.each(function(idx) {
          if (!("className" in this)) return;
          classList = [];
          var cls = className(this),
            newName = funcArg(this, name, idx, cls);
          newName.split(/\s+/g).forEach(function(klass) {
            if (!$(this).hasClass(klass)) classList.push(klass);
          }, this);
          classList.length &&
            className(this, cls + (cls ? " " : "") + classList.join(" "));
        });
      },
      removeClass: function removeClass(name) {
        return this.each(function(idx) {
          if (!("className" in this)) return;
          if (name === undefined$1) return className(this, "");
          classList = className(this);
          funcArg(this, name, idx, classList)
            .split(/\s+/g)
            .forEach(function(klass) {
              classList = classList.replace(classRE(klass), " ");
            });
          className(this, classList.trim());
        });
      },
      toggleClass: function toggleClass(name, when) {
        if (!name) return this;
        return this.each(function(idx) {
          var $this = $(this),
            names = funcArg(this, name, idx, className(this));
          names.split(/\s+/g).forEach(function(klass) {
            (when === undefined$1
            ? !$this.hasClass(klass)
            : when)
              ? $this.addClass(klass)
              : $this.removeClass(klass);
          });
        });
      },
      scrollTop: function scrollTop(value) {
        if (!this.length) return;
        var hasScrollTop = "scrollTop" in this[0];
        if (value === undefined$1)
          return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
        return this.each(
          hasScrollTop
            ? function() {
                this.scrollTop = value;
              }
            : function() {
                this.scrollTo(this.scrollX, value);
              }
        );
      },
      scrollLeft: function scrollLeft(value) {
        if (!this.length) return;
        var hasScrollLeft = "scrollLeft" in this[0];
        if (value === undefined$1)
          return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
        return this.each(
          hasScrollLeft
            ? function() {
                this.scrollLeft = value;
              }
            : function() {
                this.scrollTo(value, this.scrollY);
              }
        );
      },
      position: function position() {
        if (!this.length) return;
        var elem = this[0],
          offsetParent = this.offsetParent(),
          offset = this.offset(),
          parentOffset = rootNodeRE.test(offsetParent[0].nodeName)
            ? {
                top: 0,
                left: 0
              }
            : offsetParent.offset();
        offset.top -= parseFloat($(elem).css("margin-top")) || 0;
        offset.left -= parseFloat($(elem).css("margin-left")) || 0;
        parentOffset.top +=
          parseFloat($(offsetParent[0]).css("border-top-width")) || 0;
        parentOffset.left +=
          parseFloat($(offsetParent[0]).css("border-left-width")) || 0;
        return {
          top: offset.top - parentOffset.top,
          left: offset.left - parentOffset.left
        };
      },
      offsetParent: function offsetParent() {
        return this.map(function() {
          var parent = this.offsetParent || document.body;
          while (
            parent &&
            !rootNodeRE.test(parent.nodeName) &&
            $(parent).css("position") == "static"
          ) {
            parent = parent.offsetParent;
          }
          return parent;
        });
      }
    };
    $.fn.detach = $.fn.remove;
    ["width", "height"].forEach(function(dimension) {
      var dimensionProperty = dimension.replace(/./, function(m) {
        return m[0].toUpperCase();
      });
      $.fn[dimension] = function(value) {
        var offset,
          el = this[0];
        if (value === undefined$1)
          return isWindow(el)
            ? el["inner" + dimensionProperty]
            : isDocument(el)
            ? el.documentElement["scroll" + dimensionProperty]
            : (offset = this.offset()) && offset[dimension];
        else
          return this.each(function(idx) {
            el = $(this);
            el.css(dimension, funcArg(this, value, idx, el[dimension]()));
          });
      };
    });
    function traverseNode(node, fun) {
      fun(node);
      for (var i = 0, len = node.childNodes.length; i < len; i++) {
        traverseNode(node.childNodes[i], fun);
      }
    }
    function executeScript(doc, content, nonce) {
      var nearestNode = doc.getElementsByTagName("script")[0];
      if (!nearestNode) {
        return;
      }
      var parentNode = nearestNode.parentNode;
      if (!parentNode) {
        return;
      }
      var script = doc.createElement("script");
      script.innerHTML = content;
      if (isNotBlank(nonce)) {
        script.setAttribute("nonce", nonce);
      }
      parentNode.appendChild(script);
      parentNode.removeChild(script);
    }
    adjacencyOperators.forEach(function(operator, operatorIndex) {
      var inside = operatorIndex % 2;
      $.fn[operator] = function() {
        var argType,
          nodes = $.map(arguments, function(arg) {
            var arr = [];
            argType = type(arg);
            if (argType == "array") {
              arg.forEach(function(el) {
                if (el.nodeType !== undefined$1) return arr.push(el);
                else if ($.zepto.isZ(el)) return (arr = arr.concat(el.get()));
                arr = arr.concat(zepto.fragment(el));
              });
              return arr;
            }
            return argType == "object" || arg == null
              ? arg
              : zepto.fragment(arg);
          }),
          parent,
          copyByClone = this.length > 1;
        if (nodes.length < 1) return this;
        return this.each(function(_, target) {
          parent = inside ? target : target.parentNode;
          target =
            operatorIndex == 0
              ? target.nextSibling
              : operatorIndex == 1
              ? target.firstChild
              : operatorIndex == 2
              ? target
              : null;
          var parentInDocument = $.contains(document.documentElement, parent);
          var SCRIPT_TYPES = /^(text|application)\/(javascript|ecmascript)$/;
          var config = getConfig();
          var scriptNonce = config[CSP_SCRIPT_NONCE];
          var styleNonce = config[CSP_STYLE_NONCE];
          nodes.forEach(function(node) {
            if (copyByClone) node = node.cloneNode(true);
            else if (!parent) return $(node).remove();
            if (isNotBlank(scriptNonce) && node.tagName === "SCRIPT") {
              node.setAttribute("nonce", scriptNonce);
            }
            if (isNotBlank(styleNonce) && node.tagName === "STYLE") {
              node.setAttribute("nonce", styleNonce);
            }
            parent.insertBefore(node, target);
            if (parentInDocument)
              traverseNode(node, function(el) {
                if (
                  el.nodeName != null &&
                  el.nodeName.toUpperCase() === "SCRIPT" &&
                  (!el.type || SCRIPT_TYPES.test(el.type.toLowerCase())) &&
                  !el.src
                ) {
                  executeScript(document, el.innerHTML, el.nonce);
                }
              });
          });
        });
      };
      $.fn[
        inside
          ? operator + "To"
          : "insert" + (operatorIndex ? "Before" : "After")
      ] = function(html) {
        $(html)[operator](this);
        return this;
      };
    });
    zepto.Z.prototype = Z.prototype = $.fn;
    zepto.uniq = uniq;
    zepto.deserializeValue = deserializeValue;
    $.zepto = zepto;
    return $;
  })();
  (function($) {
    var _zid = 1,
      undefined$1,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function isString(obj) {
        return typeof obj == "string";
      },
      handlers = {},
      specialEvents = {},
      focusinSupported = "onfocusin" in window,
      focus = {
        focus: "focusin",
        blur: "focusout"
      },
      hover = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      };
    specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove =
      "MouseEvents";
    function zid(element) {
      return element._zid || (element._zid = _zid++);
    }
    function findHandlers(element, event, fn, selector) {
      event = parse(event);
      if (event.ns) var matcher = matcherFor(event.ns);
      return (handlers[zid(element)] || []).filter(function(handler) {
        return (
          handler &&
          (!event.e || handler.e == event.e) &&
          (!event.ns || matcher.test(handler.ns)) &&
          (!fn || zid(handler.fn) === zid(fn)) &&
          (!selector || handler.sel == selector)
        );
      });
    }
    function parse(event) {
      var parts = ("" + event).split(".");
      return {
        e: parts[0],
        ns: parts
          .slice(1)
          .sort()
          .join(" ")
      };
    }
    function matcherFor(ns) {
      return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
    }
    function eventCapture(handler, captureSetting) {
      return (
        (handler.del && !focusinSupported && handler.e in focus) ||
        !!captureSetting
      );
    }
    function realEvent(type) {
      return hover[type] || (focusinSupported && focus[type]) || type;
    }
    function add(element, events, fn, data, selector, delegator, capture) {
      var id = zid(element),
        set = handlers[id] || (handlers[id] = []);
      events.split(/\s/).forEach(function(event) {
        if (event == "ready") return $(document).ready(fn);
        var handler = parse(event);
        handler.fn = fn;
        handler.sel = selector;
        if (handler.e in hover)
          fn = function fn(e) {
            var related = e.relatedTarget;
            if (!related || (related !== this && !$.contains(this, related)))
              return handler.fn.apply(this, arguments);
          };
        handler.del = delegator;
        var callback = delegator || fn;
        handler.proxy = function(e) {
          e = compatible(e);
          if (e.isImmediatePropagationStopped()) return;
          e.data = data;
          var result = callback.apply(
            element,
            e._args == undefined$1 ? [e] : [e].concat(e._args)
          );
          if (result === false) e.preventDefault(), e.stopPropagation();
          return result;
        };
        handler.i = set.length;
        set.push(handler);
        if ("addEventListener" in element)
          element.addEventListener(
            realEvent(handler.e),
            handler.proxy,
            eventCapture(handler, capture)
          );
      });
    }
    function remove(element, events, fn, selector, capture) {
      var id = zid(element);
      (events || "").split(/\s/).forEach(function(event) {
        findHandlers(element, event, fn, selector).forEach(function(handler) {
          delete handlers[id][handler.i];
          if ("removeEventListener" in element)
            element.removeEventListener(
              realEvent(handler.e),
              handler.proxy,
              eventCapture(handler, capture)
            );
        });
      });
    }
    $.event = {
      add: add,
      remove: remove
    };
    $.proxy = function(fn, context) {
      var args = 2 in arguments && slice.call(arguments, 2);
      if (isFunction(fn)) {
        var proxyFn = function proxyFn() {
          return fn.apply(
            context,
            args ? args.concat(slice.call(arguments)) : arguments
          );
        };
        proxyFn._zid = zid(fn);
        return proxyFn;
      } else if (isString(context)) {
        if (args) {
          args.unshift(fn[context], fn);
          return $.proxy.apply(null, args);
        } else {
          return $.proxy(fn[context], fn);
        }
      } else {
        throw new TypeError("expected function");
      }
    };
    $.fn.bind = function(event, data, callback) {
      return this.on(event, data, callback);
    };
    $.fn.unbind = function(event, callback) {
      return this.off(event, callback);
    };
    $.fn.one = function(event, selector, data, callback) {
      return this.on(event, selector, data, callback, 1);
    };
    var returnTrue = function returnTrue() {
        return true;
      },
      returnFalse = function returnFalse() {
        return false;
      },
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
        preventDefault: "isDefaultPrevented",
        stopImmediatePropagation: "isImmediatePropagationStopped",
        stopPropagation: "isPropagationStopped"
      };
    function compatible(event, source) {
      if (source || !event.isDefaultPrevented) {
        source || (source = event);
        $.each(eventMethods, function(name, predicate) {
          var sourceMethod = source[name];
          event[name] = function() {
            this[predicate] = returnTrue;
            return sourceMethod && sourceMethod.apply(source, arguments);
          };
          event[predicate] = returnFalse;
        });
        try {
          event.timeStamp || (event.timeStamp = new Date().getTime());
        } catch (ignored) {}
        if (
          source.defaultPrevented !== undefined$1
            ? source.defaultPrevented
            : "returnValue" in source
            ? source.returnValue === false
            : source.getPreventDefault && source.getPreventDefault()
        )
          event.isDefaultPrevented = returnTrue;
      }
      return event;
    }
    function createProxy(event) {
      var key,
        proxy = {
          originalEvent: event
        };
      for (key in event) {
        if (!ignoreProperties.test(key) && event[key] !== undefined$1)
          proxy[key] = event[key];
      }
      return compatible(proxy, event);
    }
    $.fn.delegate = function(selector, event, callback) {
      return this.on(event, selector, callback);
    };
    $.fn.undelegate = function(selector, event, callback) {
      return this.off(event, selector, callback);
    };
    $.fn.live = function(event, callback) {
      $(document.body).delegate(this.selector, event, callback);
      return this;
    };
    $.fn.die = function(event, callback) {
      $(document.body).undelegate(this.selector, event, callback);
      return this;
    };
    $.fn.on = function(event, selector, data, callback, one) {
      var autoRemove,
        delegator,
        $this = this;
      if (event && !isString(event)) {
        $.each(event, function(type, fn) {
          $this.on(type, selector, data, fn, one);
        });
        return $this;
      }
      if (!isString(selector) && !isFunction(callback) && callback !== false)
        (callback = data), (data = selector), (selector = undefined$1);
      if (callback === undefined$1 || data === false)
        (callback = data), (data = undefined$1);
      if (callback === false) callback = returnFalse;
      return $this.each(function(_, element) {
        if (one)
          autoRemove = function autoRemove(e) {
            remove(element, e.type, callback);
            return callback.apply(this, arguments);
          };
        if (selector)
          delegator = function delegator(e) {
            var evt,
              match = $(e.target)
                .closest(selector, element)
                .get(0);
            if (match && match !== element) {
              evt = $.extend(createProxy(e), {
                currentTarget: match,
                liveFired: element
              });
              return (autoRemove || callback).apply(
                match,
                [evt].concat(slice.call(arguments, 1))
              );
            }
          };
        add(element, event, callback, data, selector, delegator || autoRemove);
      });
    };
    $.fn.off = function(event, selector, callback) {
      var $this = this;
      if (event && !isString(event)) {
        $.each(event, function(type, fn) {
          $this.off(type, selector, fn);
        });
        return $this;
      }
      if (!isString(selector) && !isFunction(callback) && callback !== false)
        (callback = selector), (selector = undefined$1);
      if (callback === false) callback = returnFalse;
      return $this.each(function() {
        remove(this, event, callback, selector);
      });
    };
    $.fn.trigger = function(event, args) {
      event =
        isString(event) || $.isPlainObject(event)
          ? $.Event(event)
          : compatible(event);
      event._args = args;
      return this.each(function() {
        if (event.type in focus && typeof this[event.type] == "function")
          this[event.type]();
        else if ("dispatchEvent" in this) this.dispatchEvent(event);
        else $(this).triggerHandler(event, args);
      });
    };
    $.fn.triggerHandler = function(event, args) {
      var e, result;
      this.each(function(i, element) {
        e = createProxy(isString(event) ? $.Event(event) : event);
        e._args = args;
        e.target = element;
        $.each(findHandlers(element, event.type || event), function(
          i,
          handler
        ) {
          result = handler.proxy(e);
          if (e.isImmediatePropagationStopped()) return false;
        });
      });
      return result;
    };
    (
      "focusin focusout focus blur load resize scroll unload click dblclick " +
      "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
      "change select keydown keypress keyup error"
    )
      .split(" ")
      .forEach(function(event) {
        $.fn[event] = function(callback) {
          return 0 in arguments
            ? this.bind(event, callback)
            : this.trigger(event);
        };
      });
    $.Event = function(type, props) {
      if (!isString(type)) (props = type), (type = props.type);
      var event = document.createEvent(specialEvents[type] || "Events"),
        bubbles = true;
      if (props)
        for (var name in props) {
          name == "bubbles"
            ? (bubbles = !!props[name])
            : (event[name] = props[name]);
        }
      event.initEvent(type, bubbles, true);
      return compatible(event);
    };
  })(Zepto);
  (function() {
    try {
      getComputedStyle(undefined);
    } catch (e) {
      var nativeGetComputedStyle = getComputedStyle;
      window.getComputedStyle = function(element, pseudoElement) {
        try {
          return nativeGetComputedStyle(element, pseudoElement);
        } catch (e) {
          return null;
        }
      };
    }
  })();
  (function($) {
    var zepto = $.zepto,
      oldQsa = zepto.qsa,
      childRe = /^\s*>/,
      classTag = "Zepto" + +new Date();
    zepto.qsa = function(node, selector) {
      var sel = selector,
        nodes,
        taggedParent;
      try {
        if (!sel) sel = "*";
        else if (childRe.test(sel))
          (taggedParent = $(node).addClass(classTag)),
            (sel = "." + classTag + " " + sel);
        nodes = oldQsa(node, sel);
      } catch (e) {
        throw e;
      } finally {
        if (taggedParent) taggedParent.removeClass(classTag);
      }
      return nodes;
    };
  })(Zepto);
  return Zepto;
})(window);

var MO_OBJECT = window.MutationObserver || window.WebkitMutationObserver;
function canUseMutationObserver() {
  return isFunction(MO_OBJECT);
}
function getMutationObserver(callback) {
  return new MO_OBJECT(callback);
}

var ARRAY_EXPECTED = "Expected an array of promises";
function getMoImmediateFn() {
  var textnode = document.createTextNode("");
  var twiddleNode = function twiddleNode() {
    textnode.textContent = textnode.textContent.length > 0 ? "" : "a";
  };
  var callbacks = [];
  var mo = getMutationObserver(function() {
    var len = callbacks.length;
    for (var i = 0; i < len; i += 1) {
      callbacks[i]();
    }
    callbacks.splice(0, len);
  });
  mo.observe(textnode, {
    characterData: true
  });
  return function(fn) {
    callbacks.push(fn);
    twiddleNode();
  };
}
function getOnReadyStateChangeImmediateFn() {
  return function(fn) {
    var scriptEl = $("<script>");
    scriptEl.on("readystatechange", function() {
      scriptEl.on("readystatechange", null);
      scriptEl.remove();
      scriptEl = null;
      fn();
    });
    $(document.documentElement).append(scriptEl);
  };
}
function setupPromiseImmediateFn() {
  if (canUseMutationObserver()) {
    Promise$1._setImmediateFn(getMoImmediateFn());
    return;
  }
  if (window.navigator.userAgent.indexOf("MSIE 10") !== -1) {
    Promise$1._setImmediateFn(getOnReadyStateChangeImmediateFn());
  }
}
if (Promise$1._setImmediateFn) {
  setupPromiseImmediateFn();
}
function create(func) {
  return new Promise$1(func);
}
function resolve(value) {
  return Promise$1.resolve(value);
}
function reject(value) {
  return Promise$1.reject(value);
}
function race(arr) {
  if (!isArray(arr)) {
    return reject(new TypeError(ARRAY_EXPECTED));
  }
  return Promise$1.race(arr);
}
function all(arr) {
  if (!isArray(arr)) {
    return reject(new TypeError(ARRAY_EXPECTED));
  }
  return Promise$1.all(arr);
}
function timeout(promise, time, message) {
  var id = -1;
  var delayedPromise = create(function(_, rej) {
    id = delay(function() {
      return rej(new Error(message));
    }, time);
  });
  return race([promise, delayedPromise]).then(
    function(val) {
      cancelDelay(id);
      return val;
    },
    function(err) {
      cancelDelay(id);
      throw err;
    }
  );
}

function isOptinAvailable(win) {
  if (isNil(win[ADOBE])) {
    return false;
  }
  var adobe = win[ADOBE];
  if (isNil(adobe[OPTIN])) {
    return false;
  }
  var optin = adobe[OPTIN];
  return isFunction(optin[FETCH_PERMISSIONS]) && isFunction(optin[IS_APPROVED]);
}
function isOptinEnabled(win, optinEnabled) {
  if (!optinEnabled) {
    return false;
  }
  return isOptinAvailable(win);
}
function isCategoryApproved(win, key) {
  if (!isOptinAvailable(win)) {
    return true;
  }
  var optIn = win[ADOBE][OPTIN];
  var categories = win[ADOBE][OPTIN][CATEGORIES] || {};
  var category = categories[key];
  return optIn[IS_APPROVED](category);
}
function fetchPermissions(win, key) {
  if (!isOptinAvailable(win)) {
    return resolve(true);
  }
  var optIn = win[ADOBE][OPTIN];
  var categories = win[ADOBE][OPTIN][CATEGORIES] || {};
  var category = categories[key];
  return create(function(res, rej) {
    optIn[FETCH_PERMISSIONS](function() {
      if (optIn[IS_APPROVED](category)) {
        res(true);
      } else {
        rej(ERROR_TARGET_NOT_OPTED_IN);
      }
    }, true);
  });
}

function shouldUseOptin() {
  var config = getConfig();
  var optinEnabled = config[OPTIN_ENABLED];
  return isOptinEnabled(window, optinEnabled);
}
function isTargetApproved() {
  return isCategoryApproved(window, TARGET);
}
function isAnalyticsApproved() {
  return isCategoryApproved(window, ANALYTICS);
}
function fetchOptinPermissions() {
  return fetchPermissions(window, TARGET);
}

var SESSION_ID = uuid();
function getSessionIdFromQuery() {
  var location = window.location;
  var search = location.search;
  var params = parseQueryString(search);
  return params[SESSION_ID_PARAM];
}
function saveSessionId(value, config) {
  setTargetCookie({
    name: SESSION_ID_COOKIE,
    value: value,
    expires: config[SESSION_ID_LIFETIME],
    domain: config[COOKIE_DOMAIN]
  });
}
function getSessionId() {
  if (shouldUseOptin() && !isTargetApproved()) {
    return SESSION_ID;
  }
  var config = getConfig();
  var sessionIdQuery = getSessionIdFromQuery();
  if (isNotBlank(sessionIdQuery)) {
    saveSessionId(sessionIdQuery, config);
    return getTargetCookie(SESSION_ID_COOKIE);
  }
  var sessionId = getTargetCookie(SESSION_ID_COOKIE);
  if (isBlank(sessionId)) {
    saveSessionId(SESSION_ID, config);
  }
  return getTargetCookie(SESSION_ID_COOKIE);
}

function setDeviceId(value) {
  var config = getConfig();
  setTargetCookie({
    name: DEVICE_ID_COOKIE,
    value: value,
    expires: config[DEVICE_ID_LIFETIME],
    domain: config[COOKIE_DOMAIN]
  });
}
function getDeviceId() {
  return getTargetCookie(DEVICE_ID_COOKIE);
}

var CLUSTER_ID_REGEX = /.*\.(\d+)_\d+/;
function extractCluster(id) {
  if (isBlank(id)) {
    return "";
  }
  var result = CLUSTER_ID_REGEX.exec(id);
  if (isEmpty(result) || result.length !== 2) {
    return "";
  }
  return result[1];
}
function getEdgeCluster() {
  var config = getConfig();
  if (!config[OVERRIDE_MBOX_EDGE_SERVER]) {
    return "";
  }
  var result = getCookie(EDGE_CLUSTER_COOKIE);
  return isBlank(result) ? "" : result;
}
function setEdgeCluster(id) {
  var config = getConfig();
  if (!config[OVERRIDE_MBOX_EDGE_SERVER]) {
    return;
  }
  var domain = config[COOKIE_DOMAIN];
  var expires = new Date(now() + config[OVERRIDE_MBOX_EDGE_SERVER_TIMEOUT]);
  var savedCluster = getCookie(EDGE_CLUSTER_COOKIE);
  var attrs = {
    domain: domain,
    expires: expires
  };
  if (isNotBlank(savedCluster)) {
    setCookie(EDGE_CLUSTER_COOKIE, savedCluster, attrs);
    return;
  }
  var cluster = extractCluster(id);
  if (isBlank(cluster)) {
    return;
  }
  setCookie(EDGE_CLUSTER_COOKIE, cluster, attrs);
}

function bootstrapNotify(win, doc) {
  if (isFunction(win.CustomEvent)) {
    return;
  }
  function CustomEvent(event, params) {
    var evt = doc.createEvent("CustomEvent");
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    evt.initCustomEvent(
      event,
      params.bubbles,
      params.cancelable,
      params.detail
    );
    return evt;
  }
  CustomEvent.prototype = win.Event.prototype;
  win.CustomEvent = CustomEvent;
}
function createTracking(getSessionId, getDeviceId) {
  var sessionId = getSessionId();
  var deviceId = getDeviceId();
  var result = {};
  result.sessionId = sessionId;
  if (isNotBlank(deviceId)) {
    result.deviceId = deviceId;
    return result;
  }
  return result;
}
function notify(win, doc, eventName, detail) {
  var event = new win.CustomEvent(eventName, {
    detail: detail
  });
  doc.dispatchEvent(event);
}

bootstrapNotify(window, document);
var LIBRARY_LOADED = "at-library-loaded";
var REQUEST_START = "at-request-start";
var REQUEST_SUCCEEDED$1 = "at-request-succeeded";
var REQUEST_FAILED$1 = "at-request-failed";
var CONTENT_RENDERING_START = "at-content-rendering-start";
var CONTENT_RENDERING_SUCCEEDED = "at-content-rendering-succeeded";
var CONTENT_RENDERING_FAILED = "at-content-rendering-failed";
var CONTENT_RENDERING_NO_OFFERS = "at-content-rendering-no-offers";
var CONTENT_RENDERING_REDIRECT = "at-content-rendering-redirect";
function buildPayload(type, detail) {
  var mbox = detail.mbox,
    error = detail.error,
    url = detail.url,
    analyticsDetails = detail.analyticsDetails,
    responseTokens = detail.responseTokens,
    execution = detail.execution;
  var tracking = createTracking(getSessionId, getDeviceId);
  var payload = {
    type: type,
    tracking: tracking
  };
  if (!isNil(mbox)) {
    payload.mbox = mbox;
  }
  if (!isNil(error)) {
    payload.error = error;
  }
  if (!isNil(url)) {
    payload.url = url;
  }
  if (!isEmpty(analyticsDetails)) {
    payload.analyticsDetails = analyticsDetails;
  }
  if (!isEmpty(responseTokens)) {
    payload.responseTokens = responseTokens;
  }
  if (!isEmpty(execution)) {
    payload.execution = execution;
  }
  return payload;
}
function notifyLibraryLoaded() {
  var payload = buildPayload(LIBRARY_LOADED, {});
  notify(window, document, LIBRARY_LOADED, payload);
}
function notifyRequestStart(detail) {
  var payload = buildPayload(REQUEST_START, detail);
  notify(window, document, REQUEST_START, payload);
}
function notifyRequestSucceeded(detail, redirect) {
  var payload = buildPayload(REQUEST_SUCCEEDED$1, detail);
  payload.redirect = redirect;
  notify(window, document, REQUEST_SUCCEEDED$1, payload);
}
function notifyRequestFailed(detail) {
  var payload = buildPayload(REQUEST_FAILED$1, detail);
  notify(window, document, REQUEST_FAILED$1, payload);
}
function notifyRenderingStart(detail) {
  var payload = buildPayload(CONTENT_RENDERING_START, detail);
  notify(window, document, CONTENT_RENDERING_START, payload);
}
function notifyRenderingSucceeded(detail) {
  var payload = buildPayload(CONTENT_RENDERING_SUCCEEDED, detail);
  notify(window, document, CONTENT_RENDERING_SUCCEEDED, payload);
}
function notifyRenderingFailed(detail) {
  var payload = buildPayload(CONTENT_RENDERING_FAILED, detail);
  notify(window, document, CONTENT_RENDERING_FAILED, payload);
}
function notifyRenderingNoOffers(detail) {
  var payload = buildPayload(CONTENT_RENDERING_NO_OFFERS, detail);
  notify(window, document, CONTENT_RENDERING_NO_OFFERS, payload);
}
function notifyRenderingRedirect(detail) {
  var payload = buildPayload(CONTENT_RENDERING_REDIRECT, detail);
  notify(window, document, CONTENT_RENDERING_REDIRECT, payload);
}

function isElement(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
}

var EQ_START = ":eq(";
var EQ_END = ")";
var EQ_LENGTH = EQ_START.length;
var DIGIT_IN_SELECTOR_PATTERN = /((\.|#)(-)?\d{1})/g;
function createPair(match) {
  var first = match.charAt(0);
  var second = match.charAt(1);
  var third = match.charAt(2);
  var result = {
    key: match
  };
  if (second === "-") {
    result.val = "" + first + second + "\\3" + third + " ";
  } else {
    result.val = first + "\\3" + second + " ";
  }
  return result;
}
function escapeDigitsInSelector(selector) {
  var matches = selector.match(DIGIT_IN_SELECTOR_PATTERN);
  if (isEmpty(matches)) {
    return selector;
  }
  var pairs = map(createPair, matches);
  return reduce(
    function(acc, pair) {
      return acc.replace(pair.key, pair.val);
    },
    selector,
    pairs
  );
}
function parseSelector(selector) {
  var result = [];
  var sel = trim(selector);
  var currentIndex = sel.indexOf(EQ_START);
  var head;
  var tail;
  var eq;
  var index;
  while (currentIndex !== -1) {
    head = trim(sel.substring(0, currentIndex));
    tail = trim(sel.substring(currentIndex));
    index = tail.indexOf(EQ_END);
    eq = trim(tail.substring(EQ_LENGTH, index));
    sel = trim(tail.substring(index + 1));
    currentIndex = sel.indexOf(EQ_START);
    if (head && eq) {
      result.push({
        sel: head,
        eq: Number(eq)
      });
    }
  }
  if (sel) {
    result.push({
      sel: sel
    });
  }
  return result;
}
function select(selector) {
  if (isElement(selector)) {
    return $(selector);
  }
  if (!isString(selector)) {
    return $(selector);
  }
  var selectorAsString = escapeDigitsInSelector(selector);
  if (selectorAsString.indexOf(EQ_START) === -1) {
    return $(selectorAsString);
  }
  var parts = parseSelector(selectorAsString);
  return reduce(
    function(acc, part) {
      var sel = part.sel,
        eq = part.eq;
      acc = acc.find(sel);
      if (isNumber(eq)) {
        acc = acc.eq(eq);
      }
      return acc;
    },
    $(document),
    parts
  );
}
function exists$2(selector) {
  return select(selector).length > 0;
}
function fragment(content) {
  return $("<" + DIV_TAG + "/>").append(content);
}
function wrap(content) {
  return $(content);
}
function prev(selector) {
  return select(selector).prev();
}
function next(selector) {
  return select(selector).next();
}
function parent(selector) {
  return select(selector).parent();
}
function is(query, selector) {
  return select(selector).is(query);
}
function find(query, selector) {
  return select(selector).find(query);
}
function children(selector) {
  return select(selector).children();
}

var LOAD_ERROR = "Unable to load target-vec.js";
var LOAD_AUTHORING = "Loading target-vec.js";
var NAMESPACE = "_AT";
var EDITOR = "clickHandlerForExperienceEditor";
var CURRENT_VIEW = "currentView";
function initNamespace() {
  window[NAMESPACE] = window[NAMESPACE] || {};
  window[NAMESPACE].querySelectorAll = select;
}
function handleAuthoringTriggeredView(options) {
  if (!isAuthoringEnabled()) {
    return;
  }
  var viewName = options[VIEW_NAME];
  window[NAMESPACE][CURRENT_VIEW] = viewName;
}
function setupClickHandler() {
  document.addEventListener(
    CLICK,
    function(event) {
      if (isFunction(window[NAMESPACE][EDITOR])) {
        window[NAMESPACE][EDITOR](event);
      }
    },
    true
  );
}
function initAuthoringCode() {
  if (!isAuthoringEnabled()) {
    return;
  }
  initNamespace();
  var config = getConfig();
  var authoringScriptUrl = config[AUTHORING_SCRIPT_URL];
  var success = function success() {
    return setupClickHandler();
  };
  var error = function error() {
    return logWarn(LOAD_ERROR);
  };
  logDebug(LOAD_AUTHORING);
  loadScript(authoringScriptUrl)
    .then(success)
    ["catch"](error);
}

var QA_MODE_COOKIE = "at_qa_mode";
var PREVIEW_TOKEN = "at_preview_token";
var PREVIEW_INDEX = "at_preview_index";
var ACTIVITIES_ONLY = "at_preview_listed_activities_only";
var TRUE_AUDIENCE_IDS = "at_preview_evaluate_as_true_audience_ids";
var FALSE_AUDIENCE_IDS = "at_preview_evaluate_as_false_audience_ids";
var UNDERSCORE = "_";
var notNull = function notNull(v) {
  return !isNil(v);
};
function toNumber(value) {
  return parseInt(value, 10);
}
function getIndex(value) {
  var result = toNumber(value);
  return isNaN(result) ? null : result;
}
function extractAudienceIds(value) {
  return split(UNDERSCORE, value);
}
function parsePreviewIndex(value) {
  var pair = split(UNDERSCORE, value);
  var activityIndex = getIndex(pair[0]);
  if (isNil(activityIndex)) {
    return null;
  }
  var result = {};
  result.activityIndex = activityIndex;
  var experienceIndex = getIndex(pair[1]);
  if (!isNil(experienceIndex)) {
    result.experienceIndex = experienceIndex;
  }
  return result;
}
function parsePreviewIndexes(values) {
  return filter(notNull, map(parsePreviewIndex, values));
}
function extractPreviewIndexes(value) {
  if (isArray(value)) {
    return parsePreviewIndexes(value);
  }
  return parsePreviewIndexes([value]);
}
function extractQaMode(queryString) {
  var query = parseQueryString(queryString);
  var token = query[PREVIEW_TOKEN];
  if (isBlank(token)) {
    return null;
  }
  var result = {};
  result.token = token;
  var listedActivitiesOnly = query[ACTIVITIES_ONLY];
  if (isNotBlank(listedActivitiesOnly) && listedActivitiesOnly === TRUE) {
    result.listedActivitiesOnly = true;
  }
  var trueAudiences = query[TRUE_AUDIENCE_IDS];
  if (isNotBlank(trueAudiences)) {
    result.evaluateAsTrueAudienceIds = extractAudienceIds(trueAudiences);
  }
  var falseAudiences = query[FALSE_AUDIENCE_IDS];
  if (isNotBlank(falseAudiences)) {
    result.evaluateAsFalseAudienceIds = extractAudienceIds(falseAudiences);
  }
  var previewIndexes = query[PREVIEW_INDEX];
  if (isEmpty(previewIndexes)) {
    return result;
  }
  result.previewIndexes = extractPreviewIndexes(previewIndexes);
  return result;
}
function initQaMode(win) {
  var result = extractQaMode(win.location.search);
  if (isNil(result)) {
    return;
  }
  var expires = new Date(now() + 1.86e6);
  setCookie(QA_MODE_COOKIE, JSON.stringify(result), {
    expires: expires
  });
}
function getQaMode() {
  var result = getCookie(QA_MODE_COOKIE);
  if (isBlank(result)) {
    return {};
  }
  try {
    return JSON.parse(result);
  } catch (e) {
    return {};
  }
}

var PREVIEW_MODE_COOKIE = "at_preview_mode";
var PREVIEW_MODE_TOKEN = "at_preview";
function extractPreviewMode(queryString) {
  var query = parseQueryString(queryString);
  var token = query[PREVIEW_MODE_TOKEN];
  if (isBlank(token)) {
    return null;
  }
  return {
    token: token
  };
}
function initPreviewMode(win) {
  var result = extractPreviewMode(win.location.search);
  if (isNil(result)) {
    return;
  }
  var expires = new Date(now() + 1.86e6);
  setCookie(PREVIEW_MODE_COOKIE, JSON.stringify(result), {
    expires: expires
  });
}
function getPreview() {
  var result = getCookie(PREVIEW_MODE_COOKIE);
  if (isBlank(result)) {
    return {};
  }
  try {
    return JSON.parse(result);
  } catch (e) {
    return {};
  }
}

function remove(selector) {
  return select(selector)
    .empty()
    .remove();
}
function after(content, selector) {
  return select(selector).after(content);
}
function before(content, selector) {
  return select(selector).before(content);
}
function append(content, selector) {
  return select(selector).append(content);
}
function prepend(content, selector) {
  return select(selector).prepend(content);
}
function setHtml(content, selector) {
  return select(selector).html(content);
}
function getHtml(selector) {
  return select(selector).html();
}
function setText(content, selector) {
  return select(selector).text(content);
}

var STYLE_PREFIX = "at-";
var BODY_STYLE_ID = "at-body-style";
var BODY_STYLE_ID_SELECTOR = "#" + BODY_STYLE_ID;
var ALL_VIEWS_STYLE_ID = STYLE_PREFIX + "views";
function createStyleMarkup(id, content) {
  return (
    "<" +
    STYLE_TAG +
    " " +
    ID +
    '="' +
    id +
    '" ' +
    CLASS +
    '="' +
    FLICKER_CONTROL_CLASS +
    '">' +
    content +
    "</" +
    STYLE_TAG +
    ">"
  );
}
function createActionStyle(styleDef, selector) {
  var id = STYLE_PREFIX + hash(selector);
  var style = selector + " {" + styleDef + "}";
  return createStyleMarkup(id, style);
}
function createAllViewsStyle(styleDef, aggregateSelector) {
  var style = aggregateSelector + " {" + styleDef + "}";
  return createStyleMarkup(ALL_VIEWS_STYLE_ID, style);
}
function addHidingSnippet(config) {
  var bodyHidingEnabled = config[BODY_HIDING_ENABLED];
  if (bodyHidingEnabled !== true) {
    return;
  }
  if (exists$2(BODY_STYLE_ID_SELECTOR)) {
    return;
  }
  var bodyHiddenStyle = config[BODY_HIDDEN_STYLE];
  append(createStyleMarkup(BODY_STYLE_ID, bodyHiddenStyle), HEAD_TAG);
}
function removeHidingSnippet(config) {
  var bodyHidingEnabled = config[BODY_HIDING_ENABLED];
  if (bodyHidingEnabled !== true) {
    return;
  }
  if (!exists$2(BODY_STYLE_ID_SELECTOR)) {
    return;
  }
  remove(BODY_STYLE_ID_SELECTOR);
}
function addActionHidings(config, selectors) {
  if (isEmpty(selectors)) {
    return;
  }
  var alreadyHidden = function alreadyHidden(selector) {
    return !exists$2("#" + (STYLE_PREFIX + hash(selector)));
  };
  var selectorsToHide = filter(alreadyHidden, selectors);
  if (isEmpty(selectorsToHide)) {
    return;
  }
  var styleDef = config[DEFAULT_CONTENT_HIDDEN_STYLE];
  var buildStyle = function buildStyle(selector) {
    return createActionStyle(styleDef, selector);
  };
  var content = join("\n", map(buildStyle, selectorsToHide));
  append(content, HEAD_TAG);
}
function addAllViewsHidings(config, selectors) {
  if (isEmpty(selectors) || exists$2("#" + ALL_VIEWS_STYLE_ID)) {
    return;
  }
  var styleDef = config[DEFAULT_CONTENT_HIDDEN_STYLE];
  var aggregateSelector = join(", ", selectors);
  var content = createAllViewsStyle(styleDef, aggregateSelector);
  append(content, HEAD_TAG);
}

function injectHidingSnippetStyle() {
  addHidingSnippet(getConfig());
}
function removeHidingSnippetStyle() {
  removeHidingSnippet(getConfig());
}
function injectActionHidingStyles(selectors) {
  addActionHidings(getConfig(), selectors);
}
function injectAllViewsHidingStyle(selectors) {
  addAllViewsHidings(getConfig(), selectors);
}
function removeActionHidingStyle(selector) {
  var id = STYLE_PREFIX + hash(selector);
  remove("#" + id);
}
function removeAllViewsHidingStyle() {
  var hidingStyleSelector = "#" + ALL_VIEWS_STYLE_ID;
  if (exists$2(hidingStyleSelector)) {
    remove(hidingStyleSelector);
  }
}

var OPTOUT_MESSAGE = "Disabled due to optout";
var MCAAMB = "MCAAMB";
var MCAAMLH = "MCAAMLH";
var MCMID = "MCMID";
var MCOPTOUT = "MCOPTOUT";
var SDID_METHOD = "getSupplementalDataID";
var CIDS_METHOD = "getCustomerIDs";
var SUPPORTS_NS = true;
var NAMESPACE_TYPE = "NS";
var DATASOURCE_TYPE = "DS";
var TRACK_SERVER_PROP = "trackingServer";
var TRACK_SERVER_SECURE_PROP = TRACK_SERVER_PROP + "Secure";
function hasId(value) {
  return !isNil(value[ID]);
}
function hasAuthState(value) {
  return !isNil(value[AUTH_STATE]);
}
function getAuthenticatedState(value) {
  switch (value) {
    case 0:
      return "unknown";
    case 1:
      return "authenticated";
    case 2:
      return "logged_out";
    default:
      return "unknown";
  }
}
function isPrimary(value) {
  return value[PRIMARY];
}
function isCustomerId(value) {
  return hasId(value) || hasAuthState(value);
}
function normalizeCustomerIds(customerIds, customerIdType) {
  return reduce(
    function(acc, value, key) {
      var item = {};
      item[INTEGRATION_CODE] = key;
      if (hasId(value)) {
        item[ID] = value[ID];
      }
      if (hasAuthState(value)) {
        item[AUTHENTICATED_STATE] = getAuthenticatedState(value[AUTH_STATE]);
      }
      item[TYPE] = customerIdType;
      if (isPrimary(value)) {
        item[PRIMARY] = true;
      }
      acc.push(item);
      return acc;
    },
    [],
    filter(isCustomerId, customerIds)
  );
}
function buildDeliveryCustomerIds(customerIds) {
  if (!customerIds.nameSpaces && !customerIds.dataSources) {
    return normalizeCustomerIds(customerIds, DATASOURCE_TYPE);
  }
  var normalizedCustomerIds = [];
  if (customerIds.nameSpaces) {
    normalizedCustomerIds.push.apply(
      normalizedCustomerIds,
      normalizeCustomerIds(customerIds.nameSpaces, NAMESPACE_TYPE)
    );
  }
  if (customerIds.dataSources) {
    normalizedCustomerIds.push.apply(
      normalizedCustomerIds,
      normalizeCustomerIds(customerIds.dataSources, DATASOURCE_TYPE)
    );
  }
  return normalizedCustomerIds;
}
function getCustomerIds(visitor) {
  if (isNil(visitor)) {
    return [];
  }
  if (!isFunction(visitor[CIDS_METHOD])) {
    return [];
  }
  var customerIds = visitor[CIDS_METHOD](SUPPORTS_NS);
  if (!isObject(customerIds)) {
    return [];
  }
  return buildDeliveryCustomerIds(customerIds);
}
function getSdid(visitor, consumerId) {
  if (isNil(visitor)) {
    return null;
  }
  if (!isFunction(visitor[SDID_METHOD])) {
    return null;
  }
  return visitor[SDID_METHOD](consumerId);
}
function getInstanceProperty(visitor, property) {
  if (isNil(visitor)) {
    return null;
  }
  var result = visitor[property];
  if (isNil(result)) {
    return null;
  }
  return result;
}

var VISITOR = "Visitor";
var GET_INSTANCE_METHOD = "getInstance";
var IS_ALLOWED_METHOD = "isAllowed";
function getInstance(win, imsOrgId, sdidParamExpiry) {
  if (isBlank(imsOrgId)) {
    return null;
  }
  if (isNil(win[VISITOR])) {
    return null;
  }
  if (!isFunction(win[VISITOR][GET_INSTANCE_METHOD])) {
    return null;
  }
  var visitor = win[VISITOR][GET_INSTANCE_METHOD](imsOrgId, {
    sdidParamExpiry: sdidParamExpiry
  });
  if (
    isObject(visitor) &&
    isFunction(visitor[IS_ALLOWED_METHOD]) &&
    visitor[IS_ALLOWED_METHOD]()
  ) {
    return visitor;
  }
  return null;
}

var TIMEOUT_MESSAGE = "Visitor API requests timed out";
var ERROR_MESSAGE = "Visitor API requests error";
function getVisitorValuesAsync(visitor, optoutEnabled) {
  if (!isFunction(visitor.getVisitorValues)) {
    return resolve({});
  }
  var fields = [MCMID, MCAAMB, MCAAMLH];
  if (optoutEnabled) {
    fields.push(MCOPTOUT);
  }
  return create(function(res) {
    visitor.getVisitorValues(function(values) {
      return res(values);
    }, fields);
  });
}
function handleError(error) {
  logDebug(ERROR_MESSAGE, error);
  return {};
}
function getAsyncValues(visitor, visitorApiTimeout, optoutEnabled) {
  if (isNil(visitor)) {
    return resolve({});
  }
  var requests = getVisitorValuesAsync(visitor, optoutEnabled);
  return timeout(requests, visitorApiTimeout, TIMEOUT_MESSAGE)["catch"](
    handleError
  );
}

function getVisitorValues(visitor, optoutEnabled) {
  if (!isFunction(visitor.getVisitorValues)) {
    return {};
  }
  var fields = [MCMID, MCAAMB, MCAAMLH];
  if (optoutEnabled) {
    fields.push(MCOPTOUT);
  }
  var result = {};
  visitor.getVisitorValues(function(values) {
    return assign(result, values);
  }, fields);
  return result;
}
function getSyncValues(visitor, optoutEnabled) {
  if (isNil(visitor)) {
    return {};
  }
  return getVisitorValues(visitor, optoutEnabled);
}

function getVisitorInstance() {
  var config = getConfig();
  var imsOrgId = config[IMS_ORG_ID];
  var sdidParamExpiry = config[SUPPLEMENTAL_DATA_ID_PARAM_TIMEOUT];
  return getInstance(window, imsOrgId, sdidParamExpiry);
}
function getAsyncVisitorValues() {
  var visitor = getVisitorInstance();
  var config = getConfig();
  var visitorApiTimeout = config[VISITOR_API_TIMEOUT];
  var optoutEnabled = config[OPTOUT_ENABLED];
  return getAsyncValues(visitor, visitorApiTimeout, optoutEnabled);
}
function getSyncVisitorValues() {
  var visitor = getVisitorInstance();
  var config = getConfig();
  var optoutEnabled = config[OPTOUT_ENABLED];
  return getSyncValues(visitor, optoutEnabled);
}
function getCustomerIdsVisitorValues() {
  return getCustomerIds(getVisitorInstance());
}
function getSdidVisitorValue(consumerId) {
  return getSdid(getVisitorInstance(), consumerId);
}
function getVisitorProperty(property) {
  return getInstanceProperty(getVisitorInstance(), property);
}

var storage = {};
function setItem(key, value) {
  storage[key] = value;
}
function getItem(key) {
  return storage[key];
}

var LOG_PREFIX = "Data provider";
var TIMED_OUT = "timed out";
var MAX_TIMEOUT = 2000;
function areDataProvidersPresent(win) {
  var globalSettings = win[GLOBAL_SETTINGS];
  if (isNil(globalSettings)) {
    return false;
  }
  var dataProviders = globalSettings[DATA_PROVIDERS];
  if (!isArray(dataProviders) || isEmpty(dataProviders)) {
    return false;
  }
  return true;
}
function isValidDataProvider(dataProvider) {
  var name = dataProvider[NAME];
  if (!isString(name) || isEmpty(name)) {
    return false;
  }
  var version = dataProvider[VERSION];
  if (!isString(version) || isEmpty(version)) {
    return false;
  }
  var wait = dataProvider[TIMEOUT];
  if (!isNil(wait) && !isNumber(wait)) {
    return false;
  }
  var provider = dataProvider[PROVIDER];
  if (!isFunction(provider)) {
    return false;
  }
  return true;
}
function createPromise(provider) {
  return create(function(success, error) {
    provider(function(err, params) {
      if (!isNil(err)) {
        error(err);
        return;
      }
      success(params);
    });
  });
}
function createTrace(nameKey, name, versionKey, version, resKey, res) {
  var dataProviderTrace = {};
  dataProviderTrace[nameKey] = name;
  dataProviderTrace[versionKey] = version;
  dataProviderTrace[resKey] = res;
  var result = {};
  result[DATA_PROVIDER] = dataProviderTrace;
  return result;
}
function convertToPromise(dataProvider) {
  var name = dataProvider[NAME];
  var version = dataProvider[VERSION];
  var wait = dataProvider[TIMEOUT] || MAX_TIMEOUT;
  var provider = dataProvider[PROVIDER];
  var promise = createPromise(provider);
  return timeout(promise, wait, TIMED_OUT)
    .then(function(params) {
      var trace = createTrace(NAME, name, VERSION, version, PARAMS, params);
      logDebug(LOG_PREFIX, SUCCESS, trace);
      addClientTrace(trace);
      return params;
    })
    ["catch"](function(error) {
      var trace = createTrace(NAME, name, VERSION, version, ERROR, error);
      logDebug(LOG_PREFIX, ERROR, trace);
      addClientTrace(trace);
      return {};
    });
}
function collectParams(arr) {
  var result = reduce(
    function(acc, value) {
      return assign(acc, value);
    },
    {},
    arr
  );
  setItem(DATA_PROVIDERS, result);
  return result;
}
function executeAsyncDataProviders(win) {
  if (!areDataProvidersPresent(win)) {
    return resolve({});
  }
  var dataProviders = win[GLOBAL_SETTINGS][DATA_PROVIDERS];
  var validProviders = filter(isValidDataProvider, dataProviders);
  return all(map(convertToPromise, validProviders)).then(collectParams);
}
function executeSyncDataProviders() {
  var result = getItem(DATA_PROVIDERS);
  if (isNil(result)) {
    return {};
  }
  return result;
}

function getAsyncDataProvidersParameters() {
  return executeAsyncDataProviders(window);
}
function getSyncDataProvidersParameters() {
  return executeSyncDataProviders();
}

var TOKEN_PARAM = "authorization";
var TOKEN_COOKIE = "mboxDebugTools";
function getTokenFromQueryString(win) {
  var location = win.location;
  var search = location.search;
  var params = parseQueryString(search);
  var result = params[TOKEN_PARAM];
  if (isBlank(result)) {
    return null;
  }
  return result;
}
function getTokenFromCookie() {
  var result = getCookie(TOKEN_COOKIE);
  if (isBlank(result)) {
    return null;
  }
  return result;
}
function getTraceToken() {
  var param = getTokenFromQueryString(window);
  var cookie = getTokenFromCookie();
  return param || cookie;
}

function isPair(pair) {
  return !isEmpty(pair) && pair.length === 2 && isNotBlank(pair[0]);
}
function createPair$1(param) {
  var index = param.indexOf("=");
  if (index === -1) {
    return [];
  }
  return [param.substr(0, index), param.substr(index + 1)];
}
function objectToParamsInternal(obj, ks, result, keyFunc) {
  forEach(function(value, key) {
    if (isObject(value)) {
      ks.push(key);
      objectToParamsInternal(value, ks, result, keyFunc);
      ks.pop();
    } else if (isEmpty(ks)) {
      result[keyFunc(key)] = value;
    } else {
      result[keyFunc(join(".", ks.concat(key)))] = value;
    }
  }, obj);
}
function queryStringToParams(queryString) {
  return filter(function(value, key) {
    return isNotBlank(key);
  }, parseQueryString(queryString));
}
function arrayToParams(array) {
  var pairs = reduce(
    function(acc, param) {
      acc.push(createPair$1(param));
      return acc;
    },
    [],
    filter(isNotBlank, array)
  );
  return reduce(
    function(acc, pair) {
      acc[decode(trim(pair[0]))] = decode(trim(pair[1]));
      return acc;
    },
    {},
    filter(isPair, pairs)
  );
}
function objectToParams(object, keyFunc) {
  var result = {};
  if (isNil(keyFunc)) {
    objectToParamsInternal(object, [], result, identity);
  } else {
    objectToParamsInternal(object, [], result, keyFunc);
  }
  return result;
}
function functionToParams(func) {
  if (!isFunction(func)) {
    return {};
  }
  var params = null;
  try {
    params = func();
  } catch (_ignore) {
    return {};
  }
  if (isNil(params)) {
    return {};
  }
  if (isArray(params)) {
    return arrayToParams(params);
  }
  if (isString(params) && isNotBlank(params)) {
    return queryStringToParams(params);
  }
  if (isObject(params)) {
    return objectToParams(params);
  }
  return {};
}

function getParamsAll(mboxParams) {
  return assign({}, mboxParams, functionToParams(window.targetPageParamsAll));
}
function getParams(globalMboxParams) {
  return assign(
    {},
    globalMboxParams,
    functionToParams(window.targetPageParams)
  );
}
function getTargetPageParams(mbox) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var mboxParams = config[MBOX_PARAMS];
  var globalMboxParams = config[GLOBAL_MBOX_PARAMS];
  if (globalMbox !== mbox) {
    return getParamsAll(mboxParams || {});
  }
  return assign(
    getParamsAll(mboxParams || {}),
    getParams(globalMboxParams || {})
  );
}

function getWebGLRendererInternal() {
  var canvas = document.createElement("canvas");
  var gl =
    canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  if (isNil(gl)) {
    return null;
  }
  var glInfo = gl.getExtension("WEBGL_debug_renderer_info");
  if (isNil(glInfo)) {
    return null;
  }
  var result = gl.getParameter(glInfo.UNMASKED_RENDERER_WEBGL);
  if (isNil(result)) {
    return null;
  }
  return result;
}
var WEB_GL_RENDERER_INTERNAL = getWebGLRendererInternal();
function getPixelRatio() {
  var ratio = window.devicePixelRatio;
  if (!isNil(ratio)) {
    return ratio;
  }
  ratio = 1;
  var screen = window.screen;
  var systemXDPI = screen.systemXDPI,
    logicalXDPI = screen.logicalXDPI;
  if (!isNil(systemXDPI) && !isNil(logicalXDPI) && systemXDPI > logicalXDPI) {
    ratio = systemXDPI / logicalXDPI;
  }
  return ratio;
}
function getScreenOrientation() {
  var screen = window.screen;
  var orientation = screen.orientation,
    width = screen.width,
    height = screen.height;
  if (isNil(orientation)) {
    return width > height ? "landscape" : "portrait";
  }
  if (isNil(orientation.type)) {
    return null;
  }
  var parts = split("-", orientation.type);
  if (isEmpty(parts)) {
    return null;
  }
  var result = parts[0];
  if (!isNil(result)) {
    return result;
  }
  return null;
}
function getWebGLRenderer() {
  return WEB_GL_RENDERER_INTERNAL;
}

var PROFILE_PREFIX = "profile.";
var THIRD_PARTY_ID = "mbox3rdPartyId";
var PROPERTY_TOKEN = "at_property";
var ORDER_ID = "orderId";
var ORDER_TOTAL = "orderTotal";
var PRODUCT_PURCHASED_ID = "productPurchasedId";
var PRODUCT_ID = "productId";
var CATEGORY_ID = "categoryId";
function isThirdPartyId(param) {
  return param === THIRD_PARTY_ID;
}
function isProfileParam(param) {
  return param.indexOf(PROFILE_PREFIX) !== -1;
}
function isPropertyToken(param) {
  return param === PROPERTY_TOKEN;
}
function isOrderId(param) {
  return param === ORDER_ID;
}
function isOrderTotal(param) {
  return param === ORDER_TOTAL;
}
function isProductPurchasedId(param) {
  return param === PRODUCT_PURCHASED_ID;
}
function isProductId(param) {
  return param === PRODUCT_ID;
}
function isCategoryId(param) {
  return param === CATEGORY_ID;
}
function isSpecialParam(param) {
  return (
    isProfileParam(param) ||
    isThirdPartyId(param) ||
    isPropertyToken(param) ||
    isOrderId(param) ||
    isOrderTotal(param) ||
    isProductPurchasedId(param) ||
    isProductId(param) ||
    isCategoryId(param)
  );
}
function extractProfileParam(param) {
  return param.substring(PROFILE_PREFIX.length);
}
function getThirdPartyId(parameters) {
  return parameters[THIRD_PARTY_ID];
}
function getPropertyToken(params) {
  return params[PROPERTY_TOKEN];
}
function getOrderId(params) {
  return params[ORDER_ID];
}
function getOrderTotal(params) {
  return params[ORDER_TOTAL];
}
function getPurchasedProductIds(params) {
  var value = params[PRODUCT_PURCHASED_ID];
  var result = map(trim, split(",", value));
  return filter(isNotBlank, result);
}
function getProductId(params) {
  return params[PRODUCT_ID];
}
function getCategoryId(params) {
  return params[CATEGORY_ID];
}
function getParams$1(params) {
  return reduce(
    function(acc, value, key) {
      if (isSpecialParam(key)) {
        return acc;
      }
      acc[key] = isNil(value) ? "" : value;
      return acc;
    },
    {},
    params
  );
}
function getProfileParams(params) {
  return reduce(
    function(acc, value, key) {
      if (!isProfileParam(key)) {
        return acc;
      }
      var profileKey = extractProfileParam(key);
      if (isBlank(profileKey)) {
        return acc;
      }
      acc[profileKey] = isNil(value) ? "" : value;
      return acc;
    },
    {},
    params
  );
}

var POST = "POST";
var NETWORK_ERROR = "Network request failed";
var REQUEST_TIMEOUT = "Request timed out";
var MALFORMED_RESPONSE = "Malformed response JSON";
function addOnload(xhr, resolve, reject) {
  xhr.onload = function() {
    var status = xhr.status === 1223 ? 204 : xhr.status;
    if (status < 100 || status > 599) {
      reject(new Error(NETWORK_ERROR));
      return;
    }
    var response;
    try {
      response = JSON.parse(xhr.responseText);
    } catch (e) {
      reject(new Error(MALFORMED_RESPONSE));
      return;
    }
    var headers = xhr.getAllResponseHeaders();
    resolve({
      status: status,
      headers: headers,
      response: response
    });
  };
  return xhr;
}
function addOnerror(xhr, reject) {
  xhr.onerror = function() {
    reject(new Error(NETWORK_ERROR));
  };
  return xhr;
}
function addOntimeout(xhr, timeout, reject) {
  xhr.timeout = timeout;
  xhr.ontimeout = function() {
    reject(new Error(REQUEST_TIMEOUT));
  };
  return xhr;
}
function addHeaders(xhr) {
  var headers =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  forEach(function(values, key) {
    if (!isArray(values)) {
      return;
    }
    forEach(function(value) {
      xhr.setRequestHeader(key, value);
    }, values);
  }, headers);
  return xhr;
}
function executeXhr(_ref) {
  var url = _ref.url,
    headers = _ref.headers,
    body = _ref.body,
    timeout = _ref.timeout,
    async = _ref.async;
  return create(function(resolve, reject) {
    var xhr = new window.XMLHttpRequest();
    xhr = addOnload(xhr, resolve, reject);
    xhr = addOnerror(xhr, reject);
    xhr.open(POST, url, async);
    xhr.withCredentials = true;
    xhr = addHeaders(xhr, headers);
    if (async) {
      xhr = addOntimeout(xhr, timeout, reject);
    }
    xhr.send(JSON.stringify(body));
  }).then(function(xhrResponse) {
    var response = xhrResponse.response;
    var status = response.status,
      message = response.message;
    if (!isNil(status) && !isNil(message)) {
      throw new Error(message);
    }
    return response;
  });
}

var EDGE_SERVER_PREFIX = "mboxedge";
var EDGE_SERVER_DOMAIN = ".tt.omtrdc.net";
var notEmpty = function notEmpty(val) {
  return !isEmpty(val);
};
function throwIfOptout(values) {
  var optout = values[MCOPTOUT];
  if (optout) {
    throw new Error(OPTOUT_MESSAGE);
  }
  return values;
}
function getAsyncThirdPartyData() {
  var visitorValues = getAsyncVisitorValues();
  var dataProvidersParams = getAsyncDataProvidersParameters();
  return all([visitorValues.then(throwIfOptout), dataProvidersParams]);
}
function getSyncThirdPartyData() {
  var visitorValues = getSyncVisitorValues();
  var dataProvidersParams = getSyncDataProvidersParameters();
  return [visitorValues, dataProvidersParams];
}
function getAllParams(providersParams) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  return assign({}, providersParams, getTargetPageParams(globalMbox));
}
function getTimeOffset() {
  return -new Date().getTimezoneOffset();
}
function createScreen() {
  var screen = window.screen;
  return {
    width: screen.width,
    height: screen.height,
    orientation: getScreenOrientation(),
    colorDepth: screen.colorDepth,
    pixelRatio: getPixelRatio()
  };
}
function createWindow() {
  var documentElement = document.documentElement;
  return {
    width: documentElement.clientWidth,
    height: documentElement.clientHeight
  };
}
function createBrowser() {
  var location = window.location;
  return {
    host: location.hostname,
    webGLRenderer: getWebGLRenderer()
  };
}
function createAddress() {
  var location = window.location;
  return {
    url: location.href,
    referringUrl: document.referrer
  };
}
function createContext(context) {
  if (!isNil(context) && context.channel === WEB_CHANNEL) {
    return context;
  }
  var validContext = context || {};
  var beacon = validContext.beacon;
  return {
    userAgent: window.navigator.userAgent,
    timeOffsetInMinutes: getTimeOffset(),
    channel: WEB_CHANNEL,
    screen: createScreen(),
    window: createWindow(),
    browser: createBrowser(),
    address: createAddress(),
    geo: context && context.geo,
    beacon: beacon
  };
}
function createAudienceManager(audienceManager, visitorValues) {
  if (!isNil(audienceManager)) {
    return audienceManager;
  }
  var result = {};
  if (isEmpty(visitorValues)) {
    return result;
  }
  var locationHint = visitorValues[MCAAMLH];
  var locationHintNumber = parseInt(locationHint, 10);
  if (!isNaN(locationHintNumber)) {
    result.locationHint = locationHintNumber;
  }
  var blob = visitorValues[MCAAMB];
  if (isNotBlank(blob)) {
    result.blob = blob;
  }
  return result;
}
function createCustomerId(data) {
  var id = data.id,
    integrationCode = data.integrationCode,
    authenticatedState = data.authenticatedState,
    type = data.type,
    primary = data.primary;
  var result = {};
  if (isNotBlank(id)) {
    result.id = id;
  }
  if (isNotBlank(integrationCode)) {
    result.integrationCode = integrationCode;
  }
  if (isNotBlank(authenticatedState)) {
    result.authenticatedState = authenticatedState;
  }
  if (isNotBlank(type)) {
    result.type = type;
  }
  if (primary) {
    result.primary = primary;
  }
  return result;
}
function createCustomerIds(customerIdsValues) {
  return map(createCustomerId, customerIdsValues);
}
function createVisitorId(
  id,
  deviceId,
  thirdPartyId,
  visitorValues,
  customerIdsValues
) {
  var result = {};
  if (isNotBlank(deviceId)) {
    result.tntId = deviceId;
  }
  if (isNotBlank(thirdPartyId)) {
    result.thirdPartyId = thirdPartyId;
  }
  if (isNotBlank(id.thirdPartyId)) {
    result.thirdPartyId = id.thirdPartyId;
  }
  var mid = visitorValues[MCMID];
  if (isNotBlank(mid)) {
    result.marketingCloudVisitorId = mid;
  }
  if (isNotBlank(id.marketingCloudVisitorId)) {
    result.marketingCloudVisitorId = id.marketingCloudVisitorId;
  }
  if (!isEmpty(id.customerIds)) {
    result.customerIds = id.customerIds;
    return result;
  }
  if (!isEmpty(customerIdsValues)) {
    result.customerIds = createCustomerIds(customerIdsValues);
  }
  return result;
}
function createExperienceCloud(experienceCloud, visitorValues) {
  var result = {};
  var audienceManager = createAudienceManager(
    experienceCloud.audienceManager,
    visitorValues
  );
  if (!isEmpty(audienceManager)) {
    result.audienceManager = audienceManager;
  }
  if (!isEmpty(experienceCloud.analytics)) {
    result.analytics = experienceCloud.analytics;
  }
  return result;
}
function createProperty(property, allParams) {
  if (!isNil(property) && isNotBlank(property.token)) {
    return property;
  }
  var result = {};
  var token = getPropertyToken(allParams);
  if (isNotBlank(token)) {
    result.token = token;
  }
  return result;
}
function createTrace$1(trace) {
  if (!isNil(trace) && isNotBlank(trace.authorizationToken)) {
    return trace;
  }
  var result = {};
  var authorizationToken = getTraceToken();
  if (isNotBlank(authorizationToken)) {
    result.authorizationToken = authorizationToken;
  }
  return result;
}
function createPreview(preview) {
  if (!isNil(preview)) {
    return preview;
  }
  return getPreview();
}
function createQaMode(qaMode) {
  if (!isNil(qaMode)) {
    return qaMode;
  }
  return getQaMode();
}
function createOrder(params) {
  var result = {};
  var orderId = getOrderId(params);
  if (!isNil(orderId)) {
    result.id = orderId;
  }
  var orderTotal = getOrderTotal(params);
  var orderTotalNumber = parseFloat(orderTotal);
  if (!isNaN(orderTotalNumber)) {
    result.total = orderTotalNumber;
  }
  var purchasedProductIds = getPurchasedProductIds(params);
  if (!isEmpty(purchasedProductIds)) {
    result.purchasedProductIds = purchasedProductIds;
  }
  return result;
}
function createProduct(params) {
  var result = {};
  var productId = getProductId(params);
  if (!isNil(productId)) {
    result.id = productId;
  }
  var categoryId = getCategoryId(params);
  if (!isNil(categoryId)) {
    result.categoryId = categoryId;
  }
  return result;
}
function createRequestDetails(item, allParams) {
  var result = {};
  var params = assign({}, getParams$1(allParams), item.parameters || {});
  var profileParams = assign(
    {},
    getProfileParams(allParams),
    item.profileParameters || {}
  );
  var order = assign({}, createOrder(allParams), item.order || {});
  var product = assign({}, createProduct(allParams), item.product || {});
  if (!isEmpty(params)) {
    result.parameters = params;
  }
  if (!isEmpty(profileParams)) {
    result.profileParameters = profileParams;
  }
  if (!isEmpty(order)) {
    result.order = order;
  }
  if (!isEmpty(product)) {
    result.product = product;
  }
  return result;
}
function createMboxRequestDetails(item, allParams) {
  var providersParams =
    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var index = item.index,
    name = item.name,
    address = item.address;
  var params = assign(
    {},
    name === globalMbox ? allParams : providersParams,
    getTargetPageParams(name)
  );
  var result = createRequestDetails(item, params);
  if (!isNil(index)) {
    result.index = index;
  }
  if (isNotBlank(name)) {
    result.name = name;
  }
  if (!isEmpty(address)) {
    result.address = address;
  }
  return result;
}
function createViewRequestDetails(item, allParams) {
  var name = item.name,
    address = item.address;
  var result = createRequestDetails(item, allParams);
  if (isNotBlank(name)) {
    result.name = name;
  }
  if (!isEmpty(address)) {
    result.address = address;
  }
  return result;
}
function createExecute(request, allParams, providersParams) {
  var _request$execute = request.execute,
    execute = _request$execute === void 0 ? {} : _request$execute;
  var result = {};
  if (isEmpty(execute)) {
    return result;
  }
  var pageLoad = execute.pageLoad;
  if (!isNil(pageLoad)) {
    result.pageLoad = createRequestDetails(pageLoad, allParams);
  }
  var mboxes = execute.mboxes;
  if (!isNil(mboxes) && isArray(mboxes) && !isEmpty(mboxes)) {
    var temp = filter(
      notEmpty,
      map(function(e) {
        return createMboxRequestDetails(e, allParams, providersParams);
      }, mboxes)
    );
    if (!isEmpty(temp)) {
      result.mboxes = temp;
    }
  }
  return result;
}
function createPrefetch(request, allParams, providersParams) {
  var _request$prefetch = request.prefetch,
    prefetch = _request$prefetch === void 0 ? {} : _request$prefetch;
  var result = {};
  if (isEmpty(prefetch)) {
    return result;
  }
  var mboxes = prefetch.mboxes;
  if (!isNil(mboxes) && isArray(mboxes) && !isEmpty(mboxes)) {
    result.mboxes = map(function(e) {
      return createMboxRequestDetails(e, allParams, providersParams);
    }, mboxes);
  }
  var views = prefetch.views;
  if (!isNil(views) && isArray(views) && !isEmpty(views)) {
    result.views = map(function(e) {
      return createViewRequestDetails(e, allParams);
    }, views);
  }
  return result;
}
function createAnalytics(consumerId, request) {
  if (shouldUseOptin() && !isAnalyticsApproved()) {
    return null;
  }
  var config = getConfig();
  var sdid = getSdidVisitorValue(consumerId);
  var server = getVisitorProperty(TRACK_SERVER_PROP);
  var serverSecure = getVisitorProperty(TRACK_SERVER_SECURE_PROP);
  var _request$experienceCl = request.experienceCloud,
    experienceCloud =
      _request$experienceCl === void 0 ? {} : _request$experienceCl;
  var _experienceCloud$anal = experienceCloud.analytics,
    analytics = _experienceCloud$anal === void 0 ? {} : _experienceCloud$anal;
  var logging = analytics.logging,
    supplementalDataId = analytics.supplementalDataId,
    trackingServer = analytics.trackingServer,
    trackingServerSecure = analytics.trackingServerSecure;
  var result = {};
  if (!isNil(logging)) {
    result.logging = logging;
  } else {
    result.logging = config[ANALYTICS_LOGGING];
  }
  if (!isNil(supplementalDataId)) {
    result.supplementalDataId = supplementalDataId;
  }
  if (isNotBlank(sdid)) {
    result.supplementalDataId = sdid;
  }
  if (!isNil(trackingServer)) {
    result.trackingServer = trackingServer;
  }
  if (isNotBlank(server)) {
    result.trackingServer = server;
  }
  if (!isNil(trackingServerSecure)) {
    result.trackingServerSecure = trackingServerSecure;
  }
  if (isNotBlank(serverSecure)) {
    result.trackingServerSecure = serverSecure;
  }
  if (isEmpty(result)) {
    return null;
  }
  return result;
}
function createDeliveryRequest(request, visitorValues, providersParams) {
  var allParams = getAllParams(providersParams);
  var deviceId = getDeviceId();
  var thirdPartyId = getThirdPartyId(allParams);
  var customerIdsValues = getCustomerIdsVisitorValues();
  var visitorId = createVisitorId(
    request.id || {},
    deviceId,
    thirdPartyId,
    visitorValues,
    customerIdsValues
  );
  var property = createProperty(request.property, allParams);
  var experienceCloud = createExperienceCloud(
    request.experienceCloud || {},
    visitorValues
  );
  var trace = createTrace$1(request.trace);
  var preview = createPreview(request.preview);
  var qaMode = createQaMode(request.qaMode);
  var execute = createExecute(request, allParams, providersParams);
  var prefetch = createPrefetch(request, allParams, providersParams);
  var notifications = request.notifications;
  var result = {};
  result.requestId = uuid();
  result.context = createContext(request.context);
  if (!isEmpty(visitorId)) {
    result.id = visitorId;
  }
  if (!isEmpty(property)) {
    result.property = property;
  }
  if (!isEmpty(trace)) {
    result.trace = trace;
  }
  if (!isEmpty(experienceCloud)) {
    result.experienceCloud = experienceCloud;
  }
  if (!isEmpty(preview)) {
    result.preview = preview;
  }
  if (!isEmpty(qaMode)) {
    result.qaMode = qaMode;
  }
  if (!isEmpty(execute)) {
    result.execute = execute;
  }
  if (!isEmpty(prefetch)) {
    result.prefetch = prefetch;
  }
  if (!isEmpty(notifications)) {
    result.notifications = notifications;
  }
  return result;
}
function buildRequest(request, params, data) {
  var visitorValues = data[0];
  var providersValues = data[1];
  var providersParams = assign({}, providersValues, params);
  return createDeliveryRequest(request, visitorValues, providersParams);
}
function createAsyncDeliveryRequest(request, params) {
  return getAsyncThirdPartyData().then(function(data) {
    return buildRequest(request, params, data);
  });
}
function createSyncDeliveryRequest(request, params) {
  var data = getSyncThirdPartyData();
  return buildRequest(request, params, data);
}
function getTimeout(config, timeout) {
  if (!isNumber(timeout)) {
    return config[TIMEOUT];
  }
  if (timeout < 0) {
    return config[TIMEOUT];
  }
  return timeout;
}
function getServerDomain(config) {
  var serverDomain = config[SERVER_DOMAIN];
  var overrideMboxEdgeServer = config[OVERRIDE_MBOX_EDGE_SERVER];
  if (!overrideMboxEdgeServer) {
    return serverDomain;
  }
  var cluster = getEdgeCluster();
  if (isBlank(cluster)) {
    return serverDomain;
  }
  return "" + EDGE_SERVER_PREFIX + cluster + EDGE_SERVER_DOMAIN;
}
function createRequestUrl(config) {
  var scheme = config[SCHEME];
  var host = getServerDomain(config);
  var path = config[ENDPOINT];
  var client = config[CLIENT_CODE];
  var sessionId = getSessionId();
  var version = config[VERSION];
  var queryString = stringifyQueryString({
    client: client,
    sessionId: sessionId,
    version: version
  });
  return scheme + "//" + host + path + "?" + queryString;
}
function executeDeliveryRequest(request, requestTimeout) {
  var config = getConfig();
  var url = createRequestUrl(config);
  var headers = _defineProperty({}, CONTENT_TYPE, [TEXT_PLAIN]);
  var timeout = getTimeout(config, requestTimeout);
  var async = true;
  var options = {
    url: url,
    headers: headers,
    body: request,
    timeout: timeout,
    async: async
  };
  return executeXhr(options).then(function(response) {
    return assign(response, {
      decisioningMethod: DECISIONING_METHOD.SERVER_SIDE
    });
  });
}
function executeRequest(options, request, requestTimeout) {
  logDebug(REQUEST, request);
  addClientTrace({
    request: request
  });
  return executeDeliveryRequest(request, requestTimeout).then(function(
    response
  ) {
    logDebug(RESPONSE, response);
    addClientTrace({
      response: response
    });
    return {
      request: request,
      response: response
    };
  });
}

var prop = function prop(key) {
  return function(obj) {
    return obj[key];
  };
};
var not = function not(pred) {
  return function(val) {
    return !pred(val);
  };
};
var notNil = not(isNil);
var notBlank = not(isBlank);
var filterBy = function filterBy(pred) {
  return function(coll) {
    return filter(pred, coll);
  };
};
var isError = function isError(val) {
  return val.status === ERROR;
};
var isActions = function isActions(val) {
  return val.type === ACTIONS;
};
var isRedirect = function isRedirect(val) {
  return val.type === REDIRECT;
};
var filterNotNil = filterBy(notNil);
var filterNotBlank = filterBy(notBlank);
var selectOptions = prop(OPTIONS);
var selectContent = prop(CONTENT);
var selectResponseTokens = prop(RESPONSE_TOKENS);
var hasName = function hasName(val) {
  return isNotBlank(val.name);
};
var hasIndex = function hasIndex(val) {
  return !isNil(val.index);
};
var isValidMbox = function isValidMbox(val) {
  return isObject(val) && hasName(val);
};
var isValidPrefetchMbox = function isValidPrefetchMbox(val) {
  return isObject(val) && hasName(val) && hasIndex(val);
};
var isValidView = function isValidView(val) {
  return isObject(val) && hasName(val);
};
var hasSelector = function hasSelector(val) {
  return isNotBlank(val.selector);
};
var selectData = prop(DATA);
var hasData = flow([selectData, notNil]);
function createSuccess(type, data) {
  return {
    status: SUCCESS,
    type: type,
    data: data
  };
}
function createError(type, data) {
  return {
    status: ERROR,
    type: type,
    data: data
  };
}
function isValidOption(option) {
  return isObject(option);
}
function isValidOptionEventToken(option) {
  if (!isValidOption(option)) {
    return false;
  }
  return isNotBlank(option.eventToken);
}
function isValidMetric(metric) {
  if (isEmpty(metric) || isBlank(metric.type)) {
    return false;
  }
  return isNotBlank(metric.eventToken);
}
function isValidSelectorMetric(metric) {
  if (!isValidMetric(metric)) {
    return false;
  }
  return isNotBlank(metric.selector);
}

function hasDeviceId(res) {
  var id = res.id;
  return isObject(id) && isNotBlank(id.tntId);
}
function handleDeviceId(context) {
  var response = context.response;
  if (hasDeviceId(response)) {
    setDeviceId(response.id.tntId);
  }
  return context;
}

function handleEdgeCluster(context) {
  var response = context.response;
  if (hasDeviceId(response)) {
    var id = response.id;
    var tntId = id.tntId;
    setEdgeCluster(tntId);
  }
  setEdgeCluster(null);
  return context;
}

function addTraceIfExists() {
  var item =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var trace = item.trace;
  if (!isEmpty(trace)) {
    addServerTrace(trace);
  }
}
function handleTraces(httpContext) {
  var response = httpContext.response;
  var _response$execute = response.execute,
    execute = _response$execute === void 0 ? {} : _response$execute,
    _response$prefetch = response.prefetch,
    prefetch = _response$prefetch === void 0 ? {} : _response$prefetch;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad,
    _execute$mboxes = execute.mboxes,
    mboxes = _execute$mboxes === void 0 ? [] : _execute$mboxes;
  var _prefetch$mboxes = prefetch.mboxes,
    prefetchMboxes = _prefetch$mboxes === void 0 ? [] : _prefetch$mboxes,
    _prefetch$views = prefetch.views,
    views = _prefetch$views === void 0 ? [] : _prefetch$views;
  addTraceIfExists(pageLoad);
  forEach(addTraceIfExists, mboxes);
  forEach(addTraceIfExists, prefetchMboxes);
  forEach(addTraceIfExists, views);
  return httpContext;
}

var SDID_PARAM = "adobe_mc_sdid";
function getRedirectUriParams(uri) {
  var result = uri.queryKey;
  var param = result[SDID_PARAM];
  if (!isString(param)) {
    return result;
  }
  if (isBlank(param)) {
    return result;
  }
  var nowInSeconds = Math.round(now() / 1000);
  result[SDID_PARAM] = param.replace(/\|TS=\d+/, "|TS=" + nowInSeconds);
  return result;
}
function getUriParams(uri) {
  return uri.queryKey;
}
function createUrlInternal(url, params, uriParamsFunc) {
  var parsedUri = parseUri$1(url);
  var protocol = parsedUri.protocol;
  var host = parsedUri.host;
  var path = parsedUri.path;
  var port = parsedUri.port === "" ? "" : ":" + parsedUri.port;
  var anchor = isBlank(parsedUri.anchor) ? "" : "#" + parsedUri.anchor;
  var uriParams = uriParamsFunc(parsedUri);
  var queryString = stringifyQueryString(assign({}, uriParams, params));
  var query = isBlank(queryString) ? "" : "?" + queryString;
  return protocol + "://" + host + port + path + query + anchor;
}
function createRedirectUrl(url, params) {
  return createUrlInternal(url, params, getRedirectUriParams);
}
function createUrl(url, params) {
  return createUrlInternal(url, params, getUriParams);
}

function createRedirectOption(option) {
  var url = option.content;
  if (isBlank(url)) {
    logDebug(EMPTY_URL, option);
    return null;
  }
  var result = assign({}, option);
  result.content = createRedirectUrl(url, {});
  return result;
}

var NETWORK_ERROR$1 = "Network request failed";
var REQUEST_TIMEOUT$1 = "Request timed out";
var URL_REQUIRED = "URL is required";
var GET = "GET";
var POST$1 = "POST";
var METHOD = "method";
var URL = "url";
var HEADERS = "headers";
var DATA$1 = "data";
var CREDENTIALS = "credentials";
var TIMEOUT$1 = "timeout";
var ASYNC = "async";
function throwError(message) {
  throw new Error(message);
}
function processOptions(options) {
  var method = options[METHOD] || GET;
  var url = options[URL] || throwError(URL_REQUIRED);
  var headers = options[HEADERS] || {};
  var data = options[DATA$1] || null;
  var credentials = options[CREDENTIALS] || false;
  var timeout = options[TIMEOUT$1] || 3000;
  var async = isNil(options[ASYNC]) ? true : options[ASYNC] === true;
  var result = {};
  result[METHOD] = method;
  result[URL] = url;
  result[HEADERS] = headers;
  result[DATA$1] = data;
  result[CREDENTIALS] = credentials;
  result[TIMEOUT$1] = timeout;
  result[ASYNC] = async;
  return result;
}
function addOnload$1(xhr, resolve, reject) {
  xhr.onload = function() {
    var status = xhr.status === 1223 ? 204 : xhr.status;
    if (status < 100 || status > 599) {
      reject(new Error(NETWORK_ERROR$1));
      return;
    }
    var response = xhr.responseText;
    var headers = xhr.getAllResponseHeaders();
    var result = {
      status: status,
      headers: headers,
      response: response
    };
    resolve(result);
  };
  return xhr;
}
function addOnerror$1(xhr, reject) {
  xhr.onerror = function() {
    reject(new Error(NETWORK_ERROR$1));
  };
  return xhr;
}
function addOntimeout$1(xhr, timeout, reject) {
  xhr.timeout = timeout;
  xhr.ontimeout = function() {
    reject(new Error(REQUEST_TIMEOUT$1));
  };
  return xhr;
}
function addCredentials(xhr, credentials) {
  if (credentials === true) {
    xhr.withCredentials = credentials;
  }
  return xhr;
}
function addHeaders$1(xhr, headers) {
  forEach(function(value, key) {
    forEach(function(v) {
      return xhr.setRequestHeader(key, v);
    }, value);
  }, headers);
  return xhr;
}
function createXhrPromise(win, opts) {
  var options = processOptions(opts);
  var method = options[METHOD];
  var url = options[URL];
  var headers = options[HEADERS];
  var data = options[DATA$1];
  var credentials = options[CREDENTIALS];
  var timeout = options[TIMEOUT$1];
  var async = options[ASYNC];
  return create(function(resolve, reject) {
    var xhr = new win.XMLHttpRequest();
    xhr = addOnload$1(xhr, resolve, reject);
    xhr = addOnerror$1(xhr, reject);
    xhr.open(method, url, async);
    xhr = addCredentials(xhr, credentials);
    xhr = addHeaders$1(xhr, headers);
    if (async) {
      xhr = addOntimeout$1(xhr, timeout, reject);
    }
    xhr.send(data);
  });
}

function xhr(options) {
  return createXhrPromise(window, options);
}

function createOptions(url, params, timeout) {
  var result = {};
  result[METHOD] = GET;
  result[URL] = createUrl(url, params);
  result[TIMEOUT$1] = timeout;
  return result;
}
function isSuccess(status) {
  return (status >= 200 && status < 300) || status === 304;
}
function createOption(res) {
  var status = res.status;
  if (!isSuccess(status)) {
    return null;
  }
  var content = res.response;
  if (isBlank(content)) {
    return null;
  }
  var result = {};
  result.type = HTML;
  result.content = content;
  return result;
}
function createHtmlOption(option) {
  var content = option.content;
  var config = getConfig();
  var timeout = config[TIMEOUT$1];
  return xhr(createOptions(content, {}, timeout))
    .then(createOption)
    ["catch"](function() {
      return null;
    });
}

var CLICK_TRACK_PATTERN = /CLKTRK#(\S+)/;
var CLICK_TRACK_REPLACE_PATTERN = /CLKTRK#(\S+)\s/;
function getClickTrackNodeId(action) {
  var selector = action[SELECTOR];
  if (isBlank(selector)) {
    return "";
  }
  var result = CLICK_TRACK_PATTERN.exec(selector);
  if (isEmpty(result) || result.length !== 2) {
    return "";
  }
  return result[1];
}
function getContent(id, content) {
  var div = document.createElement(DIV_TAG);
  div.innerHTML = content;
  var firstElement = div.firstElementChild;
  if (isNil(firstElement)) {
    return content;
  }
  firstElement.id = id;
  return firstElement.outerHTML;
}
function processClickTrackId(action) {
  var content = action[CONTENT];
  var nodeId = getClickTrackNodeId(action);
  if (isBlank(nodeId) || isBlank(content)) {
    return action;
  }
  var selector = action[SELECTOR];
  action[SELECTOR] = selector.replace(CLICK_TRACK_REPLACE_PATTERN, "");
  action[CONTENT] = getContent(nodeId, content);
  return action;
}

var notNull$1 = function notNull(val) {
  return !isNil(val);
};
function hasSelector$1(action) {
  var selector = action.selector;
  return !isNil(selector);
}
function setHtml$1(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function setText$1(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function appendHtml(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function prependHtml(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function replaceHtml(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function insertBefore(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function insertAfter(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var result = processClickTrackId(action);
  var content = result[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, result);
    return null;
  }
  return result;
}
function customCode(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_CONTENT, action);
    return null;
  }
  return action;
}
function setAttribute(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isObject(content)) {
    logDebug(EMPTY_ATTRIBUTE, action);
    return null;
  }
  return action;
}
function setImageSource(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isString(content)) {
    logDebug(EMPTY_IMAGE_URL, action);
    return null;
  }
  return action;
}
function setStyle(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isObject(content)) {
    logDebug(EMPTY_PROPERTY, action);
    return null;
  }
  return action;
}
function resize(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isObject(content)) {
    logDebug(EMPTY_SIZES, action);
    return null;
  }
  return action;
}
function move(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isObject(content)) {
    logDebug(EMPTY_COORDINATES, action);
    return null;
  }
  return action;
}
function remove$1(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  return action;
}
function rearrange(action) {
  if (!hasSelector$1(action)) {
    return null;
  }
  var content = action[CONTENT];
  if (!isObject(content)) {
    logDebug(EMPTY_REARRANGE, action);
    return null;
  }
  return action;
}
function redirect(action) {
  var content = action.content;
  if (isBlank(content)) {
    logDebug(EMPTY_URL, action);
    return null;
  }
  action.content = createRedirectUrl(content, {});
  return action;
}
function processAction(action) {
  var type = action[TYPE];
  if (isBlank(type)) {
    return null;
  }
  switch (type) {
    case SET_HTML:
      return setHtml$1(action);
    case SET_TEXT:
      return setText$1(action);
    case APPEND_HTML:
      return appendHtml(action);
    case PREPEND_HTML:
      return prependHtml(action);
    case REPLACE_HTML:
      return replaceHtml(action);
    case INSERT_BEFORE:
      return insertBefore(action);
    case INSERT_AFTER:
      return insertAfter(action);
    case CUSTOM_CODE:
      return customCode(action);
    case SET_ATTRIBUTE:
      return setAttribute(action);
    case SET_IMAGE_SOURCE:
      return setImageSource(action);
    case SET_STYLE:
      return setStyle(action);
    case RESIZE:
      return resize(action);
    case MOVE:
      return move(action);
    case REMOVE:
      return remove$1(action);
    case REARRANGE:
      return rearrange(action);
    case REDIRECT:
      return redirect(action);
    default:
      return null;
  }
}
function createActionsOption(option) {
  var actions = option[CONTENT];
  if (!isArray(actions)) {
    return null;
  }
  if (isEmpty(actions)) {
    return null;
  }
  var processedActions = filter(notNull$1, map(processAction, actions));
  if (isEmpty(processedActions)) {
    return null;
  }
  var result = assign({}, option);
  result.content = processedActions;
  return result;
}

function getTokens() {
  var value =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = value.options;
  if (!isArray(options)) {
    return [];
  }
  if (isEmpty(options)) {
    return [];
  }
  return filterNotNil(map(selectResponseTokens, options));
}
function getResponseTokens() {
  var response =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _response$execute = response.execute,
    execute = _response$execute === void 0 ? {} : _response$execute,
    _response$prefetch = response.prefetch,
    prefetch = _response$prefetch === void 0 ? {} : _response$prefetch;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad,
    _execute$mboxes = execute.mboxes,
    mboxes = _execute$mboxes === void 0 ? [] : _execute$mboxes;
  var _prefetch$mboxes = prefetch.mboxes,
    prefetchMboxes = _prefetch$mboxes === void 0 ? [] : _prefetch$mboxes,
    _prefetch$views = prefetch.views,
    views = _prefetch$views === void 0 ? [] : _prefetch$views;
  var pageLoadTokens = getTokens(pageLoad);
  var mboxesTokens = flatten(map(getTokens, mboxes));
  var prefetchMboxesTokens = flatten(map(getTokens, prefetchMboxes));
  var viewsTokens = flatten(map(getTokens, views));
  return flatten([
    pageLoadTokens,
    mboxesTokens,
    prefetchMboxesTokens,
    viewsTokens
  ]);
}

function getRedirect() {
  var response =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _response$execute = response.execute,
    execute = _response$execute === void 0 ? {} : _response$execute;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad,
    _execute$mboxes = execute.mboxes,
    mboxes = _execute$mboxes === void 0 ? [] : _execute$mboxes;
  var pageLoadOpts = selectOptions(pageLoad) || [];
  var mboxesOpts = flatten(filterNotNil(map(selectOptions, mboxes)));
  var options = flatten([pageLoadOpts, mboxesOpts]);
  var actions = flatten(map(selectContent, filter(isActions, options)));
  var redirectOptions = filter(isRedirect, options);
  var redirectActions = filter(isRedirect, actions);
  var redirects = redirectOptions.concat(redirectActions);
  var result = {};
  if (isEmpty(redirects)) {
    return result;
  }
  var redirect = redirects[0];
  var url = redirect.content;
  if (isBlank(url)) {
    return result;
  }
  result.url = url;
  return result;
}

function getAnalytics() {
  var item =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var analytics = item.analytics;
  return isEmpty(analytics) ? [] : [analytics];
}
function getAnalyticsDetails() {
  var response =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _response$execute = response.execute,
    execute = _response$execute === void 0 ? {} : _response$execute,
    _response$prefetch = response.prefetch,
    prefetch = _response$prefetch === void 0 ? {} : _response$prefetch;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad,
    _execute$mboxes = execute.mboxes,
    mboxes = _execute$mboxes === void 0 ? [] : _execute$mboxes;
  var _prefetch$mboxes = prefetch.mboxes,
    prefetchMboxes = _prefetch$mboxes === void 0 ? [] : _prefetch$mboxes,
    _prefetch$views = prefetch.views,
    views = _prefetch$views === void 0 ? [] : _prefetch$views;
  var pageLoadDetails = getAnalytics(pageLoad);
  var mboxesDetails = flatten(map(getAnalytics, mboxes));
  var prefetchMboxesDetails = flatten(map(getAnalytics, prefetchMboxes));
  var viewsDetails = flatten(map(getAnalytics, views));
  return flatten([
    pageLoadDetails,
    mboxesDetails,
    prefetchMboxesDetails,
    viewsDetails
  ]);
}

function addContextDetails(to, from) {
  to.parameters = from.parameters;
  to.profileParameters = from.profileParameters;
  to.order = from.order;
  to.product = from.product;
}
function addOptionsAndMetrics(result, arr) {
  var options = arr[0];
  var metrics = arr[1];
  var hasOptions = !isEmpty(options);
  var hasMetrics = !isEmpty(metrics);
  if (!hasOptions && !hasMetrics) {
    return result;
  }
  if (hasOptions) {
    result.options = options;
  }
  if (hasMetrics) {
    result.metrics = metrics;
  }
  return result;
}
function processOption(option) {
  var type = option.type;
  switch (type) {
    case REDIRECT:
      return resolve(createRedirectOption(option));
    case DYNAMIC:
      return createHtmlOption(option);
    case ACTIONS:
      return resolve(createActionsOption(option));
    default:
      return resolve(option);
  }
}
function processOptions$1(options, predicate) {
  if (!isArray(options)) {
    return resolve([]);
  }
  if (isEmpty(options)) {
    return resolve([]);
  }
  var validOptions = filter(predicate, options);
  if (isEmpty(validOptions)) {
    return resolve([]);
  }
  var optionsPromises = map(function(opt) {
    return processOption(opt);
  }, validOptions);
  return all(optionsPromises).then(filterNotNil);
}
function processMetrics(metrics, predicate) {
  if (!isArray(metrics)) {
    return resolve([]);
  }
  if (isEmpty(metrics)) {
    return resolve([]);
  }
  return resolve(filter(predicate, metrics));
}
function processPageLoad(httpContext) {
  var response = httpContext.response;
  var execute = response.execute;
  if (!isObject(execute)) {
    return resolve(null);
  }
  var pageLoad = execute.pageLoad;
  if (!isObject(pageLoad)) {
    return resolve(null);
  }
  var analytics = pageLoad.analytics,
    options = pageLoad.options,
    metrics = pageLoad.metrics;
  var result = {
    analytics: analytics
  };
  return all([
    processOptions$1(options, isValidOption),
    processMetrics(metrics, isValidSelectorMetric)
  ]).then(function(arr) {
    return addOptionsAndMetrics(result, arr);
  });
}
function processExecuteMbox(item) {
  var name = item.name,
    analytics = item.analytics,
    options = item.options,
    metrics = item.metrics;
  var result = {
    name: name,
    analytics: analytics
  };
  return all([
    processOptions$1(options, isValidOption),
    processMetrics(metrics, isValidMetric)
  ]).then(function(arr) {
    return addOptionsAndMetrics(result, arr);
  });
}
function processExecuteMboxes(httpContext) {
  var response = httpContext.response;
  var execute = response.execute;
  if (!isObject(execute)) {
    return resolve([]);
  }
  var mboxes = execute.mboxes;
  if (!isArray(mboxes) || isEmpty(mboxes)) {
    return resolve([]);
  }
  var validMboxes = filter(isValidMbox, mboxes);
  return all(map(processExecuteMbox, validMboxes)).then(filterNotNil);
}
function sameMbox(mbox, index, name) {
  return mbox.index === index && mbox.name === name;
}
function getRequestMbox(request, index, name) {
  var _request$prefetch = request.prefetch,
    prefetch = _request$prefetch === void 0 ? {} : _request$prefetch;
  var _prefetch$mboxes = prefetch.mboxes,
    mboxes = _prefetch$mboxes === void 0 ? [] : _prefetch$mboxes;
  if (isEmpty(mboxes)) {
    return null;
  }
  return first(
    filter(function(item) {
      return sameMbox(item, index, name);
    }, mboxes)
  );
}
function processPrefetchMbox(request, item) {
  var index = item.index,
    name = item.name,
    state = item.state,
    analytics = item.analytics,
    options = item.options,
    metrics = item.metrics;
  var requestMbox = getRequestMbox(request, index, name);
  var result = {
    name: name,
    state: state,
    analytics: analytics
  };
  if (!isNil(requestMbox)) {
    addContextDetails(result, requestMbox);
  }
  return all([
    processOptions$1(options, isValidOptionEventToken),
    processMetrics(metrics, isValidMetric)
  ]).then(function(arr) {
    return addOptionsAndMetrics(result, arr);
  });
}
function processPrefetchMboxes(httpContext) {
  var request = httpContext.request,
    response = httpContext.response;
  var prefetch = response.prefetch;
  if (!isObject(prefetch)) {
    return resolve([]);
  }
  var mboxes = prefetch.mboxes;
  if (!isArray(mboxes) || isEmpty(mboxes)) {
    return resolve([]);
  }
  var validMboxes = filter(isValidPrefetchMbox, mboxes);
  var process = function process(item) {
    return processPrefetchMbox(request, item);
  };
  return all(map(process, validMboxes)).then(filterNotNil);
}
function getRequestView(request) {
  var _request$prefetch2 = request.prefetch,
    prefetch = _request$prefetch2 === void 0 ? {} : _request$prefetch2;
  var _prefetch$views = prefetch.views,
    views = _prefetch$views === void 0 ? [] : _prefetch$views;
  if (isEmpty(views)) {
    return null;
  }
  return views[0];
}
function processView(request, view) {
  var name = view.name,
    state = view.state,
    analytics = view.analytics,
    options = view.options,
    metrics = view.metrics;
  var requestView = getRequestView(request);
  var result = {
    name: name.toLowerCase(),
    state: state,
    analytics: analytics
  };
  if (!isNil(requestView)) {
    addContextDetails(result, requestView);
  }
  return all([
    processOptions$1(options, isValidOptionEventToken),
    processMetrics(metrics, isValidSelectorMetric)
  ]).then(function(arr) {
    return addOptionsAndMetrics(result, arr);
  });
}
function processPrefetchViews(httpContext) {
  var request = httpContext.request,
    response = httpContext.response;
  var prefetch = response.prefetch;
  if (!isObject(prefetch)) {
    return resolve([]);
  }
  var views = prefetch.views;
  if (!isArray(views) || isEmpty(views)) {
    return resolve([]);
  }
  var validViews = filter(isValidView, views);
  var process = function process(view) {
    return processView(request, view);
  };
  return all(map(process, validViews)).then(filterNotNil);
}
function processPrefetchMetrics(httpContext) {
  var response = httpContext.response;
  var prefetch = response.prefetch;
  if (!isObject(prefetch)) {
    return resolve([]);
  }
  var metrics = prefetch.metrics;
  return processMetrics(metrics, isValidSelectorMetric);
}
function processMeta(httpContext) {
  var response = httpContext.response;
  var remoteMboxes = response.remoteMboxes,
    remoteViews = response.remoteViews,
    decisioningMethod = response.decisioningMethod;
  var meta = {};
  if (isObject(remoteMboxes)) {
    meta.remoteMboxes = remoteMboxes;
  }
  if (isObject(remoteViews)) {
    meta.remoteViews = remoteViews;
  }
  if (isString(decisioningMethod)) {
    meta.decisioningMethod = decisioningMethod;
  }
  return resolve(meta);
}
function createResponseContext(arr) {
  var pageLoad = arr[0];
  var mboxes = arr[1];
  var prefetchMboxes = arr[2];
  var views = arr[3];
  var prefetchMetrics = arr[4];
  var meta = arr[5];
  var result = {};
  var execute = {};
  if (isObject(pageLoad)) {
    execute.pageLoad = pageLoad;
  }
  if (!isEmpty(mboxes)) {
    execute.mboxes = mboxes;
  }
  var prefetch = {};
  if (!isEmpty(prefetchMboxes)) {
    prefetch.mboxes = prefetchMboxes;
  }
  if (!isEmpty(views)) {
    prefetch.views = views;
  }
  if (!isEmpty(prefetchMetrics)) {
    prefetch.metrics = prefetchMetrics;
  }
  if (!isEmpty(execute)) {
    result.execute = execute;
  }
  if (!isEmpty(prefetch)) {
    result.prefetch = prefetch;
  }
  if (!isEmpty(meta)) {
    result.meta = meta;
  }
  return result;
}
function processResponse(httpContext) {
  var handlers = [handleTraces, handleDeviceId, handleEdgeCluster];
  var context = flow(handlers)(httpContext);
  var pageLoad = processPageLoad(context);
  var mboxes = processExecuteMboxes(context);
  var prefetchMboxes = processPrefetchMboxes(context);
  var views = processPrefetchViews(context);
  var prefetchMetrics = processPrefetchMetrics(context);
  var meta = processMeta(context);
  var promises = [
    pageLoad,
    mboxes,
    prefetchMboxes,
    views,
    prefetchMetrics,
    meta
  ];
  return all(promises).then(createResponseContext);
}

function hasRedirect(response) {
  var redirect = getRedirect(response);
  return !isEmpty(redirect);
}
function createEventPayload(response) {
  var responseTokens = getResponseTokens(response);
  var payload = {};
  if (!isEmpty(responseTokens)) {
    payload.responseTokens = responseTokens;
  }
  return payload;
}

function handleRequestSuccess(response) {
  var payload = createEventPayload(response);
  var analyticsDetails = getAnalyticsDetails(response);
  if (!isEmpty(analyticsDetails)) {
    payload.analyticsDetails = analyticsDetails;
  }
  logDebug(REQUEST_SUCCEEDED, response);
  notifyRequestSucceeded(payload, hasRedirect(response));
  return resolve(response);
}
function handleMboxRequestSuccess(mbox, response) {
  var payload = createEventPayload(response);
  payload.mbox = mbox;
  logDebug(REQUEST_SUCCEEDED, response);
  notifyRequestSucceeded(payload, hasRedirect(response));
  return resolve(response);
}
function handleRequestError(error) {
  logWarn(REQUEST_FAILED, error);
  notifyRequestFailed({
    error: error
  });
  return reject(error);
}
function handleMboxRequestError(mbox, error) {
  logWarn(REQUEST_FAILED, error);
  notifyRequestFailed({
    mbox: mbox,
    error: error
  });
  return reject(error);
}
function executeGetOffer(options) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var mbox = options.mbox,
    timeout = options.timeout;
  var params = isObject(options.params) ? options.params : {};
  var successFunc = function successFunc(response) {
    return handleMboxRequestSuccess(mbox, response);
  };
  var errorFunc = function errorFunc(error) {
    return handleMboxRequestError(mbox, error);
  };
  var payload = {};
  var execute = {};
  if (mbox === globalMbox) {
    execute.pageLoad = {};
  } else {
    execute.mboxes = [
      {
        index: 0,
        name: mbox
      }
    ];
  }
  payload.execute = execute;
  var analytics = createAnalytics(mbox, payload);
  if (!isEmpty(analytics)) {
    var experienceCloud = {};
    experienceCloud.analytics = analytics;
    payload.experienceCloud = experienceCloud;
  }
  notifyRequestStart({
    mbox: mbox
  });
  return createAsyncDeliveryRequest(payload, params)
    .then(function(request) {
      return executeRequest(options, request, timeout);
    })
    .then(processResponse)
    .then(successFunc)
    ["catch"](errorFunc);
}
function executeGetOffers(options) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var _options$consumerId = options.consumerId,
    consumerId =
      _options$consumerId === void 0 ? globalMbox : _options$consumerId,
    request = options.request,
    timeout = options.timeout;
  var analytics = createAnalytics(consumerId, request);
  var successFunc = function successFunc(response) {
    return handleRequestSuccess(response);
  };
  var errorFunc = function errorFunc(error) {
    return handleRequestError(error);
  };
  if (!isEmpty(analytics)) {
    var experienceCloud = request.experienceCloud || {};
    experienceCloud.analytics = analytics;
    request.experienceCloud = experienceCloud;
  }
  notifyRequestStart({});
  return createAsyncDeliveryRequest(request, {})
    .then(function(deliveryRequest) {
      return executeRequest(options, deliveryRequest, timeout);
    })
    .then(processResponse)
    .then(successFunc)
    ["catch"](errorFunc);
}

function addClass(cssClass, selector) {
  return select(selector).addClass(cssClass);
}
function setCss(style, selector) {
  return select(selector).css(style);
}

function getAttr(name, selector) {
  return select(selector).attr(name);
}
function setAttr(name, value, selector) {
  return select(selector).attr(name, value);
}
function removeAttr(name, selector) {
  return select(selector).removeAttr(name);
}
function copyAttr(from, to, selector) {
  var value = getAttr(from, selector);
  if (isNotBlank(value)) {
    removeAttr(from, selector);
    setAttr(to, value, selector);
  }
}
function hasAttr(name, selector) {
  return isNotBlank(getAttr(name, selector));
}

var VISIBILITY_STATE = "visibilityState";
var VISIBLE = "visible";
var DELAY = 100;
function createError$1(selector) {
  return new Error("Could not find: " + selector);
}
function awaitUsingMutationObserver(selector, timeout, queryFunc) {
  return create(function(res, rej) {
    var mo = getMutationObserver(function() {
      var elems = queryFunc(selector);
      if (!isEmpty(elems)) {
        mo.disconnect();
        res(elems);
      }
    });
    delay(function() {
      mo.disconnect();
      rej(createError$1(selector));
    }, timeout);
    mo.observe(document, {
      childList: true,
      subtree: true
    });
  });
}
function canUseRequestAnimation() {
  return document[VISIBILITY_STATE] === VISIBLE;
}
function awaitUsingRequestAnimation(selector, timeout, queryFunc) {
  return create(function(res, rej) {
    function execute() {
      var elems = queryFunc(selector);
      if (!isEmpty(elems)) {
        res(elems);
        return;
      }
      window.requestAnimationFrame(execute);
    }
    execute();
    delay(function() {
      rej(createError$1(selector));
    }, timeout);
  });
}
function awaitUsingTimer(selector, timeout, queryFunc) {
  return create(function(res, rej) {
    function execute() {
      var elems = queryFunc(selector);
      if (!isEmpty(elems)) {
        res(elems);
        return;
      }
      delay(execute, DELAY);
    }
    execute();
    delay(function() {
      rej(createError$1(selector));
    }, timeout);
  });
}
function awaitSelector(selector) {
  var timeout =
    arguments.length > 1 && arguments[1] !== undefined
      ? arguments[1]
      : getConfig()[SELECTORS_POLLING_TIMEOUT];
  var queryFunc =
    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : select;
  var elems = queryFunc(selector);
  if (!isEmpty(elems)) {
    return resolve(elems);
  }
  if (canUseMutationObserver()) {
    return awaitUsingMutationObserver(selector, timeout, queryFunc);
  }
  if (canUseRequestAnimation()) {
    return awaitUsingRequestAnimation(selector, timeout, queryFunc);
  }
  return awaitUsingTimer(selector, timeout, queryFunc);
}

function getDataSrc(item) {
  return getAttr(DATA_SRC, item);
}
function hasDataSrc(item) {
  return hasAttr(DATA_SRC, item);
}
function disableImages(html) {
  forEach(function(item) {
    return copyAttr(SRC, DATA_SRC, item);
  }, toArray(find(IMAGE_TAG, html)));
  return html;
}
function enableImages(html) {
  forEach(function(item) {
    return copyAttr(DATA_SRC, SRC, item);
  }, toArray(find(IMAGE_TAG, html)));
  return html;
}
function loadImage(src) {
  logDebug(LOADING_IMAGE, src);
  return getAttr(SRC, setAttr(SRC, src, wrap("<" + IMAGE_TAG + "/>")));
}
function loadImages(html) {
  var elements = filter(hasDataSrc, toArray(find(IMAGE_TAG, html)));
  if (isEmpty(elements)) {
    return html;
  }
  forEach(loadImage, map(getDataSrc, elements));
  return html;
}
function renderImages(html) {
  return flow([disableImages, loadImages, enableImages])(html);
}

function getUrl(item) {
  var src = getAttr(SRC, item);
  return isNotBlank(src) ? src : null;
}
function getScriptsUrls(html) {
  return filter(isNotBlank, map(getUrl, toArray(find(SCRIPT, html))));
}
function loadScripts(urls) {
  return reduce(
    function(acc, url) {
      return acc.then(function() {
        logDebug(REMOTE_SCRIPT, url);
        addClientTrace({
          remoteScript: url
        });
        return loadScript(url);
      });
    },
    resolve(),
    urls
  );
}

function handleRenderingSuccess(action) {
  return action;
}
function handleRenderingError(action, error) {
  logWarn(UNEXPECTED_ERROR, error);
  addClientTrace({
    action: action,
    error: error
  });
  return action;
}
function renderHtml(renderFunc, action) {
  var container = select(action[SELECTOR]);
  var html = renderImages(fragment(action[CONTENT]));
  var urls = getScriptsUrls(html);
  var result;
  try {
    result = resolve(renderFunc(container, html));
  } catch (err) {
    return reject(handleRenderingError(action, err));
  }
  if (isEmpty(urls)) {
    return result
      .then(function() {
        return handleRenderingSuccess(action);
      })
      ["catch"](function(error) {
        return handleRenderingError(action, error);
      });
  }
  return result
    .then(function() {
      return loadScripts(urls);
    })
    .then(function() {
      return handleRenderingSuccess(action);
    })
    ["catch"](function(error) {
      return handleRenderingError(action, error);
    });
}

var HEAD_TAGS_SELECTOR = SCRIPT_TAG + "," + LINK_TAG + "," + STYLE_TAG;
function getHeadContent(content) {
  var container = fragment(content);
  var result = reduce(
    function(acc, elem) {
      acc.push(getHtml(fragment(elem)));
      return acc;
    },
    [],
    toArray(find(HEAD_TAGS_SELECTOR, container))
  );
  return join("", result);
}
function preprocessAction(action) {
  var result = assign({}, action);
  var content = result[CONTENT];
  if (isBlank(content)) {
    return result;
  }
  var container = select(result[SELECTOR]);
  if (!is(HEAD_TAG, container)) {
    return result;
  }
  result[TYPE] = APPEND_HTML;
  result[CONTENT] = getHeadContent(content);
  return result;
}
function addPxIfRequired(value) {
  var hasPx = value.indexOf("px") === value.length - 2;
  return hasPx ? value : value + "px";
}
function setHtmlRenderFunc(container, html) {
  return setHtml(getHtml(html), container);
}
function setHtml$2(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(setHtmlRenderFunc, action);
}
function setText$2(action) {
  var container = select(action[SELECTOR]);
  var content = action[CONTENT];
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  setText(content, container);
  return resolve(action);
}
function appendHtmlRenderFunc(container, html) {
  return append(getHtml(html), container);
}
function appendHtml$1(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(appendHtmlRenderFunc, action);
}
function prependHtmlRenderFunc(container, html) {
  return prepend(getHtml(html), container);
}
function prependHtml$1(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(prependHtmlRenderFunc, action);
}
function replaceHtmlRenderFunc(container, html) {
  var parentContainer = parent(container);
  remove(before(getHtml(html), container));
  return parentContainer;
}
function replaceHtml$1(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(replaceHtmlRenderFunc, action);
}
function insertBeforeRenderFunc(container, html) {
  return prev(before(getHtml(html), container));
}
function insertBefore$1(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(insertBeforeRenderFunc, action);
}
function insertAfterRenderFunc(container, html) {
  return next(after(getHtml(html), container));
}
function insertAfter$1(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(insertAfterRenderFunc, action);
}
function customCodeRenderFunc(container, html) {
  return parent(before(getHtml(html), container));
}
function customCode$1(action) {
  logDebug(ACTION_RENDERING, action);
  return renderHtml(customCodeRenderFunc, action);
}
function setImageSource$1(action) {
  var content = action[CONTENT];
  var container = select(action[SELECTOR]);
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  removeAttr(SRC, container);
  setAttr(SRC, loadImage(content), container);
  return resolve(action);
}
function setAttribute$1(action) {
  var content = action[CONTENT];
  var container = select(action[SELECTOR]);
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  forEach(function(value, key) {
    return setAttr(key, value, container);
  }, content);
  return resolve(action);
}
function setCssWithPriority(container, style, priority) {
  forEach(function(elem) {
    forEach(function(value, key) {
      return elem.style.setProperty(key, value, priority);
    }, style);
  }, toArray(container));
}
function setStyle$1(action) {
  var container = select(action[SELECTOR]);
  var content = action[CONTENT];
  var priority = content[PRIORITY];
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  if (isBlank(priority)) {
    setCss(content, container);
  } else {
    setCssWithPriority(container, content, priority);
  }
  return resolve(action);
}
function resize$1(action) {
  var container = select(action[SELECTOR]);
  var content = action[CONTENT];
  content[WIDTH] = addPxIfRequired(content[WIDTH]);
  content[HEIGHT] = addPxIfRequired(content[HEIGHT]);
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  setCss(content, container);
  return resolve(action);
}
function move$1(action) {
  var container = select(action[SELECTOR]);
  var content = action[CONTENT];
  content[LEFT] = addPxIfRequired(content[LEFT]);
  content[TOP] = addPxIfRequired(content[TOP]);
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  setCss(content, container);
  return resolve(action);
}
function remove$2(action) {
  var container = select(action[SELECTOR]);
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  remove(container);
  return resolve(action);
}
function rearrange$1(action) {
  var container = select(action[SELECTOR]);
  var content = action[CONTENT];
  var from = content[FROM];
  var to = content[TO];
  var elements = toArray(children(container));
  var elemFrom = elements[from];
  var elemTo = elements[to];
  if (!exists$2(elemFrom) || !exists$2(elemTo)) {
    logDebug(REARRANGE_MISSING, action);
    return reject(action);
  }
  logDebug(ACTION_RENDERING, action);
  addClientTrace({
    action: action
  });
  if (from < to) {
    after(elemFrom, elemTo);
  } else {
    before(elemFrom, elemTo);
  }
  return resolve(action);
}
function executeRenderAction(action) {
  var processedAction = preprocessAction(action);
  var type = processedAction[TYPE];
  switch (type) {
    case SET_HTML:
      return setHtml$2(processedAction);
    case SET_TEXT:
      return setText$2(processedAction);
    case APPEND_HTML:
      return appendHtml$1(processedAction);
    case PREPEND_HTML:
      return prependHtml$1(processedAction);
    case REPLACE_HTML:
      return replaceHtml$1(processedAction);
    case INSERT_BEFORE:
      return insertBefore$1(processedAction);
    case INSERT_AFTER:
      return insertAfter$1(processedAction);
    case CUSTOM_CODE:
      return customCode$1(processedAction);
    case SET_ATTRIBUTE:
      return setAttribute$1(processedAction);
    case SET_IMAGE_SOURCE:
      return setImageSource$1(processedAction);
    case SET_STYLE:
      return setStyle$1(processedAction);
    case RESIZE:
      return resize$1(processedAction);
    case MOVE:
      return move$1(processedAction);
    case REMOVE:
      return remove$2(processedAction);
    case REARRANGE:
      return rearrange$1(processedAction);
    default:
      return resolve(processedAction);
  }
}

var ACTION_KEY_ATTR = "at-action-key";
function isClickTracking(action) {
  return action[TYPE] === TRACK_CLICK || action[TYPE] === SIGNAL_CLICK;
}
function hasValidSelector(action) {
  var selector = action[SELECTOR];
  return isNotBlank(selector) || isElement(selector);
}
function markAsRendered(action) {
  var key = action.key;
  if (isBlank(key)) {
    return;
  }
  if (!hasValidSelector(action)) {
    return;
  }
  var selector = action[SELECTOR];
  setAttr(ACTION_KEY_ATTR, key, selector);
}
function removeActionCssHiding(action) {
  var cssSelector = action[CSS_SELECTOR];
  if (isBlank(cssSelector)) {
    return;
  }
  removeActionHidingStyle(cssSelector);
}
function displayAction(action) {
  if (!hasValidSelector(action)) {
    removeActionCssHiding(action);
    return;
  }
  var selector = action[SELECTOR];
  if (isClickTracking(action)) {
    addClass(CLICK_TRACKING_CSS_CLASS, selector);
    return;
  }
  addClass(MARKER_CSS_CLASS, selector);
  removeActionCssHiding(action);
}
function displayActions(actions) {
  forEach(displayAction, actions);
}
function shouldRender(action) {
  var key = action.key;
  if (isBlank(key)) {
    return true;
  }
  var type = action[TYPE];
  if (type === CUSTOM_CODE) {
    return action[PAGE];
  }
  var selector = action[SELECTOR];
  var currentKey = getAttr(ACTION_KEY_ATTR, selector);
  if (currentKey !== key) {
    return true;
  }
  if (currentKey === key) {
    return !action[PAGE];
  }
  return false;
}
function renderAwaitedAction(action) {
  if (!shouldRender(action)) {
    displayAction(action);
    return action;
  }
  return executeRenderAction(action)
    .then(function() {
      logDebug(ACTION_RENDERED, action);
      addClientTrace({
        action: action
      });
      markAsRendered(action);
      displayAction(action);
      return action;
    })
    ["catch"](function(error) {
      logWarn(UNEXPECTED_ERROR, error);
      addClientTrace({
        action: action,
        error: error
      });
      displayAction(action);
      var result = assign({}, action);
      result[ERROR] = true;
      return result;
    });
}
function postProcess(actions) {
  var errorActions = filter(function(e) {
    return e[ERROR] === true;
  }, actions);
  if (isEmpty(errorActions)) {
    return resolve();
  }
  displayActions(errorActions);
  return reject(actions);
}
function awaitAction(action) {
  var selector = action[SELECTOR];
  return awaitSelector(selector)
    .then(function() {
      return action;
    })
    ["catch"](function() {
      var result = assign({}, action);
      result[ERROR] = true;
      return result;
    });
}
function awaitAndRenderAction(action) {
  return awaitAction(action).then(renderAwaitedAction);
}
function executeRenderActions(actions) {
  var promises = map(awaitAndRenderAction, actions);
  return all(promises).then(postProcess);
}

function addEventListener(type, func, selector) {
  return select(selector).on(type, func);
}
function removeEventListener(type, func, selector) {
  return select(selector).off(type, func);
}

var METRIC_ELEMENT_NOT_FOUND = "metric element not found";
function executeMetric(metric) {
  var selector = metric[SELECTOR];
  return awaitSelector(selector)
    .then(function() {
      addClientTrace({
        metric: metric
      });
      var foundMetric = assign(
        {
          found: true
        },
        metric
      );
      return foundMetric;
    })
    ["catch"](function() {
      logWarn(METRIC_ELEMENT_NOT_FOUND, metric);
      addClientTrace({
        metric: metric,
        message: METRIC_ELEMENT_NOT_FOUND
      });
      return metric;
    });
}

function saveView(view) {
  var key = view.name;
  var views = getItem(VIEWS) || {};
  views[key] = view;
  setItem(VIEWS, views);
}
function findView(key) {
  var options =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$page = options.page,
    page = _options$page === void 0 ? true : _options$page;
  var views = getItem(VIEWS) || {};
  var result = views[key];
  if (isNil(result)) {
    return result;
  }
  var impressionId = options.impressionId;
  if (isNil(impressionId)) {
    return result;
  }
  return assign(
    {
      page: page,
      impressionId: impressionId
    },
    result
  );
}
function persistViews(views) {
  forEach(saveView, views);
}

var NAVIGATOR = "navigator";
var SEND_BEACON = "sendBeacon";
function executeSendBeacon(win, url, data) {
  return win[NAVIGATOR][SEND_BEACON](url, data);
}
function executeSyncXhr(http, url, data) {
  var headers = {};
  headers[CONTENT_TYPE] = [TEXT_PLAIN];
  var options = {};
  options[METHOD] = POST$1;
  options[URL] = url;
  options[DATA$1] = data;
  options[CREDENTIALS] = true;
  options[ASYNC] = false;
  options[HEADERS] = headers;
  try {
    http(options);
  } catch (error) {
    return false;
  }
  return true;
}
function isBeaconSupported(win) {
  return NAVIGATOR in win && SEND_BEACON in win[NAVIGATOR];
}
function sendBeacon(url, data) {
  if (isBeaconSupported(window)) {
    return executeSendBeacon(window, url, data);
  }
  return executeSyncXhr(xhr, url, data);
}

var SEND_BEACON_SUCCESS = "Beacon data sent";
var SEND_BEACON_ERROR = "Beacon data sent failed";
var VIEW_TRIGGERED = "View triggered notification";
var VIEW_RENDERED = "View rendered notification";
var MBOXES_RENDERED = "Mboxes rendered notification";
var EVENT_HANDLER = "Event handler notification";
var MBOX_EVENT_HANDLER = "Mbox event handler notification";
var VIEW_EVENT_HANDLER = "View event handler notification";
var PREFETCH_MBOXES = "prefetchMboxes";
var RENDERED = "rendered";
var TRIGGERED = "triggered";
function createRequest(consumerId) {
  var analytics = createAnalytics(consumerId, {});
  var request = {
    context: {
      beacon: true
    }
  };
  if (!isEmpty(analytics)) {
    var experienceCloud = {};
    experienceCloud.analytics = analytics;
    request.experienceCloud = experienceCloud;
  }
  return request;
}
function createSyncNotificationRequest(consumerId, params, notifications) {
  var request = createRequest(consumerId);
  var result = createSyncDeliveryRequest(request, params);
  result.notifications = notifications;
  return result;
}
function createAsyncNotificationRequest(consumerId, params, notifications) {
  var request = createRequest(consumerId);
  return createAsyncDeliveryRequest(request, params).then(function(result) {
    result.notifications = notifications;
    return result;
  });
}
function createNotification(item, type, tokens) {
  var id = uuid();
  var timestamp = now();
  var parameters = item.parameters,
    profileParameters = item.profileParameters,
    order = item.order,
    product = item.product;
  var result = {
    id: id,
    type: type,
    timestamp: timestamp,
    parameters: parameters,
    profileParameters: profileParameters,
    order: order,
    product: product
  };
  if (isEmpty(tokens)) {
    return result;
  }
  result.tokens = tokens;
  return result;
}
function createMboxNotification(mbox, type, tokens) {
  var name = mbox.name,
    state = mbox.state;
  var notification = createNotification(mbox, type, tokens);
  notification.mbox = {
    name: name,
    state: state
  };
  return notification;
}
function createViewNotification(view, type, tokens) {
  var name = view.name,
    state = view.state;
  var notification = createNotification(view, type, tokens);
  notification.view = {
    name: name,
    state: state
  };
  return notification;
}
function executeBeaconNotification(request) {
  var config = getConfig();
  var url = createRequestUrl(config);
  var data = JSON.stringify(request);
  if (sendBeacon(url, data)) {
    logDebug(SEND_BEACON_SUCCESS, url, request);
    return true;
  }
  logWarn(SEND_BEACON_ERROR, url, request);
  return false;
}
function sendEventNotification(source, type, token) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var params = getTargetPageParams(globalMbox);
  var requestDetails = createRequestDetails({}, params);
  var notification = createNotification(requestDetails, type, [token]);
  var request = createSyncNotificationRequest(uuid(), params, [notification]);
  logDebug(EVENT_HANDLER, source, notification);
  addClientTrace({
    source: source,
    event: type,
    request: request
  });
  executeBeaconNotification(request);
}
function sendMboxEventNotification(name, type, token) {
  var params = getTargetPageParams(name);
  var requestDetails = createRequestDetails({}, params);
  var notification = createNotification(requestDetails, type, [token]);
  notification.mbox = {
    name: name
  };
  var request = createSyncNotificationRequest(uuid(), params, [notification]);
  logDebug(MBOX_EVENT_HANDLER, name, notification);
  addClientTrace({
    mbox: name,
    event: type,
    request: request
  });
  executeBeaconNotification(request);
}
function sendMboxesRenderedNotifications(items) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var notifications = [];
  var type = DISPLAY_EVENT;
  forEach(function(item) {
    var mbox = item.mbox,
      data = item.data;
    if (isNil(data)) {
      return;
    }
    var _data$eventTokens = data.eventTokens,
      eventTokens = _data$eventTokens === void 0 ? [] : _data$eventTokens;
    if (isEmpty(eventTokens)) {
      return;
    }
    notifications.push(createMboxNotification(mbox, type, eventTokens));
  }, items);
  if (isEmpty(notifications)) {
    return;
  }
  var request = createSyncNotificationRequest(globalMbox, {}, notifications);
  logDebug(MBOXES_RENDERED, notifications);
  addClientTrace({
    source: PREFETCH_MBOXES,
    event: RENDERED,
    request: request
  });
  executeBeaconNotification(request);
}
function sendViewEventNotification(name, type, token) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var params = getTargetPageParams(globalMbox);
  var requestDetails = createRequestDetails({}, params);
  var notification = createNotification(requestDetails, type, [token]);
  notification.view = {
    name: name
  };
  var request = createSyncNotificationRequest(uuid(), params, [notification]);
  logDebug(VIEW_EVENT_HANDLER, name, notification);
  addClientTrace({
    view: name,
    event: type,
    request: request
  });
  executeBeaconNotification(request);
}
function sendViewTriggeredNotifications(options) {
  var name = options.viewName,
    impressionId = options.impressionId;
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var params = getTargetPageParams(globalMbox);
  var requestDetails = createRequestDetails({}, params);
  var notification = createNotification(requestDetails, DISPLAY_EVENT, []);
  notification.view = {
    name: name
  };
  logDebug(VIEW_TRIGGERED, name);
  createAsyncNotificationRequest(name, params, [notification]).then(function(
    request
  ) {
    request.impressionId = impressionId;
    addClientTrace({
      view: name,
      event: TRIGGERED,
      request: request
    });
    executeBeaconNotification(request);
  });
}
function sendViewRenderedNotifications(item) {
  if (isNil(item)) {
    return;
  }
  var view = item.view,
    _item$data = item.data,
    data = _item$data === void 0 ? {} : _item$data;
  var _data$eventTokens2 = data.eventTokens,
    eventTokens = _data$eventTokens2 === void 0 ? [] : _data$eventTokens2;
  if (isEmpty(eventTokens)) {
    return;
  }
  var name = view.name,
    impressionId = view.impressionId;
  var persistedView = findView(name);
  if (isNil(persistedView)) {
    return;
  }
  var notification = createViewNotification(
    persistedView,
    DISPLAY_EVENT,
    eventTokens
  );
  var request = createSyncNotificationRequest(name, {}, [notification]);
  request.impressionId = impressionId;
  logDebug(VIEW_RENDERED, name, eventTokens);
  addClientTrace({
    view: name,
    event: RENDERED,
    request: request
  });
  executeBeaconNotification(request);
}

var CACHE$1 = {};
var PAGE_LOAD$1 = "pageLoadMetrics";
var PREFETCH = "prefetchMetrics";
var selectMetrics = prop(METRICS);
var createMetricSuccess = function createMetricSuccess() {
  return createSuccess(METRIC);
};
var createMetricError = function createMetricError(error) {
  return createError(METRIC, error);
};
function decorateElementIfRequired(type, selector) {
  if (type !== CLICK) {
    return;
  }
  addClass(CLICK_TRACKING_CSS_CLASS, selector);
}
function isHandlerCached(name, key) {
  return !isNil(CACHE$1[name]) && !isNil(CACHE$1[name][key]);
}
function removePreviousHandlersFromCache(currentViewName, type, selector) {
  if (!isNil(CACHE$1[currentViewName])) {
    return;
  }
  var viewNames = keys(CACHE$1);
  if (isEmpty(viewNames)) {
    return;
  }
  forEach(function(viewName) {
    var handlerNames = keys(CACHE$1[viewName]);
    forEach(function(handlerName) {
      var func = CACHE$1[viewName][handlerName];
      removeEventListener(type, func, selector);
    }, handlerNames);
    delete CACHE$1[viewName];
  }, viewNames);
}
function addHandlerToCache(name, key, handler) {
  CACHE$1[name] = CACHE$1[name] || {};
  CACHE$1[name][key] = handler;
}
function attachEventHandler(name, fromView, metric, notifyFunc) {
  var type = metric.type,
    selector = metric.selector,
    eventToken = metric.eventToken;
  var key = hash(type + ":" + selector + ":" + eventToken);
  var handler = function handler() {
    return notifyFunc(name, type, eventToken);
  };
  decorateElementIfRequired(type, selector);
  if (!fromView) {
    addEventListener(type, handler, selector);
    return;
  }
  if (isHandlerCached(name, key)) {
    return;
  }
  removePreviousHandlersFromCache(name, type, selector);
  addHandlerToCache(name, key, handler);
  addEventListener(type, handler, selector);
}
function attachMetricEventHandlers(name, fromView, metrics, notifyFunc) {
  return all(map(executeMetric, metrics))
    .then(function(arr) {
      forEach(
        function(metric) {
          return attachEventHandler(name, fromView, metric, notifyFunc);
        },
        filter(function(metric) {
          return metric.found;
        }, arr)
      );
      return createMetricSuccess();
    })
    ["catch"](createMetricError);
}
function executeMboxMetrics(mbox) {
  var name = mbox.name;
  return attachMetricEventHandlers(
    name,
    false,
    selectMetrics(mbox),
    sendMboxEventNotification
  );
}
function executeViewMetrics(view) {
  var name = view.name;
  return attachMetricEventHandlers(
    name,
    true,
    selectMetrics(view),
    sendViewEventNotification
  );
}
function executePageLoadMetrics(pageLoad) {
  return attachMetricEventHandlers(
    PAGE_LOAD$1,
    false,
    selectMetrics(pageLoad),
    sendEventNotification
  );
}
function executePrefetchMetrics(prefetch) {
  return attachMetricEventHandlers(
    PREFETCH,
    false,
    selectMetrics(prefetch),
    sendEventNotification
  );
}

var selectContent$1 = prop(CONTENT);
var selectCssSelector = prop(CSS_SELECTOR);
var createRenderSuccess = function createRenderSuccess(eventToken) {
  return createSuccess(RENDER, eventToken);
};
var createRenderError = function createRenderError(error) {
  return createError(RENDER, error);
};
var hasNonErrorData = function hasNonErrorData(val) {
  return not(isError)(val) && hasData(val);
};
function hideActions(actions) {
  var items = map(selectCssSelector, actions);
  injectActionHidingStyles(filterNotBlank(items));
}
function hideAllViewsActions(actions) {
  var items = map(selectCssSelector, actions);
  injectAllViewsHidingStyle(filterNotNil(items));
}
function extractActions(item) {
  var options = filter(isActions, selectOptions(item));
  return flatten(map(selectContent$1, options));
}
function isValidAction(action) {
  return isObject(action) && action.type !== SET_JSON;
}
function decorateActions(actions, key, page) {
  return map(function(e) {
    return assign(
      {
        key: key,
        page: page
      },
      e
    );
  }, filter(isValidAction, actions));
}
function executeRendering(option, key, page) {
  var eventToken = option.eventToken,
    content = option.content;
  var actions = decorateActions(content, key, page);
  return executeRenderActions(actions)
    .then(function() {
      return createRenderSuccess(eventToken);
    })
    ["catch"](createRenderError);
}
function isValidOption$1(option) {
  return isObject(option) && option.type !== JSON$1;
}
function renderOptions(func, item) {
  return map(func, filter(isValidOption$1, selectOptions(item)));
}
function postExecuteRendering(key, item, values) {
  var result = _defineProperty(
    {
      status: SUCCESS
    },
    key,
    item
  );
  var errors = map(selectData, filter(isError, values));
  var data = {};
  if (!isEmpty(errors)) {
    result.status = ERROR;
    data.errors = errors;
  }
  if (!isEmpty(data)) {
    result.data = data;
  }
  return result;
}
function postPrefetchRendering(key, item, values) {
  var result = _defineProperty(
    {
      status: SUCCESS
    },
    key,
    item
  );
  var errors = map(selectData, filter(isError, values));
  var eventTokens = map(selectData, filter(hasNonErrorData, values));
  var data = {};
  if (!isEmpty(errors)) {
    result.status = ERROR;
    data.errors = errors;
  }
  if (!isEmpty(eventTokens)) {
    data.eventTokens = eventTokens;
  }
  if (!isEmpty(data)) {
    result.data = data;
  }
  return result;
}
function renderExecuteItem(item, postRenderingFunc, metricsFunc) {
  var render = function render(opt) {
    return executeRendering(opt, true);
  };
  var options = renderOptions(render, item);
  return all(options)
    .then(postRenderingFunc)
    .then(function(result) {
      metricsFunc(item);
      return result;
    });
}
function renderPrefetchItem(key, item, page, metricsFunc) {
  var name = item.name;
  var render = function render(opt) {
    return executeRendering(opt, name, page);
  };
  var options = renderOptions(render, item);
  return all(options)
    .then(function(arr) {
      return postPrefetchRendering(key, item, arr);
    })
    .then(function(result) {
      metricsFunc(item);
      return result;
    });
}
function renderMbox(mbox) {
  var postRenderingFunc = function postRenderingFunc(arr) {
    return postExecuteRendering(MBOX, mbox, arr);
  };
  return renderExecuteItem(mbox, postRenderingFunc, executeMboxMetrics);
}
function renderPrefetchMbox(mbox) {
  return renderPrefetchItem(MBOX, mbox, true, executeMboxMetrics);
}
function hideOptions(item) {
  var actions = extractActions(item);
  hideActions(actions);
}
function hidePageLoadOptions(context) {
  var skipPrehiding =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (skipPrehiding) {
    return;
  }
  var _context$execute = context.execute,
    execute = _context$execute === void 0 ? {} : _context$execute;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad;
  if (!isEmpty(pageLoad)) {
    hideOptions(pageLoad);
  }
}
function hideAllViews(context) {
  var _context$prefetch = context.prefetch,
    prefetch = _context$prefetch === void 0 ? {} : _context$prefetch;
  var _prefetch$views = prefetch.views,
    views = _prefetch$views === void 0 ? [] : _prefetch$views;
  if (isEmpty(views)) {
    return;
  }
  var actions = flatten(map(extractActions, views));
  hideAllViewsActions(actions);
}
function hideViewOptions(view) {
  var actions = extractActions(view);
  hideActions(actions);
  removeAllViewsHidingStyle();
}
function renderPageLoad(pageLoad) {
  var postRenderingFunc = function postRenderingFunc(arr) {
    return postExecuteRendering(PAGE_LOAD, pageLoad, arr);
  };
  return renderExecuteItem(pageLoad, postRenderingFunc, executePageLoadMetrics);
}
function renderMboxes(mboxes) {
  return all(map(renderMbox, mboxes));
}
function renderPrefetchMboxes(mboxes) {
  return all(map(renderPrefetchMbox, mboxes));
}
function renderPrefetchMetrics(prefetch) {
  var metrics = [executePrefetchMetrics(prefetch)];
  return all(metrics).then(postExecuteRendering);
}
function renderView(view) {
  var page = view.page;
  return renderPrefetchItem(VIEW, view, page, executeViewMetrics);
}

function E() {}
E.prototype = {
  on: function on(name, callback, ctx) {
    var e = this.e || (this.e = {});
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });
    return this;
  },
  once: function once(name, callback, ctx) {
    var self = this;
    function listener() {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function emit(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function off(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }
    liveEvents.length ? (e[name] = liveEvents) : delete e[name];
    return this;
  }
};
var tinyEmitter = E;
var TinyEmitter = E;
tinyEmitter.TinyEmitter = TinyEmitter;

function create$1() {
  return new tinyEmitter();
}
function publishOn(eventBus, name, args) {
  eventBus.emit(name, args);
}
function subscribeTo(eventBus, name, func) {
  eventBus.on(name, func);
}

var EVENT_BUS = create$1();
function publish(name, args) {
  publishOn(EVENT_BUS, name, args);
}
function subscribe(name, func) {
  subscribeTo(EVENT_BUS, name, func);
}

function redirect$1(option) {
  return {
    type: REDIRECT,
    content: option.url
  };
}
function setContent(action) {
  var result = {};
  result.type = SET_HTML;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function setText$3(action) {
  var result = {};
  result.type = SET_TEXT;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function appendContent(action) {
  var result = {};
  result.type = APPEND_HTML;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function prependContent(action) {
  var result = {};
  result.type = PREPEND_HTML;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function replaceContent(action) {
  var result = {};
  result.type = REPLACE_HTML;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function insertBefore$2(action) {
  var result = {};
  result.type = INSERT_BEFORE;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function insertAfter$2(action) {
  var result = {};
  result.type = INSERT_AFTER;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function customCode$2(action) {
  var result = {};
  result.type = CUSTOM_CODE;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function setAttribute$2(action) {
  var result = {};
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  if (action.attribute === SRC) {
    result.type = SET_IMAGE_SOURCE;
    result.content = action.value;
    return result;
  }
  result.type = SET_ATTRIBUTE;
  var content = {};
  content[action.attribute] = action.value;
  result.content = content;
  return result;
}
function setStyle$2(action) {
  var _action$style = action.style,
    style = _action$style === void 0 ? {} : _action$style;
  var result = {};
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  if (!isNil(style.left) && !isNil(style.top)) {
    result.type = MOVE;
    result.content = style;
    return result;
  }
  if (!isNil(style.width) && !isNil(style.height)) {
    result.type = RESIZE;
    result.content = style;
    return result;
  }
  result.type = SET_STYLE;
  result.content = style;
  return result;
}
function remove$3(action) {
  var result = {};
  result.type = REMOVE;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function rearrange$2(action) {
  var content = {};
  content.from = action.from;
  content.to = action.to;
  var result = {};
  result.type = REARRANGE;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  result.content = content;
  return result;
}
function hasSelectors(action) {
  return isNotBlank(action.selector) && isNotBlank(action.cssSelector);
}
function createPageLoad(items) {
  var result = {};
  if (isEmpty(items)) {
    return result;
  }
  var options = [];
  var metrics = [];
  var actions = [];
  forEach(function(item) {
    var type = item.action;
    switch (type) {
      case SET_CONTENT:
        if (hasSelectors(item)) {
          actions.push(setContent(item));
        } else {
          options.push({
            type: HTML,
            content: item.content
          });
        }
        break;
      case SET_JSON:
        if (!isEmpty(item.content)) {
          forEach(function(e) {
            return options.push({
              type: JSON$1,
              content: e
            });
          }, item.content);
        }
        break;
      case SET_TEXT:
        actions.push(setText$3(item));
        break;
      case APPEND_CONTENT:
        actions.push(appendContent(item));
        break;
      case PREPEND_CONTENT:
        actions.push(prependContent(item));
        break;
      case REPLACE_CONTENT:
        actions.push(replaceContent(item));
        break;
      case INSERT_BEFORE:
        actions.push(insertBefore$2(item));
        break;
      case INSERT_AFTER:
        actions.push(insertAfter$2(item));
        break;
      case CUSTOM_CODE:
        actions.push(customCode$2(item));
        break;
      case SET_ATTRIBUTE:
        actions.push(setAttribute$2(item));
        break;
      case SET_STYLE:
        actions.push(setStyle$2(item));
        break;
      case REMOVE:
        actions.push(remove$3(item));
        break;
      case REARRANGE:
        actions.push(rearrange$2(item));
        break;
      case REDIRECT:
        options.push(redirect$1(item));
        break;
      case TRACK_CLICK:
        metrics.push({
          type: CLICK,
          selector: item.selector,
          eventToken: item.clickTrackId
        });
        break;
    }
  }, items);
  var pageLoad = {};
  var hasActions = !isEmpty(actions);
  if (hasActions) {
    options.push({
      type: ACTIONS,
      content: actions
    });
  }
  var hasOptions = !isEmpty(options);
  if (hasOptions) {
    pageLoad.options = options;
  }
  var hasMetrics = !isEmpty(metrics);
  if (hasMetrics) {
    pageLoad.metrics = metrics;
  }
  if (isEmpty(pageLoad)) {
    return result;
  }
  var execute = {};
  execute.pageLoad = pageLoad;
  result.execute = execute;
  return result;
}
function createMboxes(name, items) {
  var result = {};
  if (isEmpty(items)) {
    return result;
  }
  var options = [];
  var metrics = [];
  forEach(function(item) {
    var type = item.action;
    switch (type) {
      case SET_CONTENT:
        options.push({
          type: HTML,
          content: item.content
        });
        break;
      case SET_JSON:
        if (!isEmpty(item.content)) {
          forEach(function(e) {
            return options.push({
              type: JSON$1,
              content: e
            });
          }, item.content);
        }
        break;
      case REDIRECT:
        options.push(redirect$1(item));
        break;
      case SIGNAL_CLICK:
        metrics.push({
          type: CLICK,
          eventToken: item.clickTrackId
        });
        break;
    }
  }, items);
  var mbox = {
    name: name
  };
  var hasOptions = !isEmpty(options);
  if (hasOptions) {
    mbox.options = options;
  }
  var hasMetrics = !isEmpty(metrics);
  if (hasMetrics) {
    mbox.metrics = metrics;
  }
  if (isEmpty(mbox)) {
    return result;
  }
  var execute = {};
  var mboxes = [mbox];
  execute.mboxes = mboxes;
  result.execute = execute;
  return result;
}
function convertToContext(mbox, items, pageLoadEnabled) {
  if (pageLoadEnabled) {
    return createPageLoad(items);
  }
  return createMboxes(mbox, items);
}

var PAGE_LOAD_RENDERING_FAILED = "Page load rendering failed";
var MBOXES_RENDERING_FAILED = "Mboxes rendering failed";
var VIEW_RENDERING_FAILED = "View rendering failed";
var PREFETCH_RENDERING_FAILED = "Prefetch rendering failed";
var hasErrors = function hasErrors(items) {
  return !isEmpty(filter(isError, items));
};
function getPageLoadData(pageLoad) {
  var status = pageLoad.status,
    data = pageLoad.data;
  var result = {
    status: status,
    pageLoad: true
  };
  if (!isNil(data)) {
    result.data = data;
  }
  return result;
}
function getMboxData(item) {
  var status = item.status,
    mbox = item.mbox,
    data = item.data;
  var name = mbox.name;
  var result = {
    status: status,
    mbox: name
  };
  if (!isNil(data)) {
    result.data = data;
  }
  return result;
}
function getViewData(item) {
  var status = item.status,
    view = item.view,
    data = item.data;
  var name = view.name;
  var result = {
    status: status,
    view: name
  };
  if (!isNil(data)) {
    result.data = data;
  }
  return result;
}
function getPrefetchMetricsData(prefetchMetrics) {
  var status = prefetchMetrics.status,
    data = prefetchMetrics.data;
  var result = {
    status: status,
    prefetchMetrics: true
  };
  if (!isNil(data)) {
    result.data = data;
  }
  return result;
}
function handlePageLoad(pageLoad) {
  if (isNil(pageLoad)) {
    return [null];
  }
  var result = map(getPageLoadData, [pageLoad]);
  if (hasErrors(result)) {
    logWarn(PAGE_LOAD_RENDERING_FAILED, pageLoad);
  }
  return result;
}
function handleMboxes(mboxes) {
  if (isNil(mboxes)) {
    return [null];
  }
  var result = map(getMboxData, mboxes);
  if (hasErrors(result)) {
    logWarn(MBOXES_RENDERING_FAILED, mboxes);
  }
  return result;
}
function handlePrefetchMboxes(mboxes) {
  var func =
    arguments.length > 1 && arguments[1] !== undefined
      ? arguments[1]
      : sendMboxesRenderedNotifications;
  if (isNil(mboxes)) {
    return [null];
  }
  var result = map(getMboxData, mboxes);
  if (hasErrors(result)) {
    logWarn(MBOXES_RENDERING_FAILED, mboxes);
  }
  func(mboxes);
  return result;
}
function handleView(item) {
  var func =
    arguments.length > 1 && arguments[1] !== undefined
      ? arguments[1]
      : sendViewRenderedNotifications;
  if (isNil(item)) {
    return [null];
  }
  var result = map(getViewData, [item]);
  if (hasErrors(result)) {
    logWarn(VIEW_RENDERING_FAILED, item);
  }
  var view = item.view;
  if (!view.page) {
    return result;
  }
  func(item);
  return result;
}
function handlePrefetchMetrics(prefetchMetrics) {
  if (isNil(prefetchMetrics)) {
    return [null];
  }
  var result = map(getPrefetchMetricsData, [prefetchMetrics]);
  if (hasErrors(result)) {
    logWarn(PREFETCH_RENDERING_FAILED, prefetchMetrics);
  }
  return result;
}
function handleRenderingSuccess$1(values) {
  var results = flatten([
    handlePageLoad(values[0]),
    handleMboxes(values[1]),
    handlePrefetchMboxes(values[2]),
    handlePrefetchMetrics(values[3])
  ]);
  var nonNull = filter(notNil, results);
  var errors = filter(isError, nonNull);
  if (!isEmpty(errors)) {
    return reject(errors);
  }
  return resolve(nonNull);
}
function handleRenderingError$1(err) {
  return reject(err);
}

function processOptions$2(selector, item) {
  if (isEmpty(item)) {
    return;
  }
  var options = item.options;
  if (isEmpty(options)) {
    return;
  }
  forEach(function(option) {
    if (option.type !== HTML) {
      return;
    }
    var type = SET_HTML;
    var content = option.content;
    option.type = ACTIONS;
    option.content = [
      {
        type: type,
        selector: selector,
        content: content
      }
    ];
  }, options);
}
function processMetrics$1(selector, item) {
  var metrics = item.metrics;
  if (isEmpty(metrics)) {
    return;
  }
  var name = item.name;
  forEach(function(metric) {
    metric.name = name;
    metric.selector = metric.selector || selector;
  }, metrics);
}
function createRenderingContext(selector, context) {
  var result = assign({}, context);
  var _result$execute = result.execute,
    execute = _result$execute === void 0 ? {} : _result$execute,
    _result$prefetch = result.prefetch,
    prefetch = _result$prefetch === void 0 ? {} : _result$prefetch;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad,
    _execute$mboxes = execute.mboxes,
    mboxes = _execute$mboxes === void 0 ? [] : _execute$mboxes;
  var _prefetch$mboxes = prefetch.mboxes,
    prefetchMboxes = _prefetch$mboxes === void 0 ? [] : _prefetch$mboxes;
  processOptions$2(selector, pageLoad);
  forEach(function(elem) {
    return processOptions$2(selector, elem);
  }, mboxes);
  forEach(function(elem) {
    return processMetrics$1(selector, elem);
  }, mboxes);
  forEach(function(elem) {
    return processOptions$2(selector, elem);
  }, prefetchMboxes);
  forEach(function(elem) {
    return processMetrics$1(selector, elem);
  }, prefetchMboxes);
  return result;
}
function persistViewsIfPresent(context) {
  var _context$prefetch = context.prefetch,
    prefetch = _context$prefetch === void 0 ? {} : _context$prefetch;
  var _prefetch$views = prefetch.views,
    views = _prefetch$views === void 0 ? [] : _prefetch$views;
  if (isEmpty(views)) {
    return;
  }
  persistViews(views);
}
function renderContext(context) {
  var promises = [];
  var _context$execute = context.execute,
    execute = _context$execute === void 0 ? {} : _context$execute;
  var _execute$pageLoad2 = execute.pageLoad,
    pageLoad = _execute$pageLoad2 === void 0 ? {} : _execute$pageLoad2,
    _execute$mboxes2 = execute.mboxes,
    mboxes = _execute$mboxes2 === void 0 ? [] : _execute$mboxes2;
  if (!isEmpty(pageLoad)) {
    promises.push(renderPageLoad(pageLoad));
  } else {
    promises.push(resolve(null));
  }
  if (!isEmpty(mboxes)) {
    promises.push(renderMboxes(mboxes));
  } else {
    promises.push(resolve(null));
  }
  var _context$prefetch2 = context.prefetch,
    prefetch = _context$prefetch2 === void 0 ? {} : _context$prefetch2;
  var _prefetch$mboxes2 = prefetch.mboxes,
    prefetchMboxes = _prefetch$mboxes2 === void 0 ? [] : _prefetch$mboxes2,
    _prefetch$metrics = prefetch.metrics,
    metrics = _prefetch$metrics === void 0 ? [] : _prefetch$metrics;
  if (!isEmpty(prefetchMboxes)) {
    promises.push(renderPrefetchMboxes(prefetchMboxes));
  } else {
    promises.push(resolve(null));
  }
  if (isArray(metrics) && !isEmpty(metrics)) {
    promises.push(renderPrefetchMetrics(prefetch));
  } else {
    promises.push(resolve(null));
  }
  removeHidingSnippetStyle();
  return all(promises)
    .then(handleRenderingSuccess$1)
    ["catch"](handleRenderingError$1);
}
function executeRedirect(win, url) {
  delay(function() {
    return win.location.replace(url);
  });
}
function retrieveSelector(selector) {
  if (isNotBlank(selector)) {
    return selector;
  }
  if (isElement(selector)) {
    return selector;
  }
  return HEAD_TAG;
}
function showElement(selector) {
  addClass(MARKER_CSS_CLASS, selector);
}
function executeApplyOffer(options) {
  var mbox = options.mbox,
    selector = options.selector,
    actions = options.offer;
  var config = getConfig();
  var pageLoadEnabled = mbox === config[GLOBAL_MBOX_NAME];
  if (isEmpty(actions)) {
    logDebug(NO_ACTIONS);
    showElement(selector);
    removeHidingSnippetStyle();
    notifyRenderingNoOffers({
      mbox: mbox
    });
    return;
  }
  var context = convertToContext(mbox, actions, pageLoadEnabled);
  var renderingContext = createRenderingContext(selector, context);
  var redirect = getRedirect(renderingContext);
  if (!isEmpty(redirect)) {
    var url = redirect.url;
    logDebug(REDIRECT_ACTION, redirect);
    notifyRenderingRedirect({
      url: url
    });
    executeRedirect(window, url);
    return;
  }
  notifyRenderingStart({
    mbox: mbox
  });
  hidePageLoadOptions(renderingContext);
  renderContext(renderingContext)
    .then(function(execution) {
      if (isEmpty(execution)) {
        return;
      }
      notifyRenderingSucceeded({
        mbox: mbox,
        execution: execution
      });
    })
    ["catch"](function(error) {
      return notifyRenderingFailed({
        error: error
      });
    });
}
function executeApplyOffers(options) {
  var skipPrehiding =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var selector = options.selector,
    response = options.response;
  if (isEmpty(response)) {
    logDebug(NO_ACTIONS);
    showElement(selector);
    removeHidingSnippetStyle();
    notifyRenderingNoOffers({});
    publish(NO_OFFERS_EVENT);
    return resolve();
  }
  var renderingContext = createRenderingContext(selector, response);
  var redirect = getRedirect(renderingContext);
  if (!isEmpty(redirect)) {
    var url = redirect.url;
    logDebug(REDIRECT_ACTION, redirect);
    notifyRenderingRedirect({
      url: url
    });
    publish(REDIRECT_OFFER_EVENT);
    executeRedirect(window, url);
    return resolve();
  }
  notifyRenderingStart({});
  persistViewsIfPresent(renderingContext);
  publish(CACHE_UPDATED_EVENT);
  hidePageLoadOptions(renderingContext, skipPrehiding);
  return renderContext(renderingContext)
    .then(function(execution) {
      if (isEmpty(execution)) {
        return;
      }
      notifyRenderingSucceeded({
        execution: execution
      });
    })
    ["catch"](function(error) {
      return notifyRenderingFailed({
        error: error
      });
    });
}

function hasServerState(config) {
  var serverState = config[SERVER_STATE];
  if (isEmpty(serverState)) {
    return false;
  }
  var request = serverState.request,
    response = serverState.response;
  if (isEmpty(request)) {
    return false;
  }
  if (isEmpty(response)) {
    return false;
  }
  return true;
}
function getServerState(config) {
  return config[SERVER_STATE];
}

var INIT = "[page-init]";
function handleError$1(error) {
  logWarn(INIT, VIEW_DELIVERY_ERROR, error);
  addClientTrace({
    source: INIT,
    error: error
  });
  removeHidingSnippetStyle();
}
function handleSuccess(response) {
  var skipPrehiding =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var options = {
    selector: HEAD_TAG,
    response: response
  };
  logDebug(INIT, RESPONSE, response);
  addClientTrace({
    source: INIT,
    response: response
  });
  executeApplyOffers(options, skipPrehiding)["catch"](handleError$1);
}
function scrubServerStateResponse(config, response) {
  var result = assign({}, response);
  var execute = result.execute,
    prefetch = result.prefetch;
  var pageLoadEnabled = config[PAGE_LOAD_ENABLED];
  var viewsEnabled = config[VIEWS_ENABLED];
  if (execute) {
    result.execute.mboxes = null;
  }
  if (execute && !pageLoadEnabled) {
    result.execute.pageLoad = null;
  }
  if (prefetch) {
    result.prefetch.mboxes = null;
  }
  if (prefetch && !viewsEnabled) {
    result.prefetch.views = null;
  }
  return result;
}
function processServerState(config) {
  var serverState = getServerState(config);
  var request = serverState.request,
    response = serverState.response;
  var skipPrehiding = true;
  logDebug(INIT, USING_SERVER_STATE);
  addClientTrace({
    source: INIT,
    serverState: serverState
  });
  var scrubbedResponse = scrubServerStateResponse(config, response);
  hidePageLoadOptions(scrubbedResponse);
  hideAllViews(scrubbedResponse);
  processResponse({
    request: request,
    response: scrubbedResponse
  })
    .then(function(res) {
      return handleSuccess(res, skipPrehiding);
    })
    ["catch"](handleError$1);
}
function initDelivery() {
  if (!isDeliveryEnabled()) {
    logWarn(INIT, DELIVERY_DISABLED);
    addClientTrace({
      source: INIT,
      error: DELIVERY_DISABLED
    });
    return;
  }
  var config = getConfig();
  if (hasServerState(config)) {
    processServerState(config);
    return;
  }
  var pageLoadEnabled = config[PAGE_LOAD_ENABLED];
  var viewsEnabled = config[VIEWS_ENABLED];
  if (!pageLoadEnabled && !viewsEnabled) {
    logDebug(INIT, PAGE_LOAD_DISABLED);
    addClientTrace({
      source: INIT,
      error: PAGE_LOAD_DISABLED
    });
    return;
  }
  injectHidingSnippetStyle();
  var request = {};
  if (pageLoadEnabled) {
    var execute = {};
    execute.pageLoad = {};
    request.execute = execute;
  }
  if (viewsEnabled) {
    var prefetch = {};
    prefetch.views = [{}];
    request.prefetch = prefetch;
  }
  var timeout = config[TIMEOUT];
  logDebug(INIT, REQUEST, request);
  addClientTrace({
    source: INIT,
    request: request
  });
  var options = {
    request: request,
    timeout: timeout
  };
  if (!shouldUseOptin() || isTargetApproved()) {
    executeGetOffers(options)
      .then(handleSuccess)
      ["catch"](handleError$1);
    return;
  }
  fetchOptinPermissions()
    .then(function() {
      executeGetOffers(options)
        .then(handleSuccess)
        ["catch"](handleError$1);
    })
    ["catch"](handleError$1);
}

function createValid() {
  var result = {};
  result[VALID] = true;
  return result;
}
function createInvalid(error) {
  var result = {};
  result[VALID] = false;
  result[ERROR] = error;
  return result;
}
function validateMbox(mbox) {
  if (isBlank(mbox)) {
    return createInvalid(MBOX_REQUIRED);
  }
  if (mbox.length > MBOX_LENGTH) {
    return createInvalid(MBOX_TOO_LONG);
  }
  return createValid();
}
function validateGetOfferOptions(options) {
  if (!isObject(options)) {
    return createInvalid(OPTIONS_REQUIRED);
  }
  var mbox = options[MBOX];
  var mboxValidation = validateMbox(mbox);
  if (!mboxValidation[VALID]) {
    return mboxValidation;
  }
  if (!isFunction(options[SUCCESS])) {
    return createInvalid(SUCCESS_REQUIRED);
  }
  if (!isFunction(options[ERROR])) {
    return createInvalid(ERROR_REQUIRED);
  }
  return createValid();
}
function validateGetOffersOptions(options) {
  if (!isObject(options)) {
    return createInvalid(OPTIONS_REQUIRED);
  }
  var request = options.request;
  if (!isObject(request)) {
    return createInvalid(REQUEST_REQUIRED);
  }
  var execute = request.execute,
    prefetch = request.prefetch;
  if (!isObject(execute) && !isObject(prefetch)) {
    return createInvalid(EXECUTE_OR_PREFETCH_REQUIRED);
  }
  return createValid();
}
function validateSendNotificationsOptions(options) {
  if (!isObject(options)) {
    return createInvalid(OPTIONS_REQUIRED);
  }
  var request = options.request;
  if (!isObject(request)) {
    return createInvalid(REQUEST_REQUIRED);
  }
  var execute = request.execute,
    prefetch = request.prefetch,
    notifications = request.notifications;
  if (isObject(execute) || isObject(prefetch)) {
    return createInvalid(EXECUTE_OR_PREFETCH_NOT_ALLOWED);
  }
  if (!isArray(notifications)) {
    return createInvalid(NOTIFICATIONS_REQUIRED);
  }
  return createValid();
}
function validateApplyOfferOptions(options) {
  if (!isObject(options)) {
    return createInvalid(OPTIONS_REQUIRED);
  }
  var mbox = options[MBOX];
  var mboxValidation = validateMbox(mbox);
  if (!mboxValidation[VALID]) {
    return mboxValidation;
  }
  var offer = options[OFFER];
  if (!isArray(offer)) {
    return createInvalid(OFFER_REQUIRED);
  }
  return createValid();
}
function validateApplyOffersOptions(options) {
  if (!isObject(options)) {
    return createInvalid(OPTIONS_REQUIRED);
  }
  var response = options.response;
  if (!isObject(response)) {
    return createInvalid(RESPONE_REQUIRED);
  }
  return createValid();
}
function validateTrackEventOptions(options) {
  if (!isObject(options)) {
    return createInvalid(OPTIONS_REQUIRED);
  }
  var mbox = options[MBOX];
  var mboxValidation = validateMbox(mbox);
  if (!mboxValidation[VALID]) {
    return mboxValidation;
  }
  return createValid();
}

function redirect$2(option) {
  return {
    action: REDIRECT,
    url: option.content
  };
}
function setHtml$3(action) {
  var result = {};
  result.action = SET_CONTENT;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function setText$4(action) {
  var result = {};
  result.action = SET_TEXT;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function appendHtml$2(action) {
  var result = {};
  result.action = APPEND_CONTENT;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function prependHtml$2(action) {
  var result = {};
  result.action = PREPEND_CONTENT;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function replaceHtml$2(action) {
  var result = {};
  result.action = REPLACE_CONTENT;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function insertBefore$3(action) {
  var result = {};
  result.action = INSERT_BEFORE;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function insertAfter$3(action) {
  var result = {};
  result.action = INSERT_AFTER;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function customCode$3(action) {
  var result = {};
  result.action = CUSTOM_CODE;
  result.content = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function setAttribute$3(action) {
  var attribute = keys(action.content)[0];
  var result = {};
  result.action = SET_ATTRIBUTE;
  result.attribute = attribute;
  result.value = action.content[attribute];
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function setImageSource$2(action) {
  var result = {};
  result.action = SET_ATTRIBUTE;
  result.attribute = SRC;
  result.value = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function setStyle$3(action) {
  var result = {};
  result.action = SET_STYLE;
  result.style = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function resize$2(action) {
  var result = {};
  result.action = SET_STYLE;
  result.style = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function move$2(action) {
  var result = {};
  result.action = SET_STYLE;
  result.style = action.content;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function remove$4(action) {
  var result = {};
  result.action = REMOVE;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function rearrange$3(action) {
  var result = {};
  result.action = REARRANGE;
  result.from = action.content.from;
  result.to = action.content.to;
  result.selector = action.selector;
  result.cssSelector = action.cssSelector;
  return result;
}
function processActions(actions) {
  var result = [];
  forEach(function(action) {
    var type = action.type;
    switch (type) {
      case SET_HTML:
        result.push(setHtml$3(action));
        break;
      case SET_TEXT:
        result.push(setText$4(action));
        break;
      case APPEND_HTML:
        result.push(appendHtml$2(action));
        break;
      case PREPEND_HTML:
        result.push(prependHtml$2(action));
        break;
      case REPLACE_HTML:
        result.push(replaceHtml$2(action));
        break;
      case INSERT_BEFORE:
        result.push(insertBefore$3(action));
        break;
      case INSERT_AFTER:
        result.push(insertAfter$3(action));
        break;
      case CUSTOM_CODE:
        result.push(customCode$3(action));
        break;
      case SET_ATTRIBUTE:
        result.push(setAttribute$3(action));
        break;
      case SET_IMAGE_SOURCE:
        result.push(setImageSource$2(action));
        break;
      case SET_STYLE:
        result.push(setStyle$3(action));
        break;
      case RESIZE:
        result.push(resize$2(action));
        break;
      case MOVE:
        result.push(move$2(action));
        break;
      case REMOVE:
        result.push(remove$4(action));
        break;
      case REARRANGE:
        result.push(rearrange$3(action));
        break;
      case REDIRECT:
        result.push(redirect$2(action));
        break;
    }
  }, actions);
  return result;
}
function processMetrics$2(metrics) {
  if (isEmpty(metrics)) {
    return [];
  }
  var result = [];
  forEach(function(m) {
    if (m.type !== CLICK) {
      return;
    }
    if (hasSelector(m)) {
      result.push({
        action: TRACK_CLICK,
        selector: m.selector,
        clickTrackId: m.eventToken
      });
    } else {
      result.push({
        action: SIGNAL_CLICK,
        clickTrackId: m.eventToken
      });
    }
  }, metrics);
  return result;
}
function processItem(item) {
  if (isEmpty(item)) {
    return [];
  }
  var htmls = [];
  var jsons = [];
  var actions = [];
  var _item$options = item.options,
    options = _item$options === void 0 ? [] : _item$options,
    _item$metrics = item.metrics,
    metrics = _item$metrics === void 0 ? [] : _item$metrics;
  forEach(function(option) {
    var type = option.type;
    switch (type) {
      case HTML:
        htmls.push(option.content);
        break;
      case JSON$1:
        jsons.push(option.content);
        break;
      case REDIRECT:
        actions.push(redirect$2(option));
        break;
      case ACTIONS:
        actions.push.apply(actions, processActions(option.content));
        break;
    }
  }, options);
  if (!isEmpty(htmls)) {
    actions.push({
      action: SET_CONTENT,
      content: htmls.join("")
    });
  }
  if (!isEmpty(jsons)) {
    actions.push({
      action: SET_JSON,
      content: jsons
    });
  }
  var clickActions = processMetrics$2(metrics);
  if (!isEmpty(clickActions)) {
    actions.push.apply(actions, clickActions);
  }
  return actions;
}
function convertToActions(response) {
  var _response$execute = response.execute,
    execute = _response$execute === void 0 ? {} : _response$execute;
  var _execute$pageLoad = execute.pageLoad,
    pageLoad = _execute$pageLoad === void 0 ? {} : _execute$pageLoad;
  var _execute$mboxes = execute.mboxes,
    mboxes = _execute$mboxes === void 0 ? [] : _execute$mboxes;
  var result = [];
  result.push.apply(result, processItem(pageLoad));
  result.push.apply(result, flatten(map(processItem, mboxes)));
  return result;
}

var GET_OFFER = "[getOffer()]";
function handleRequestSuccess$1(options, response) {
  var actions = convertToActions(response);
  options[SUCCESS](actions);
}
function handleRequestError$1(options, error) {
  var status = error[STATUS] || UNKNOWN;
  options[ERROR](status, error);
}
function getOffer(options) {
  var validationResult = validateGetOfferOptions(options);
  var error = validationResult[ERROR];
  if (!validationResult[VALID]) {
    logWarn(GET_OFFER, error);
    addClientTrace({
      source: GET_OFFER,
      options: options,
      error: error
    });
    return;
  }
  if (!isDeliveryEnabled()) {
    delay(options[ERROR](WARNING, DELIVERY_DISABLED));
    logWarn(GET_OFFER, DELIVERY_DISABLED);
    addClientTrace({
      source: GET_OFFER,
      options: options,
      error: DELIVERY_DISABLED
    });
    return;
  }
  var successFunc = function successFunc(response) {
    return handleRequestSuccess$1(options, response);
  };
  var errorFunc = function errorFunc(err) {
    return handleRequestError$1(options, err);
  };
  logDebug(GET_OFFER, options);
  addClientTrace({
    source: GET_OFFER,
    options: options
  });
  if (!shouldUseOptin() || isTargetApproved()) {
    executeGetOffer(options)
      .then(successFunc)
      ["catch"](errorFunc);
    return;
  }
  fetchOptinPermissions().then(function() {
    executeGetOffer(options)
      .then(successFunc)
      ["catch"](errorFunc);
  });
}

var GET_OFFERS = "[getOffers()]";
function getOffers(options) {
  var validationResult = validateGetOffersOptions(options);
  var error = validationResult[ERROR];
  if (!validationResult[VALID]) {
    logWarn(GET_OFFERS, error);
    addClientTrace({
      source: GET_OFFERS,
      options: options,
      error: error
    });
    return reject(validationResult);
  }
  if (!isDeliveryEnabled()) {
    logWarn(GET_OFFERS, DELIVERY_DISABLED);
    addClientTrace({
      source: GET_OFFERS,
      options: options,
      error: DELIVERY_DISABLED
    });
    return reject(new Error(DELIVERY_DISABLED));
  }
  logDebug(GET_OFFERS, options);
  addClientTrace({
    source: GET_OFFERS,
    options: options
  });
  if (!shouldUseOptin() || isTargetApproved()) {
    return executeGetOffers(options);
  }
  return fetchOptinPermissions().then(function() {
    return executeGetOffers(options);
  });
}

var APPLY_OFFER = "[applyOffer()]";
function applyOffer(options) {
  var selector = retrieveSelector(options.selector);
  var validationResult = validateApplyOfferOptions(options);
  var error = validationResult[ERROR];
  if (!validationResult[VALID]) {
    logWarn(APPLY_OFFER, options, error);
    addClientTrace({
      source: APPLY_OFFER,
      options: options,
      error: error
    });
    showElement(selector);
    return;
  }
  if (!isDeliveryEnabled()) {
    logWarn(APPLY_OFFER, DELIVERY_DISABLED);
    addClientTrace({
      source: APPLY_OFFER,
      options: options,
      error: DELIVERY_DISABLED
    });
    showElement(selector);
    return;
  }
  options.selector = selector;
  logDebug(APPLY_OFFER, options);
  addClientTrace({
    source: APPLY_OFFER,
    options: options
  });
  executeApplyOffer(options);
}

var APPLY_OFFERS = "[applyOffers()]";
function applyOffers(options) {
  var selector = retrieveSelector(options.selector);
  var validationResult = validateApplyOffersOptions(options);
  var error = validationResult[ERROR];
  if (!validationResult[VALID]) {
    logWarn(APPLY_OFFERS, options, error);
    addClientTrace({
      source: APPLY_OFFERS,
      options: options,
      error: error
    });
    showElement(selector);
    return reject(validationResult);
  }
  if (!isDeliveryEnabled()) {
    logWarn(APPLY_OFFERS, DELIVERY_DISABLED);
    addClientTrace({
      source: APPLY_OFFERS,
      options: options,
      error: DELIVERY_DISABLED
    });
    showElement(selector);
    return reject(new Error(DELIVERY_DISABLED));
  }
  options.selector = selector;
  logDebug(APPLY_OFFERS, options);
  addClientTrace({
    source: APPLY_OFFERS,
    options: options
  });
  return executeApplyOffers(options);
}

var SEND_NOTIFICATIONS = "[sendNotifications()]";
function sendNotifications(options) {
  var config = getConfig();
  var globalMbox = config[GLOBAL_MBOX_NAME];
  var _options$consumerId = options.consumerId,
    consumerId =
      _options$consumerId === void 0 ? globalMbox : _options$consumerId,
    request = options.request;
  var validationResult = validateSendNotificationsOptions(options);
  var error = validationResult[ERROR];
  if (!validationResult[VALID]) {
    logWarn(SEND_NOTIFICATIONS, error);
    addClientTrace({
      source: SEND_NOTIFICATIONS,
      options: options,
      error: error
    });
    return;
  }
  if (!isDeliveryEnabled()) {
    logWarn(SEND_NOTIFICATIONS, DELIVERY_DISABLED);
    addClientTrace({
      source: SEND_NOTIFICATIONS,
      options: options,
      error: DELIVERY_DISABLED
    });
    return;
  }
  logDebug(SEND_NOTIFICATIONS, options);
  addClientTrace({
    source: SEND_NOTIFICATIONS,
    options: options
  });
  var notifications = request.notifications;
  var notificationsRequest = createSyncNotificationRequest(
    consumerId,
    {},
    notifications
  );
  if (shouldUseOptin() && !isTargetApproved()) {
    logWarn(SEND_NOTIFICATIONS, ERROR_TARGET_NOT_OPTED_IN);
    return;
  }
  executeBeaconNotification(notificationsRequest);
}

var TRACK_EVENT = "[trackEvent()]";
function normalizeOptions(config, options) {
  var mbox = options[MBOX];
  var result = assign({}, options);
  var optsParams = isObject(options.params) ? options.params : {};
  result[PARAMS] = assign({}, getTargetPageParams(mbox), optsParams);
  result[TIMEOUT] = getTimeout(config, options[TIMEOUT]);
  result[SUCCESS] = isFunction(options[SUCCESS]) ? options[SUCCESS] : noop;
  result[ERROR] = isFunction(options[ERROR]) ? options[ERROR] : noop;
  return result;
}
function shouldTrackBySelector(options) {
  var type = options[TYPE];
  var selector = options[SELECTOR];
  return isNotBlank(type) && (isNotBlank(selector) || isElement(selector));
}
function trackImmediateInternal(options) {
  var mbox = options.mbox;
  var optsParams = isObject(options.params) ? options.params : {};
  var params = assign({}, getTargetPageParams(mbox), optsParams);
  var type = DISPLAY_EVENT;
  var requestDetails = createRequestDetails({}, params);
  var notification = createNotification(requestDetails, type, []);
  notification.mbox = {
    name: mbox
  };
  var request = createSyncNotificationRequest(mbox, params, [notification]);
  if (executeBeaconNotification(request)) {
    logDebug(TRACK_EVENT_SUCCESS, options);
    options[SUCCESS]();
    return;
  }
  logWarn(TRACK_EVENT_ERROR, options);
  options[ERROR](UNKNOWN, TRACK_EVENT_ERROR);
}
function trackImmediate(options) {
  if (shouldUseOptin() && !isTargetApproved()) {
    logWarn(TRACK_EVENT_ERROR, ERROR_TARGET_NOT_OPTED_IN);
    options[ERROR](ERROR, ERROR_TARGET_NOT_OPTED_IN);
    return;
  }
  trackImmediateInternal(options);
}
function handleEvent(options) {
  trackImmediate(options);
  return !options.preventDefault;
}
function trackBySelector(options) {
  var selector = options[SELECTOR];
  var type = options[TYPE];
  var elements = toArray(select(selector));
  var onEvent = function onEvent() {
    return handleEvent(options);
  };
  forEach(function(element) {
    return addEventListener(type, onEvent, element);
  }, elements);
}
function trackEvent(opts) {
  var validationResult = validateTrackEventOptions(opts);
  var error = validationResult[ERROR];
  if (!validationResult[VALID]) {
    logWarn(TRACK_EVENT, error);
    addClientTrace({
      source: TRACK_EVENT,
      options: opts,
      error: error
    });
    return;
  }
  var config = getConfig();
  var options = normalizeOptions(config, opts);
  if (!isDeliveryEnabled()) {
    logWarn(TRACK_EVENT, DELIVERY_DISABLED);
    delay(options[ERROR](WARNING, DELIVERY_DISABLED));
    addClientTrace({
      source: TRACK_EVENT,
      options: opts,
      error: DELIVERY_DISABLED
    });
    return;
  }
  logDebug(TRACK_EVENT, options);
  addClientTrace({
    source: TRACK_EVENT,
    options: options
  });
  if (shouldTrackBySelector(options)) {
    trackBySelector(options);
    return;
  }
  trackImmediate(options);
}

var TRIGGER_VIEW = "[triggerView()]";
var TASKS = [];
var LOADING = 0;
var LOADED = 1;
var STATE = LOADING;
function executeApplyOffersForView(view) {
  hideViewOptions(view);
  return renderView(view)
    .then(handleView)
    .then(function(execution) {
      if (isEmpty(execution)) {
        return;
      }
      notifyRenderingSucceeded({
        execution: execution
      });
    })
    ["catch"](function(error) {
      logWarn(RENDERING_VIEW_FAILED, error);
      notifyRenderingFailed({
        error: error
      });
    });
}
function processTriggeredViews() {
  while (TASKS.length > 0) {
    var triggeredView = TASKS.pop();
    var viewName = triggeredView.viewName;
    var persistedView = findView(viewName, triggeredView);
    if (!isNil(persistedView)) {
      executeApplyOffersForView(persistedView);
    }
  }
}
function processResponseEvents() {
  STATE = LOADED;
  processTriggeredViews();
}
function setupListeners() {
  subscribe(CACHE_UPDATED_EVENT, processResponseEvents);
  subscribe(NO_OFFERS_EVENT, processResponseEvents);
  subscribe(REDIRECT_OFFER_EVENT, processResponseEvents);
}
function getTriggerViewOptions(viewName, opts) {
  var result = {};
  result.viewName = viewName;
  result.impressionId = uuid();
  result.page = true;
  if (!isEmpty(opts)) {
    result.page = !!opts.page;
  }
  return result;
}
function handleTriggeredView(options) {
  handleAuthoringTriggeredView(options);
  var viewName = options.viewName;
  var persistedView = findView(viewName, options);
  if (isNil(persistedView) && options.page) {
    sendViewTriggeredNotifications(options);
  }
  TASKS.push(options);
  if (STATE !== LOADED) {
    return;
  }
  processTriggeredViews();
}
function triggerView(value, opts) {
  if (!isString(value) || isBlank(value)) {
    logWarn(TRIGGER_VIEW, VIEW_NAME_ERROR, value);
    addClientTrace({
      source: TRIGGER_VIEW,
      view: value,
      error: VIEW_NAME_ERROR
    });
    return;
  }
  var viewName = value.toLowerCase();
  var options = getTriggerViewOptions(viewName, opts);
  logDebug(TRIGGER_VIEW, viewName, options);
  addClientTrace({
    source: TRIGGER_VIEW,
    view: viewName,
    options: options
  });
  handleTriggeredView(options);
}
setupListeners();

var COMMON_MBOX_WARN =
  "function has been deprecated. Please use getOffer() and applyOffer() functions instead.";
var REGISTER_EXTENSION_WARN =
  "adobe.target.registerExtension() function has been deprecated. Please review the documentation for alternatives.";
var MBOX_CREATE_WARN = "mboxCreate() " + COMMON_MBOX_WARN;
var MBOX_DEFINE_WARN = "mboxDefine() " + COMMON_MBOX_WARN;
var MBOX_UPDATE_WARN = "mboxUpdate() " + COMMON_MBOX_WARN;
function registerExtension() {
  logWarn(REGISTER_EXTENSION_WARN, arguments);
}
function mboxCreate() {
  logWarn(MBOX_CREATE_WARN, arguments);
}
function mboxDefine() {
  logWarn(MBOX_DEFINE_WARN, arguments);
}
function mboxUpdate() {
  logWarn(MBOX_UPDATE_WARN, arguments);
}

function overridePublicApi(win) {
  win.adobe = win.adobe || {};
  win.adobe.target = {
    VERSION: "",
    event: {},
    getOffer: noop,
    getOffers: noopPromise,
    applyOffer: noop,
    applyOffers: noopPromise,
    sendNotifications: noop,
    trackEvent: noop,
    triggerView: noop,
    registerExtension: noop,
    init: noop
  };
  win.mboxCreate = noop;
  win.mboxDefine = noop;
  win.mboxUpdate = noop;
}
function init(win, doc, settings) {
  if (
    win.adobe &&
    win.adobe.target &&
    typeof win.adobe.target.getOffer !== "undefined"
  ) {
    logWarn(ALREADY_INITIALIZED);
    return;
  }
  initConfig(settings);
  var config = getConfig();
  var version = config[VERSION];
  win.adobe = win.adobe || {};
  win.adobe.target = win.adobe.target || {};
  win.adobe.target.VERSION = version;
  win.adobe.target.event = {
    LIBRARY_LOADED: LIBRARY_LOADED,
    REQUEST_START: REQUEST_START,
    REQUEST_SUCCEEDED: REQUEST_SUCCEEDED$1,
    REQUEST_FAILED: REQUEST_FAILED$1,
    CONTENT_RENDERING_START: CONTENT_RENDERING_START,
    CONTENT_RENDERING_SUCCEEDED: CONTENT_RENDERING_SUCCEEDED,
    CONTENT_RENDERING_FAILED: CONTENT_RENDERING_FAILED,
    CONTENT_RENDERING_NO_OFFERS: CONTENT_RENDERING_NO_OFFERS,
    CONTENT_RENDERING_REDIRECT: CONTENT_RENDERING_REDIRECT
  };
  if (!config[ENABLED]) {
    overridePublicApi(win);
    logWarn(DELIVERY_DISABLED);
    return;
  }
  initTraces();
  initAuthoringCode();
  initQaMode(win);
  initPreviewMode(win);
  win.adobe.target.getOffer = getOffer;
  win.adobe.target.getOffers = getOffers;
  win.adobe.target.applyOffer = applyOffer;
  win.adobe.target.applyOffers = applyOffers;
  win.adobe.target.sendNotifications = sendNotifications;
  win.adobe.target.trackEvent = trackEvent;
  win.adobe.target.triggerView = triggerView;
  win.adobe.target.registerExtension = registerExtension;
  win.mboxCreate = mboxCreate;
  win.mboxDefine = mboxDefine;
  win.mboxUpdate = mboxUpdate;
  notifyLibraryLoaded();
}
var bootstrapLaunch = {
  init: init,
  initConfig: initConfig,
  initDelivery: initDelivery
};

module.exports = bootstrapLaunch;

          }

        },
        "adobe-target-v2/lib/messages.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

module.exports = {
  ALREADY_INITIALIZED: "AT: Adobe Target has already been initialized.",
  DELIVERY_DISABLED: "AT: Adobe Target content delivery is disabled. Update your DOCTYPE to support Standards mode.",
  NO_REQUEST: "AT: Target library is either not loaded or disabled, no request will be executed"
};
          }

        },
        "adobe-target-v2/lib/modules/params-store.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

var overrideProps = require("./object-override");

var params = {};
var pageLoadParams = {};

function isComplexParam(param) {
  if (typeof param === "undefined" || param == null) return false;
  return Object.prototype.hasOwnProperty.call(param, "value") && param.checked != null;
}

function processParams(items) {
  var result = {};
  var keys = Object.keys(items);

  keys.forEach(function (key) {
    var param = items[key];

    if (!isComplexParam(param)) {
      result[key] = param;
      return;
    }

    var checked = param.checked,
        value = param.value;


    if (checked && value === "") {
      return;
    }

    result[key] = value;
  });

  return result;
}

function mergeParams(items) {
  var processedParams = processParams(items);
  overrideProps(params, processedParams);
}

function mergePageLoadParams(items) {
  var processedParams = processParams(items);
  overrideProps(pageLoadParams, processedParams);
}

function getParams() {
  return params;
}

function getPageLoadParams() {
  return pageLoadParams;
}

module.exports = {
  mergeParams: mergeParams,
  mergePageLoadParams: mergePageLoadParams,
  getParams: getParams,
  getPageLoadParams: getPageLoadParams
};
          }

        },
        "adobe-target-v2/lib/targetSettings.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

var extensionSettings = turbine.getExtensionSettings();
var targetSettings = extensionSettings.targetSettings || {};

module.exports = {
  extensionSettings: extensionSettings,
  targetSettings: targetSettings
};
          }

        },
        "adobe-target-v2/lib/modules/object-override.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

function overrideProp(overriden, overriding, field, undef) {
  if (overriding[field] !== undef) {
    overriden[field] = overriding[field]; //eslint-disable-line
  }
}

function subsetFilter(key) {
  if (Array.isArray(this.subset)) {
    return this.subset.indexOf(key) !== -1;
  }
  return true;
}

module.exports = function (overriden, overriding, subset) {
  Object.keys(overriding).filter(subsetFilter, { subset: subset }).forEach(function (key) {
    overrideProp(overriden, overriding, key);
  });
};
          }

        },
        "adobe-target-v2/lib/librarySettings.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

var TARGET_DEFAULT_SETTINGS = {
  version: "2.5.0"
};

module.exports = {
  TARGET_DEFAULT_SETTINGS: TARGET_DEFAULT_SETTINGS
};
          }

        },
        "adobe-target-v2/lib/modules/event-util.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

function addEventListener(elem, type, handler) {
  elem.addEventListener(type, handler);
}

function removeEventListener(elem, type, handler) {
  elem.removeEventListener(type, handler);
}

module.exports = {
  addEventListener: addEventListener,
  removeEventListener: removeEventListener
};
          }

        },
        "adobe-target-v2/lib/modules/page-load.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

var _librarySettings = require("../librarySettings");

var win = require("@adobe/reactor-window"); /* eslint-disable import/no-extraneous-dependencies */

var overrideProps = require("./object-override");

var _require = require("./params-store"),
    getParams = _require.getParams,
    getPageLoadParams = _require.getPageLoadParams;

var _require2 = require("../targetSettings"),
    targetSettings = _require2.targetSettings;

module.exports = function (settings) {
  targetSettings.mboxParams = getParams();
  targetSettings.globalMboxParams = getPageLoadParams();

  overrideProps(targetSettings, settings, ["bodyHidingEnabled", "bodyHiddenStyle"]);

  overrideProps(targetSettings, win.targetGlobalSettings || {}, ["enabled", "bodyHidingEnabled", "bodyHiddenStyle"]);
  overrideProps(targetSettings, _librarySettings.TARGET_DEFAULT_SETTINGS || {}, ["version"]);

  return targetSettings;
};
          }

        }
      }
    },
    "adobe-alloy": {
      "displayName": "Adobe Experience Platform Web SDK",
      "hostedLibFilesBaseUrl": "https://assets.adobedtm.com/extensions/EP6c968e8e304b4cd480cae98810effca1/",
      "settings": {
        "instances": [
          {
            "name": "alloy",
            "edgeDomain": "sstats.adobe.com",
            "edgeConfigId": "275a1cc1-992e-4c14-b63a-c28ac0ccbf48",
            "defaultConsent": "%aep_consent%",
            "onBeforeEventSend": function(content) {
  // Modify content.xdm as necessary. There is no need to wrap the code in a function
// or return a value. For example:
// content.xdm.web.webPageDetails.name = "Checkout";

},
            "stagingEdgeConfigId": "275a1cc1-992e-4c14-b63a-c28ac0ccbf48:stage",
            "clickCollectionEnabled": false,
            "developmentEdgeConfigId": "275a1cc1-992e-4c14-b63a-c28ac0ccbf48:dev"
          }
        ]
      },
      "modules": {
        "adobe-alloy/dist/lib/dataElements/eventMergeId/index.js": {
          "name": "event-merge-id",
          "displayName": "Event merge ID",
          "script": function(module, exports, require, turbine) {
"use strict";

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
var createEventMergeId = require("./createEventMergeId");

var instanceManager = require("../../instanceManager/index");

var eventMergeIdCache = require("../../eventMergeIdCache");

module.exports = createEventMergeId({
  instanceManager: instanceManager,
  eventMergeIdCache: eventMergeIdCache
});
          }

        },
        "adobe-alloy/dist/lib/dataElements/xdmObject/index.js": {
          "name": "xdm-object",
          "displayName": "XDM object",
          "script": function(module, exports, require, turbine) {
"use strict";

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
module.exports = function (settings) {
  return settings.data;
};
          }

        },
        "adobe-alloy/dist/lib/instanceManager/index.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// The Adobe Launch bundler doesn't handle requiring npm packages, but this is
// equivalent to require("@adobe/alloy"). We could run our own bundler to do this,
// but this works. If Alloy changed the location of its cjs entry point we would
// need to change the path here.
var _require = require("../alloy"),
    createInstance = _require.createInstance,
    createEventMergeId = _require.createEventMergeId;

var createInstanceManager = require("./createInstanceManager");

var injectWrapOnBeforeEventSend = require("./injectWrapOnBeforeEventSend");

var version = "2.7.3";
var wrapOnBeforeEventSend = injectWrapOnBeforeEventSend({
  version: version
});
module.exports = createInstanceManager({
  turbine: turbine,
  window: window,
  createInstance: createInstance,
  createEventMergeId: createEventMergeId,
  orgId: _satellite.company.orgId,
  wrapOnBeforeEventSend: wrapOnBeforeEventSend
});
          }

        },
        "adobe-alloy/dist/lib/dataElements/eventMergeId/createEventMergeId.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
module.exports = function (_ref) {
  var instanceManager = _ref.instanceManager,
      eventMergeIdCache = _ref.eventMergeIdCache;
  return function (settings) {
    // Optimally we would use the data element name as the cache ID, but
    // we don't receive the data element name from Turbine, so we have to use
    // a separate cache ID that was generated when the data element was created.
    var cacheId = settings.cacheId;
    var eventMergeId = eventMergeIdCache.getByCacheId(cacheId);

    if (!eventMergeId) {
      var _instanceManager$crea = instanceManager.createEventMergeId();

      eventMergeId = _instanceManager$crea.eventMergeId;
      eventMergeIdCache.set(cacheId, eventMergeId);
    }

    return eventMergeId;
  };
};
          }

        },
        "adobe-alloy/dist/lib/eventMergeIdCache.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
var eventMergeIdByCacheId = {};
/**
 * Caches event merge IDs by a cache ID.
 */

module.exports = {
  set: function set(cacheId, eventMergeId) {
    eventMergeIdByCacheId[cacheId] = eventMergeId;
  },
  getByCacheId: function getByCacheId(cacheId) {
    return eventMergeIdByCacheId[cacheId];
  },
  clearByEventMergeId: function clearByEventMergeId(eventMergeId) {
    Object.keys(eventMergeIdByCacheId).forEach(function (cacheId) {
      if (eventMergeIdByCacheId[cacheId] === eventMergeId) {
        delete eventMergeIdByCacheId[cacheId];
      }
    });
  }
};
          }

        },
        "adobe-alloy/dist/lib/alloy.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInstance = exports.createEventMergeId = void 0;

var _reactorObjectAssign = _interopRequireDefault(require("@adobe/reactor-object-assign"));

var _reactorCookie = _interopRequireDefault(require("@adobe/reactor-cookie"));

var _reactorQueryString = _interopRequireDefault(require("@adobe/reactor-query-string"));

var _reactorLoadScript = _interopRequireDefault(require("@adobe/reactor-load-script"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
var CHROME = "Chrome";
var EDGE = "Edge";
var EDGE_CHROMIUM = "EdgeChromium";
var FIREFOX = "Firefox";
var IE = "IE";
var SAFARI = "Safari";
var UNKNOWN = "Unknown";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Determines whether an array includes a certain value.
 * @param {Array} arr Array to search.
 * @param {*} item The item for which to search.
 * @returns {boolean}
 */

var includes = function includes(arr, item) {
  return arr.indexOf(item) !== -1;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// we don't know. We also assume "unknown" browsers support third-party cookies,
// though we don't really know that either. We're making best guesses.


var browsersSupportingThirdPartyCookie = [CHROME, EDGE, EDGE_CHROMIUM, IE, UNKNOWN];

var areThirdPartyCookiesSupportedByDefault = function areThirdPartyCookiesSupportedByDefault(browser) {
  return includes(browsersSupportingThirdPartyCookie, browser);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var MILLISECOND = 1;
var SECOND = MILLISECOND * 1000;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;

var convertTimes = function convertTimes(fromUnit, toUnit, amount) {
  return fromUnit * amount / toUnit;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns true whether the value is null or undefined.
 * @param {*} value
 * @returns {boolean}
 */


var isNil = function isNil(value) {
  return value == null;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is an object.
 * @param {*} value
 * @returns {boolean}
 */


var isObject = function isObject(value) {
  return !isNil(value) && !Array.isArray(value) && _typeof(value) === "object";
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var deepAssignObject = function deepAssignObject(target, source) {
  Object.keys(source).forEach(function (key) {
    if (isObject(target[key]) && isObject(source[key])) {
      deepAssignObject(target[key], source[key]);
      return;
    }

    target[key] = source[key];
  });
};
/**
 * Recursively copy the values of all enumerable own properties from a source item to a target item if the both items are objects
 * @param {Object} target - a target object
 * @param {...Object} source - an array of source objects
 * @example
 * deepAssign({ a: 'a', b: 'b' }, { b: 'B', c: 'c' });
 * // { a: 'a', b: 'B', c: 'c' }
 */


var deepAssign = function deepAssign(target) {
  if (isNil(target)) {
    throw new TypeError('deepAssign "target" cannot be null or undefined');
  }

  var result = Object(target);

  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (source) {
    return deepAssignObject(result, Object(source));
  });
  return result;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Creates a function that, when passed an object of updates, will merge
 * the updates onto the current value of a payload property.
 * @param {Object} content The base object to modify
 * @param {String } key The property to merge updates into. This
 * can be a dot-notation property path.
 * @returns {Function}
 */


var createMerger = function createMerger(content, key) {
  return function (updates) {
    var propertyPath = key.split(".");
    var hostObjectForUpdates = propertyPath.reduce(function (obj, propertyName) {
      obj[propertyName] = obj[propertyName] || {};
      return obj[propertyName];
    }, content);
    deepAssign(hostObjectForUpdates, updates);
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Allows callbacks to be registered and then later called. When the
 * callbacks are called, their responses are combined into a single promise.
 */


var createCallbackAggregator = function createCallbackAggregator() {
  var callbacks = [];
  return {
    add: function add(callback) {
      callbacks.push(callback);
    },
    call: function call() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      // While this utility doesn't necessarily need to be doing the
      // Promise.all, it's currently useful everywhere this is used and
      // reduces repetitive code. We can factor it out later if we want
      // to make this utility more "pure".
      return Promise.all(callbacks.map(function (callback) {
        return callback.apply(void 0, args);
      }));
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Sequences tasks.
 */


var createTaskQueue = function createTaskQueue() {
  var queueLength = 0;
  var lastPromiseInQueue = Promise.resolve();
  return {
    /**
     * Add a task to the queue. If no task is currenty running,
     * the task will begin immediately.
     * @param {Function} task A function that will be called when
     * the task should be run. If the task it asynchronous, it should
     * return a promise.
     * @returns {Promise} A promise that will be resolved or rejected
     * with whatever value the task resolved or rejects its promise.
     */
    addTask: function addTask(task) {
      queueLength += 1;

      var lastPromiseFulfilledHandler = function lastPromiseFulfilledHandler() {
        return task()["finally"](function () {
          queueLength -= 1;
        });
      };

      lastPromiseInQueue = lastPromiseInQueue.then(lastPromiseFulfilledHandler, lastPromiseFulfilledHandler);
      return lastPromiseInQueue;
    },

    /**
     * How many tasks are in the queue. This includes the task
     * that's currently running.
     * @returns {number}
     */
    get length() {
      return queueLength;
    }

  };
};
/* eslint-disable */

/*
crc32 Â· JavaScript Function to Calculate CRC32 of a String
Description
  Below is a JavaScript function to calculate CRC32 of a string. 
  The string can be either ASCII or Unicode. 
  Unicode strings will be encoded in UTF-8. 
  The polynomial used in calculation is 0xedb88320. 
  This polynomial is used in Ethernet, Gzip, PNG, SATA and many other technologies.
*/


var crc32 = function () {
  var table = [];

  for (var _i = 0; _i < 256; _i++) {
    var c = _i;

    for (var j = 0; j < 8; j++) {
      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
    }

    table.push(c);
  }

  return function (str, crc) {
    str = unescape(encodeURIComponent(str));
    if (!crc) crc = 0;
    crc = crc ^ -1;

    for (var _i2 = 0; _i2 < str.length; _i2++) {
      var y = (crc ^ str.charCodeAt(_i2)) & 0xff;
      crc = crc >>> 8 ^ table[y];
    }

    crc = crc ^ -1;
    return crc >>> 0;
  };
}();
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * A simple utility for managing a promise's state outside of
 * the promise's "executor" (the function passed into the constructor).
 */


var defer = function defer() {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Whether a string ends with the characters of a specified string
 * @param {String} str The string to search within.
 * @param {String} suffix The string to search for.
 * @returns {boolean}
 */


var endsWith = function endsWith(str, suffix) {
  return str.substr(-suffix.length) === suffix;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns the first item in the array that satisfies the provided testing function.
 * @param {Array} arr The array to search.
 * @param {Function} predicate Function that will be called for each item. Arguments
 * will be the item, the item index, then the array itself.
 * @returns {*}
 */


var find = function find(arr, predicate) {
  for (var _i3 = 0; _i3 < arr.length; _i3 += 1) {
    var item = arr[_i3];

    if (predicate(item, _i3, arr)) {
      return item;
    }
  }

  return undefined;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var appendNode = function appendNode(parent, node) {
  return parent.appendChild(node);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var populateElementProperties = function populateElementProperties(element, props) {
  Object.keys(props).forEach(function (key) {
    // The following is to support setting style properties to avoid CSP errors.
    if (key === "style" && isObject(props[key])) {
      var styleProps = props[key];
      Object.keys(styleProps).forEach(function (styleKey) {
        element.style[styleKey] = styleProps[styleKey];
      });
    } else {
      element[key] = props[key];
    }
  });
};

var createNode = function createNode(tag) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var doc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : document;
  var result = doc.createElement(tag);
  Object.keys(attrs).forEach(function (key) {
    // TODO: To highlight CSP problems consider throwing a descriptive error
    //       if nonce is available and key is style.
    result.setAttribute(key, attrs[key]);
  });
  populateElementProperties(result, props);
  children.forEach(function (child) {
    return appendNode(result, child);
  });
  return result;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var BODY = "BODY";
var IFRAME = "IFRAME";
var IMG = "IMG";
var DIV = "DIV";
var STYLE = "STYLE";
var SCRIPT = "SCRIPT";
var SRC = "src";
var HEAD = "HEAD";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Fires an image pixel from the current document's window.
 * @param {object} currentDocument
 * @param {string} src
 * @returns {Promise}
 */

var fireImage = function fireImage(_ref) {
  var src = _ref.src,
      _ref$currentDocument = _ref.currentDocument,
      currentDocument = _ref$currentDocument === void 0 ? document : _ref$currentDocument;
  return new Promise(function (resolve, reject) {
    var attrs = {
      src: src
    };
    var props = {
      onload: resolve,
      onerror: reject,
      onabort: reject
    };
    createNode(IMG, attrs, props, [], currentDocument);
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is a function.
 * @param {*} value
 * @returns {boolean}
 */


var isFunction = function isFunction(value) {
  return typeof value === "function";
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is a non-empty array.
 * @param {*} value
 * @returns {boolean}
 */


var isNonEmptyArray = function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var toArray = function toArray(value) {
  if (Array.isArray(value)) {
    return value;
  }

  if (value == null) {
    return [];
  }

  return [].slice.call(value);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns an array of matched DOM nodes.
 * @param {String} selector
 * @param {Node} [context=document] defaults to document
 * @returns {Array} an array of DOM nodes
 */


var selectNodes = function selectNodes(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return toArray(context.querySelectorAll(selector));
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var MUTATION_OBSERVER = "MutationObserver";
var RAF = "requestAnimationFrame";
var MUTATION_OBSERVER_CONFIG = {
  childList: true,
  subtree: true
};
var VISIBILITY_STATE = "visibilityState";
var VISIBLE = "visible";
var DELAY = 100;
var MAX_POLLING_TIMEOUT = 5000;

var createError = function createError(selector) {
  return new Error("Could not find: ".concat(selector));
};

var createPromise = function createPromise(executor) {
  return new Promise(executor);
};

var canUseMutationObserver = function canUseMutationObserver(win) {
  return isFunction(win[MUTATION_OBSERVER]);
};

var awaitUsingMutationObserver = function awaitUsingMutationObserver(win, doc, selector, timeout, selectFunc) {
  return createPromise(function (resolve, reject) {
    var mutationObserver = new win[MUTATION_OBSERVER](function () {
      var nodes = selectFunc(selector);

      if (isNonEmptyArray(nodes)) {
        mutationObserver.disconnect();
        resolve(nodes);
      }
    });
    setTimeout(function () {
      mutationObserver.disconnect();
      reject(createError(selector));
    }, timeout);
    mutationObserver.observe(doc, MUTATION_OBSERVER_CONFIG);
  });
};

var canUseRequestAnimationFrame = function canUseRequestAnimationFrame(doc) {
  return doc[VISIBILITY_STATE] === VISIBLE;
};

var awaitUsingRequestAnimation = function awaitUsingRequestAnimation(win, selector, timeout, selectFunc) {
  return createPromise(function (resolve, reject) {
    var execute = function execute() {
      var nodes = selectFunc(selector);

      if (isNonEmptyArray(nodes)) {
        resolve(nodes);
        return;
      }

      win[RAF](execute);
    };

    execute();
    setTimeout(function () {
      reject(createError(selector));
    }, timeout);
  });
};

var awaitUsingTimer = function awaitUsingTimer(selector, timeout, selectFunc) {
  return createPromise(function (resolve, reject) {
    var execute = function execute() {
      var nodes = selectFunc(selector);

      if (isNonEmptyArray(nodes)) {
        resolve(nodes);
        return;
      }

      setTimeout(execute, DELAY);
    };

    execute();
    setTimeout(function () {
      reject(createError(selector));
    }, timeout);
  });
};

var awaitSelector = function awaitSelector(selector) {
  var selectFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : selectNodes;
  var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_POLLING_TIMEOUT;
  var win = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;
  var doc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : document;
  var nodes = selectFunc(selector);

  if (isNonEmptyArray(nodes)) {
    return Promise.resolve(nodes);
  }

  if (canUseMutationObserver(win)) {
    return awaitUsingMutationObserver(win, doc, selector, timeout, selectFunc);
  }

  if (canUseRequestAnimationFrame(doc)) {
    return awaitUsingRequestAnimation(win, selector, timeout, selectFunc);
  }

  return awaitUsingTimer(selector, timeout, selectFunc);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns true if element matches the selector.
 * @param {String} selector
 * @param {Node} [element]
 * @returns {Boolean}
 */


var matchesSelector = function matchesSelector(selector, element) {
  if (element.matches) {
    return element.matches(selector);
  } // Making IE 11 happy


  return element.msMatchesSelector(selector);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var removeNode = function removeNode(node) {
  var parent = node.parentNode;

  if (parent) {
    return parent.removeChild(node);
  }

  return null;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var fireOnPage = fireImage;
var IFRAME_ATTRS = {
  name: "Adobe Alloy"
};
var IFRAME_PROPS = {
  style: {
    display: "none",
    width: 0,
    height: 0
  }
};

var fireReferrerHideableImage = function fireReferrerHideableImage(request) {
  var createIframe = function createIframe() {
    return awaitSelector(BODY).then(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
          body = _ref3[0];

      var iframe = createNode(IFRAME, IFRAME_ATTRS, IFRAME_PROPS);
      return appendNode(body, iframe);
    });
  };

  var fireInIframe = function fireInIframe(_ref4) {
    var src = _ref4.src;
    return createIframe().then(function (iframe) {
      var currentDocument = iframe.contentWindow.document;
      return fireImage({
        src: src,
        currentDocument: currentDocument
      }).then(function () {
        removeNode(iframe);
      });
    });
  };

  var hideReferrer = request.hideReferrer,
      url = request.url;
  return hideReferrer ? fireInIframe({
    src: url
  }) : fireOnPage({
    src: url
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var flatMap = function flatMap(array, mapFunction) {
  return Array.prototype.concat.apply([], array.map(mapFunction));
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var baseNamespace = "com.adobe.alloy.";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns the last N number of items from an array.
 * @param {Array} arr
 * @param {number} itemCount
 * @returns {Array}
 */

var getLastArrayItems = function getLastArrayItems(arr, itemCount) {
  return arr.slice(-itemCount);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var cookieName = "".concat(baseNamespace, "getTld");
/**
 * Of the current web page's hostname, this is the top-most domain that is
 * not a "public suffix" as outlined in https://publicsuffix.org/. In other
 * words, this is top-most domain that is able to accept cookies.
 * @param {Object} window
 * @param {Object} cookieJar
 * @returns {string}
 */

var getApexDomain = function getApexDomain(window, cookieJar) {
  var topLevelCookieDomain = ""; // If hostParts.length === 1, we may be on localhost.

  var hostParts = window.location.hostname.toLowerCase().split(".");
  var i = 1;

  while (i < hostParts.length && !cookieJar.get(cookieName)) {
    i += 1;
    topLevelCookieDomain = getLastArrayItems(hostParts, i).join(".");
    cookieJar.set(cookieName, cookieName, {
      domain: topLevelCookieDomain
    });
  }

  cookieJar.remove(cookieName, {
    domain: topLevelCookieDomain
  });
  return topLevelCookieDomain;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// Remember to also incorporate the org ID wherever cookies are read or written.


var COOKIE_NAME_PREFIX = "kndctr";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var sanitizeOrgIdForCookieName = function sanitizeOrgIdForCookieName(orgId) {
  return orgId.replace("@", "_");
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getNamespacedCookieName = function getNamespacedCookieName(orgId, key) {
  return "".concat(COOKIE_NAME_PREFIX, "_").concat(sanitizeOrgIdForCookieName(orgId), "_").concat(key);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var IDENTITY = "identity";
var CONSENT = "consent";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var injectDoesIdentityCookieExist = function injectDoesIdentityCookieExist(_ref5) {
  var orgId = _ref5.orgId;
  var identityCookieName = getNamespacedCookieName(orgId, IDENTITY);
  /**
   * Returns whether the identity cookie exists.
   */

  return function () {
    return Boolean(_reactorCookie["default"].get(identityCookieName));
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Whether a string starts with the characters of a specified string
 * @param {String} str The string to search within.
 * @param {String} prefix The string to search for.
 * @returns {boolean}
 */


var startsWith = function startsWith(str, prefix) {
  return str.substr(0, prefix.length) === prefix;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getStorageByType = function getStorageByType(context, storageType, namespace) {
  // When storage is disabled on Safari, the mere act of referencing
  // window.localStorage or window.sessionStorage throws an error.
  // For this reason, we wrap in a try-catch.
  return {
    /**
     * Reads a value from storage.
     * @param {string} name The name of the item to be read.
     * @returns {string}
     */
    getItem: function getItem(name) {
      try {
        return context[storageType].getItem(namespace + name);
      } catch (e) {
        return null;
      }
    },

    /**
     * Saves a value to storage.
     * @param {string} name The name of the item to be saved.
     * @param {string} value The value of the item to be saved.
     * @returns {boolean} Whether the item was successfully saved to storage.
     */
    setItem: function setItem(name, value) {
      try {
        context[storageType].setItem(namespace + name, value);
        return true;
      } catch (e) {
        return false;
      }
    },

    /**
     * Clear all values in storage that match the namespace.
     */
    clear: function clear() {
      try {
        Object.keys(context[storageType]).forEach(function (key) {
          if (startsWith(key, namespace)) {
            context[storageType].removeItem(key);
          }
        });
        return true;
      } catch (e) {
        return false;
      }
    }
  };
};

var injectStorage = function injectStorage(context) {
  return function (additionalNamespace) {
    var finalNamespace = baseNamespace + additionalNamespace;
    return {
      session: getStorageByType(context, "sessionStorage", finalNamespace),
      persistent: getStorageByType(context, "localStorage", finalNamespace)
    };
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns items that are found within both arrays.
 * @param {Array} a
 * @param {Array} b
 * @returns {Array}
 */


var intersection = function intersection(a, b) {
  return a.filter(function (x) {
    return includes(b, x);
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is a boolean.
 * @param {*} value
 * @returns {boolean}
 */


var isBoolean = function isBoolean(value) {
  return typeof value === "boolean";
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is an empty object.
 * @param {*} value
 * @returns {boolean}
 */


var isEmptyObject = function isEmptyObject(value) {
  return isObject(value) && Object.keys(value).length === 0;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is a number.
 * @param {*} value
 * @returns {boolean}
 */
// eslint-disable-next-line no-restricted-globals


var isNumber = function isNumber(value) {
  return typeof value === "number" && !isNaN(value);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is an integer.
 * @param {*} value
 * @returns {boolean}
 */


var isInteger = function isInteger(value) {
  var parsed = parseInt(value, 10);
  return isNumber(parsed) && value === parsed;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Determines whether a cookie name is namespaced according to the contract
 * defined by the server.
 * @param {String} orgId The org ID configured for the Alloy instance.
 * @param {String} name The cookie name.
 * @returns {boolean}
 */


var isNamespacedCookieName = function isNamespacedCookieName(orgId, name) {
  return name.indexOf("".concat(COOKIE_NAME_PREFIX, "_").concat(sanitizeOrgIdForCookieName(orgId), "_")) === 0;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is a string.
 * @param {*} value
 * @returns {boolean}
 */


var isString = function isString(value) {
  return typeof value === "string";
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether the value is a populated string.
 * @param {*} value
 * @returns {boolean}
 */


var isNonEmptyString = function isNonEmptyString(value) {
  return isString(value) && value.length > 0;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Creates a function that memoizes the result of `fn`. If `keyResolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key.
 *
 * @param {Function} fn The function to have its output memoized.
 * @param {Function} [keyResolver] The function to resolve the cache key.
 * @returns {Function} The new memoized function.
 */


var memoize = function memoize(fn, keyResolver) {
  var map = new Map();
  return function () {
    var key = keyResolver ? keyResolver.apply(void 0, arguments) : arguments.length <= 0 ? undefined : arguments[0];

    if (map.has(key)) {
      return map.get(key);
    }

    var result = fn.apply(void 0, arguments);
    map.set(key, result);
    return result;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * A function that performs no operations.
 */


var noop = function noop() {};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart


var padStart = function padStart(string, targetLength, padString) {
  var originalString = String(string);
  var repeatedPadString = String(padString);

  if (originalString.length >= targetLength || repeatedPadString.length === 0) {
    return originalString;
  }

  var lengthToAdd = targetLength - originalString.length;

  while (lengthToAdd > repeatedPadString.length) {
    repeatedPadString += repeatedPadString;
  }

  return repeatedPadString.slice(0, lengthToAdd) + originalString;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Creates and returns a new error using the provided value as a message.
 * If the provided value is already an Error, it will be returned unmodified.
 * @param {*} value
 * @returns {Error}
 */


var toError = function toError(value) {
  return value instanceof Error ? value : new Error(value);
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var updateErrorMessage = function updateErrorMessage(_ref6) {
  var error = _ref6.error,
      message = _ref6.message;

  try {
    error.message = message;
  } catch (e) {// We'll set a new message when we can, but some errors, like DOMException,
    // have a read-only message property, which limits our options.
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Augments an error's message with additional context as it bubbles up the call stack.
 * @param {String} message The message to be added to the error.
 * @param {*} error Optimally, this is an instance of Error. If it is not,
 * this is used as the basis for the message of a newly created Error instance.
 * @returns {*}
 */


var stackError = function stackError(_ref7) {
  var error = _ref7.error,
      message = _ref7.message;
  var errorToStack = toError(error);
  var newMessage = "".concat(message, "\nCaused by: ").concat(errorToStack.message);
  updateErrorMessage({
    error: errorToStack,
    message: newMessage
  });
  return errorToStack;
};

var stringToBoolean = function stringToBoolean(str) {
  return isString(str) && str.toLowerCase() === "true";
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Formats the date into an ISO date-time string in the local timezone
 * @param {Date} date
 * @returns {string}
 */


var toISOStringLocal = function toISOStringLocal(date) {
  var YYYY = date.getFullYear();
  var MM = padStart(date.getMonth() + 1, 2, "0");
  var DD = padStart(date.getDate(), 2, "0");
  var hh = padStart(date.getHours(), 2, "0");
  var mm = padStart(date.getMinutes(), 2, "0");
  var ss = padStart(date.getSeconds(), 2, "0");
  var mmm = padStart(date.getMilliseconds(), 3, "0"); // The time-zone offset is the difference, in minutes, from local time to UTC. Note that this
  // means that the offset is positive if the local timezone is behind UTC and negative if it is
  // ahead. For example, for time zone UTC+10:00, -600 will be returned.

  var timezoneOffset = date.getTimezoneOffset();
  var ts = timezoneOffset > 0 ? "-" : "+";
  var th = padStart(Math.floor(Math.abs(timezoneOffset) / 60), 2, "0");
  var tm = padStart(Math.abs(timezoneOffset) % 60, 2, "0");
  return "".concat(YYYY, "-").concat(MM, "-").concat(DD, "T").concat(hh, ":").concat(mm, ":").concat(ss, ".").concat(mmm).concat(ts).concat(th, ":").concat(tm);
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var rngBrowser = createCommonjsModule(function (module) {
  // Unique ID creation requires a high quality random # generator.  In the
  // browser this is a little complicated due to unknown quality of Math.random()
  // and inconsistent support for the `crypto` API.  We do the best we can via
  // feature-detection
  // getRandomValues needs to be invoked in a context where "this" is a Crypto
  // implementation. Also, find the complete implementation of crypto on IE11.
  var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);

  if (getRandomValues) {
    // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
    var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

    module.exports = function whatwgRNG() {
      getRandomValues(rnds8);
      return rnds8;
    };
  } else {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var rnds = new Array(16);

    module.exports = function mathRNG() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return rnds;
    };
  }
});
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || rngBrowser)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Chains two validators together.
 *
 * Validators are functions of two parameters (value and path) that return the computed value if
 * the input is valid, or throw an exception if the input is invalid. In most cases the returned
 * value is the same as the input value; however, reference createDefaultValidator.js
 * to see an example where the computed value is different from the input. Additionally, if we ever
 * wanted to coerce types (i.e. parse string values into integers) as part of the validation process
 * we could use the computed value to accomplish that.
 *
 * The path parameter is used to generate informative error messages. It is created by the objectOf, and
 * arrayOf validators so that any error message can describe which key within the object or array is
 * invalid.
 *
 * The validators also have methods to chain additional validation logic. For example, when you call
 * `string()` to start a validator chain, it returns a validator function but it also has methods
 * like `required` and `nonEmpty`. In index.js you can see that these methods are actually calling `chain`.
 * Specifically in this function, the leftValidator is called first and then the return value of that is
 * sent to the rightValidator. For example, when calling `string().nonEmpty().required()` the following
 * chain is built up:
 * ```
 *              *
 *            /   \
 *          *     required
 *        /   \
 *      *     nonEmpty
 *    /   \
 * base   string
 * ```
 * Where every * is a call to chain where the two are combined. The individual validators are called from
 * left to right in the above tree. The base validator is simply the identity function `value => value`,
 * representing an optional value.
 *
 * After combining the validators, the new validator function is then augmented with the methods from the
 * leftValidator and from the additionalMethods parameter. For example, when the string() function is called
 * it chains to the base validator, but also adds additional methods like (`regexp`, `domain`, `nonEmpty`,
 * and `unique`). When `nonEmpty` is called, which calls chain again, the additional methods are carried
 * forward because they are already defined on the leftValidator.
 *
 * The base validator also contains the two methods `required` and `default`, so these can be used anywhere
 * after any of the exposed validator functions are called.
 */

var chain = function chain(leftValidator, rightValidator) {
  var additionalMethods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // combine the two validators, calling left first and then right.
  // pass the return value from left into right.
  var combinedValidator = function combinedValidator(value, path) {
    return rightValidator(leftValidator(value, path), path);
  }; // add the methods already defined on the left validator, and the additionalMethods
  // to the new combined validator function.


  (0, _reactorObjectAssign["default"])(combinedValidator, leftValidator, additionalMethods);
  return combinedValidator;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * This augments `chain` with a null check done before running the rightValidator.
 * See chain for more info.
 *
 * For most validators, we want the validation to be optional (i.e. allow null or
 * undefined values). To accomplish this, the validator needs to have a check
 * at the begining of the function, short circuiting the validation logic and
 * returning value if value is null or undefined. `default` and `required` do not
 * want this null check though. Indeed, `default` should return the default value
 * if value is null, and `required` should throw an error if value is null.
 *
 * So to keep from having to have a null check in front of most validators, this
 * function allows you to chain a rightValidator that needs to have a null check.
 */


var nullSafeChain = function nullSafeChain(leftValidator, rightValidator, additionalMethods) {
  var rightValidatorWithNullCheck = function rightValidatorWithNullCheck(value, path) {
    return value == null ? value : rightValidator(value, path);
  };

  return chain(leftValidator, rightValidatorWithNullCheck, additionalMethods);
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var assertValid = function assertValid(isValid, value, path, message) {
  if (!isValid) {
    throw new Error("'".concat(path, "': Expected ").concat(message, ", but got ").concat(JSON.stringify(value), "."));
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var booleanValidator = function booleanValidator(value, path) {
  assertValid(isBoolean(value), value, path, "true or false");
  return value;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var callbackValidator = function callbackValidator(value, path) {
  assertValid(isFunction(value), value, path, "a function");
  return value;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createArrayOfValidator = function createArrayOfValidator(elementValidator) {
  return function (value, path) {
    assertValid(Array.isArray(value), value, path, "an array");
    var errors = [];
    var validatedArray = value.map(function (subValue, i) {
      try {
        return elementValidator(subValue, "".concat(path, "[").concat(i, "]"));
      } catch (e) {
        errors.push(e.message);
        return undefined;
      }
    });

    if (errors.length) {
      throw new Error(errors.join("\n"));
    }

    return validatedArray;
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createDefaultValidator = function createDefaultValidator(defaultValue) {
  return function (value) {
    if (value == null) {
      return defaultValue;
    }

    return value;
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createLiteralValidator = function createLiteralValidator(literalValue) {
  return function (value, path) {
    assertValid(value === literalValue, value, path, "".concat(literalValue));
    return value;
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createMapOfValuesValidator = function createMapOfValuesValidator(valueValidator) {
  return function (value, path) {
    assertValid(isObject(value), value, path, "an object");
    var errors = [];
    var validatedObject = {};
    Object.keys(value).forEach(function (subKey) {
      var subValue = value[subKey];
      var subPath = path ? "".concat(path, ".").concat(subKey) : subKey;

      try {
        var validatedValue = valueValidator(subValue, subPath);

        if (validatedValue !== undefined) {
          validatedObject[subKey] = validatedValue;
        }
      } catch (e) {
        errors.push(e.message);
      }
    });

    if (errors.length) {
      throw new Error(errors.join("\n"));
    }

    return validatedObject;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createMinimumValidator = function createMinimumValidator(typeName, minimum) {
  return function (value, path) {
    assertValid(value >= minimum, value, path, "".concat(typeName, " greater than or equal to ").concat(minimum));
    return value;
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createNoUnknownFieldsValidator = function createNoUnknownFieldsValidator(schema) {
  return function (value, path) {
    var errors = [];
    Object.keys(value).forEach(function (subKey) {
      if (!schema[subKey]) {
        var subPath = path ? "".concat(path, ".").concat(subKey) : subKey;
        errors.push("'".concat(subPath, "': Unknown field."));
      }
    });

    if (errors.length) {
      throw new Error(errors.join("\n"));
    }

    return value;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createNonEmptyValidator = function createNonEmptyValidator(message) {
  return function (value, path) {
    if (isObject(value)) {
      assertValid(!isEmptyObject(value), value, path, message);
    } else {
      assertValid(value.length > 0, value, path, message);
    }

    return value;
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createObjectOfValidator = function createObjectOfValidator(schema) {
  return function (value, path) {
    assertValid(isObject(value), value, path, "an object");
    var errors = [];
    var validatedObject = {};
    Object.keys(schema).forEach(function (subKey) {
      var subValue = value[subKey];
      var subSchema = schema[subKey];
      var subPath = path ? "".concat(path, ".").concat(subKey) : subKey;

      try {
        var validatedValue = subSchema(subValue, subPath);

        if (validatedValue !== undefined) {
          validatedObject[subKey] = validatedValue;
        }
      } catch (e) {
        errors.push(e.message);
      }
    }); // copy over unknown properties

    Object.keys(value).forEach(function (subKey) {
      if (!Object.prototype.hasOwnProperty.call(validatedObject, subKey)) {
        validatedObject[subKey] = value[subKey];
      }
    });

    if (errors.length) {
      throw new Error(errors.join("\n"));
    }

    return validatedObject;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createAnyOfValidator = function createAnyOfValidator(validators, message) {
  return function (value, path) {
    var valid = find(validators, function (validator) {
      try {
        validator(value, path);
        return true;
      } catch (e) {
        return false;
      }
    });
    assertValid(valid, value, path, message);
    return value;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createUniqueValidator = function createUniqueValidator() {
  var values = [];
  return function (value, path) {
    assertValid(values.indexOf(value) === -1, value, path, "a unique value across instances");
    values.push(value);
    return value;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var DOMAIN_REGEX = /^[a-z0-9.-]{1,}$/i;

var domainValidator = function domainValidator(value, path) {
  assertValid(DOMAIN_REGEX.test(value), value, path, "a valid domain");
  return value;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var integerValidator = function integerValidator(value, path) {
  assertValid(isInteger(value), value, path, "an integer");
  return value;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var numberValidator = function numberValidator(value, path) {
  assertValid(isNumber(value), value, path, "a number");
  return value;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Determines whether the value is a valid regular expression.
 * @param {*} value
 * @returns {boolean}
 */


var isValidRegExp = function isValidRegExp(value) {
  try {
    return new RegExp(value) !== null;
  } catch (e) {
    return false;
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var regexpValidator = function regexpValidator(value, path) {
  assertValid(isValidRegExp(value), value, path, "a regular expression");
  return value;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var requiredValidator = function requiredValidator(value, path) {
  if (value == null) {
    throw new Error("'".concat(path, "' is a required option"));
  }

  return value;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var stringValidator = function stringValidator(value, path) {
  assertValid(isString(value), value, path, "a string");
  return value;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var base = function base(value) {
  return value;
}; // The 'default' and 'required' methods are available after any data-type method
// Don't use the nullSafeChain because they need to handle the null or undefined case


base["default"] = function _default(defaultValue) {
  return chain(this, createDefaultValidator(defaultValue));
};

base.required = function required() {
  return chain(this, requiredValidator);
}; // helper validators


var domain = function domain() {
  return nullSafeChain(this, domainValidator);
};

var minimumInteger = function minimumInteger(minValue) {
  return nullSafeChain(this, createMinimumValidator("an integer", minValue));
};

var minimumNumber = function minimumNumber(minValue) {
  return nullSafeChain(this, createMinimumValidator("a number", minValue));
};

var integer = function integer() {
  return nullSafeChain(this, integerValidator, {
    minimum: minimumInteger
  });
};

var nonEmptyString = function nonEmptyString() {
  return nullSafeChain(this, createNonEmptyValidator("a non-empty string"));
};

var nonEmptyArray = function nonEmptyArray() {
  return nullSafeChain(this, createNonEmptyValidator("a non-empty array"));
};

var nonEmptyObject = function nonEmptyObject() {
  return nullSafeChain(this, createNonEmptyValidator("a non-empty object"));
};

var regexp = function regexp() {
  return nullSafeChain(this, regexpValidator);
};

var unique = function createUnique() {
  return nullSafeChain(this, createUniqueValidator());
}; // top-level validators.  These are the first functions that are called to create a validator.


var anyOf = function anyOf(validators, message) {
  // use chain here because we don't want to accept null or undefined unless at least
  // one of the validators accept null or undefined.
  return chain(this, createAnyOfValidator(validators, message));
};

var anything = function anything() {
  return nullSafeChain(this, base);
};

var arrayOf = function arrayOf(elementValidator) {
  return nullSafeChain(this, createArrayOfValidator(elementValidator), {
    nonEmpty: nonEmptyArray
  });
};

var _boolean = function _boolean2() {
  return nullSafeChain(this, booleanValidator);
};

var callback = function callback() {
  return nullSafeChain(this, callbackValidator);
};

var literal = function literal(literalValue) {
  return nullSafeChain(this, createLiteralValidator(literalValue));
};

var number = function number() {
  return nullSafeChain(this, numberValidator, {
    minimum: minimumNumber,
    integer: integer,
    unique: unique
  });
};

var mapOfValues = function mapOfValues(valuesValidator) {
  return nullSafeChain(this, createMapOfValuesValidator(valuesValidator), {
    nonEmpty: nonEmptyObject
  });
};

var objectOf = function objectOf(schema) {
  var noUnknownFields = function noUnknownFields() {
    return nullSafeChain(this, createNoUnknownFieldsValidator(schema));
  };

  return nullSafeChain(this, createObjectOfValidator(schema), {
    noUnknownFields: noUnknownFields,
    nonEmpty: nonEmptyObject
  });
};

var string = function string() {
  return nullSafeChain(this, stringValidator, {
    regexp: regexp,
    domain: domain,
    nonEmpty: nonEmptyString,
    unique: unique
  });
};

var boundAnyOf = anyOf.bind(base);
var boundAnything = anything.bind(base);
var boundArrayOf = arrayOf.bind(base);

var boundBoolean = _boolean.bind(base);

var boundCallback = callback.bind(base);
var boundLiteral = literal.bind(base);
number.bind(base);
var boundMapOfValues = mapOfValues.bind(base);
var boundObjectOf = objectOf.bind(base);
var boundString = string.bind(base); // compound validators

var boundEnumOf = function boundEnumOf() {
  for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    values[_key3] = arguments[_key3];
  }

  return boundAnyOf(values.map(boundLiteral), "one of these values: [".concat(JSON.stringify(values), "]"));
};

var AMBIGUOUS = "ambiguous";
var AUTHENTICATED = "authenticated";
var LOGGED_OUT = "loggedOut";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var validateIdentityMap = boundMapOfValues(boundArrayOf(boundObjectOf({
  authenticatedState: boundEnumOf(AMBIGUOUS, AUTHENTICATED, LOGGED_OUT),
  id: boundString(),
  namespace: boundObjectOf({
    code: boundString()
  }).noUnknownFields(),
  primary: boundBoolean(),
  xid: boundString()
})).required());
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns an array whose items are the provided object's own enumerable
 * property values.
 * @param {Object} obj
 * @returns {Array}
 */

var values = function values(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var debugQueryParam = "alloy_debug";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createLogController = function createLogController(_ref8) {
  var console = _ref8.console,
      locationSearch = _ref8.locationSearch,
      createLogger = _ref8.createLogger,
      instanceName = _ref8.instanceName,
      createNamespacedStorage = _ref8.createNamespacedStorage,
      getMonitors = _ref8.getMonitors;

  var parsedQueryString = _reactorQueryString["default"].parse(locationSearch);

  var storage = createNamespacedStorage("instance.".concat(instanceName, "."));
  var debugSessionValue = storage.session.getItem("debug");
  var debugEnabled = debugSessionValue === "true";
  var debugEnabledWritableFromConfig = debugSessionValue === null;

  var getDebugEnabled = function getDebugEnabled() {
    return debugEnabled;
  };

  var setDebugEnabled = function setDebugEnabled(value, _ref9) {
    var fromConfig = _ref9.fromConfig;

    if (!fromConfig || debugEnabledWritableFromConfig) {
      debugEnabled = value;
    }

    if (!fromConfig) {
      // Web storage only allows strings, so we explicitly convert to string.
      storage.session.setItem("debug", value.toString());
      debugEnabledWritableFromConfig = false;
    }
  };

  if (parsedQueryString[debugQueryParam] !== undefined) {
    setDebugEnabled(stringToBoolean(parsedQueryString[debugQueryParam]), {
      fromConfig: false
    });
  }

  return {
    setDebugEnabled: setDebugEnabled,
    logger: createLogger({
      getDebugEnabled: getDebugEnabled,
      context: {
        instanceName: instanceName
      },
      getMonitors: getMonitors,
      console: console
    }),
    createComponentLogger: function createComponentLogger(componentName) {
      return createLogger({
        getDebugEnabled: getDebugEnabled,
        context: {
          instanceName: instanceName,
          componentName: componentName
        },
        getMonitors: getMonitors,
        console: console
      });
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// TO-DOCUMENT: Lifecycle hooks and their params.


var hookNames = [// Called after all components have been registered.
"onComponentsRegistered", // Called before an event is sent on a data collection request
"onBeforeEvent", // Called before each request is made to the edge.
"onBeforeRequest", // Called after each response is returned from the edge with a successful
// status code
"onResponse", // Called after a network request to the edge fails. Either the request
// didn't make it to the edge, didn't make it to Konductor, or Konductor
// failed to return a regularly-structured response. (In this case { error }
// is passed as the parameter)
// Also called when the respone returns a 400 or 500 error. (In this case
// { response } is passed as the parameter)
"onRequestFailure", // A user clicked on an element.
"onClick"];

var createHook = function createHook(componentRegistry, hookName) {
  return function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return Promise.all(componentRegistry.getLifecycleCallbacks(hookName).map(function (callback) {
      return new Promise(function (resolve) {
        resolve(callback.apply(void 0, args));
      });
    }));
  };
};
/**
 * This ensures that if a component's lifecycle method X
 * attempts to execute lifecycle method Y, that all X methods on all components
 * will have been called before any of their Y methods are called. It does
 * this by kicking the call to the Y method to the next JavaScript tick.
 * @returns {function}
 */


var guardHook = function guardHook(fn) {
  return function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return Promise.resolve().then(function () {
      return fn.apply(void 0, args);
    });
  };
};

var createLifecycle = function createLifecycle(componentRegistry) {
  return hookNames.reduce(function (memo, hookName) {
    memo[hookName] = guardHook(createHook(componentRegistry, hookName));
    return memo;
  }, {});
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var wrapForErrorHandling = function wrapForErrorHandling(fn, stackMessage) {
  return function () {
    var result;

    try {
      result = fn.apply(void 0, arguments);
    } catch (error) {
      throw stackError({
        error: error,
        message: stackMessage
      });
    }

    if (result instanceof Promise) {
      result = result["catch"](function (error) {
        throw stackError({
          error: error,
          message: stackMessage
        });
      });
    }

    return result;
  };
}; // TO-DOCUMENT: All public commands and their signatures.


var createComponentRegistry = function createComponentRegistry() {
  var commandsByName = {};
  var lifecycleCallbacksByName = {};

  var registerComponentCommands = function registerComponentCommands(namespace) {
    var componentCommandsByName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var conflictingCommandNames = intersection(Object.keys(commandsByName), Object.keys(componentCommandsByName));

    if (conflictingCommandNames.length) {
      throw new Error("[ComponentRegistry] Could not register ".concat(namespace, " ") + "because it has existing command(s): ".concat(conflictingCommandNames.join(",")));
    }

    Object.keys(componentCommandsByName).forEach(function (commandName) {
      var command = componentCommandsByName[commandName];
      command.commandName = commandName;
      command.run = wrapForErrorHandling(command.run, "[".concat(namespace, "] An error occurred while executing the ").concat(commandName, " command."));
      commandsByName[commandName] = command;
    });
  };

  var registerLifecycleCallbacks = function registerLifecycleCallbacks(namespace) {
    var componentLifecycleCallbacksByName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Object.keys(componentLifecycleCallbacksByName).forEach(function (hookName) {
      lifecycleCallbacksByName[hookName] = lifecycleCallbacksByName[hookName] || [];
      lifecycleCallbacksByName[hookName].push(wrapForErrorHandling(componentLifecycleCallbacksByName[hookName], "[".concat(namespace, "] An error occurred while executing the ").concat(hookName, " lifecycle hook.")));
    });
  };

  return {
    register: function register(namespace, component) {
      var commands = component.commands,
          lifecycle = component.lifecycle;
      registerComponentCommands(namespace, commands);
      registerLifecycleCallbacks(namespace, lifecycle);
    },
    getCommand: function getCommand(commandName) {
      return commandsByName[commandName];
    },
    getCommandNames: function getCommandNames() {
      return Object.keys(commandsByName);
    },
    getLifecycleCallbacks: function getLifecycleCallbacks(hookName) {
      return lifecycleCallbacksByName[hookName] || [];
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectSendNetworkRequest = function injectSendNetworkRequest(_ref10) {
  var logger = _ref10.logger,
      sendFetchRequest = _ref10.sendFetchRequest,
      sendBeaconRequest = _ref10.sendBeaconRequest,
      isRequestRetryable = _ref10.isRequestRetryable,
      getRequestRetryDelay = _ref10.getRequestRetryDelay;

  /**
   * Send a network request and returns details about the response.
   */
  return function (_ref11) {
    var requestId = _ref11.requestId,
        url = _ref11.url,
        payload = _ref11.payload,
        useSendBeacon = _ref11.useSendBeacon;
    // We want to log raw payload and event data rather than
    // our fancy wrapper objects. Calling payload.toJSON() is
    // insufficient to get all the nested raw data, because it's
    // not recursive (it doesn't call toJSON() on the event objects).
    // Parsing the result of JSON.stringify(), however, gives the
    // fully recursive raw data.
    var stringifiedPayload = JSON.stringify(payload);
    var parsedPayload = JSON.parse(stringifiedPayload);
    logger.logOnBeforeNetworkRequest({
      url: url,
      requestId: requestId,
      payload: parsedPayload
    });

    var executeRequest = function executeRequest() {
      var retriesAttempted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var requestMethod = useSendBeacon ? sendBeaconRequest : sendFetchRequest;
      return requestMethod(url, stringifiedPayload).then(function (response) {
        var requestIsRetryable = isRequestRetryable({
          response: response,
          retriesAttempted: retriesAttempted
        });

        if (requestIsRetryable) {
          var requestRetryDelay = getRequestRetryDelay({
            response: response,
            retriesAttempted: retriesAttempted
          });
          return new Promise(function (resolve) {
            setTimeout(function () {
              resolve(executeRequest(retriesAttempted + 1));
            }, requestRetryDelay);
          });
        }

        var parsedBody;

        try {
          parsedBody = JSON.parse(response.body);
        } catch (e) {// Non-JSON. Something went wrong.
        }

        logger.logOnNetworkResponse(_objectSpread(_objectSpread({
          requestId: requestId,
          url: url,
          payload: parsedPayload
        }, response), {}, {
          parsedBody: parsedBody,
          retriesAttempted: retriesAttempted
        }));
        return {
          statusCode: response.statusCode,
          body: response.body,
          parsedBody: parsedBody,
          getHeader: response.getHeader
        };
      });
    };

    return executeRequest()["catch"](function (error) {
      logger.logOnNetworkError({
        requestId: requestId,
        url: url,
        payload: parsedPayload,
        error: error
      });
      throw stackError({
        error: error,
        message: "Network request failed."
      });
    });
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectExtractEdgeInfo = function injectExtractEdgeInfo(_ref12) {
  var logger = _ref12.logger;
  return function (adobeEdgeHeader) {
    if (adobeEdgeHeader) {
      var headerParts = adobeEdgeHeader.split(";");

      if (headerParts.length >= 2 && headerParts[1].length > 0) {
        try {
          var regionId = parseInt(headerParts[1], 10); // eslint recommends using Number.isNaN instead, but this function is
          // not available in Internet Explorer. Number.isNaN is more robust to
          // non-numeric parameters. Since we already know regionId will be an
          // integer, using isNaN is okay.
          // https://github.com/airbnb/javascript#standard-library--isnan
          // eslint-disable-next-line no-restricted-globals

          if (!isNaN(regionId)) {
            return {
              regionId: regionId
            };
          }
        } catch (e) {// No need to do anything. The log statement below will log an error
        }
      }

      logger.warn("Invalid adobe edge: \"".concat(adobeEdgeHeader, "\""));
    }

    return {};
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var IN = "in";
var OUT = "out";
var PENDING = "pending";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var GENERAL = "general";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var DECLINED_CONSENT_ERROR_CODE = "declinedConsent";
var CONSENT_SOURCE_DEFAULT = "default";
var CONSENT_SOURCE_INITIAL = "initial";
var CONSENT_SOURCE_NEW = "new";

var createDeclinedConsentError = function createDeclinedConsentError(errorMessage) {
  var error = new Error(errorMessage);
  error.code = DECLINED_CONSENT_ERROR_CODE;
  error.message = errorMessage;
  return error;
};

var createConsentStateMachine = function createConsentStateMachine(_ref13) {
  var logger = _ref13.logger;
  var deferreds = [];

  var runAll = function runAll() {
    while (deferreds.length) {
      deferreds.shift().resolve();
    }
  };

  var discardAll = function discardAll() {
    while (deferreds.length) {
      deferreds.shift().reject(createDeclinedConsentError("The user declined consent."));
    }
  };

  var awaitInitial = function awaitInitial() {
    return Promise.reject(new Error("Consent has not been initialized."));
  };

  var awaitInDefault = function awaitInDefault() {
    return Promise.resolve();
  };

  var awaitIn = function awaitIn() {
    return Promise.resolve();
  };

  var awaitOutDefault = function awaitOutDefault() {
    return Promise.reject(createDeclinedConsentError("No consent preferences have been set."));
  };

  var awaitOut = function awaitOut() {
    return Promise.reject(createDeclinedConsentError("The user declined consent."));
  };

  var awaitPending = function awaitPending() {
    var deferred = defer();
    deferreds.push(deferred);
    return deferred.promise;
  };

  return {
    "in": function _in(source) {
      if (source === CONSENT_SOURCE_DEFAULT) {
        this.awaitConsent = awaitInDefault;
      } else {
        if (source === CONSENT_SOURCE_INITIAL) {
          logger.info("Loaded user consent preferences. The user previously consented.");
        } else if (source === CONSENT_SOURCE_NEW && this.awaitConsent !== awaitIn) {
          logger.info("User consented.");
        }

        runAll();
        this.awaitConsent = awaitIn;
      }
    },
    out: function out(source) {
      if (source === CONSENT_SOURCE_DEFAULT) {
        logger.warn("User consent preferences not found. Default consent of out will be used.");
        this.awaitConsent = awaitOutDefault;
      } else {
        if (source === CONSENT_SOURCE_INITIAL) {
          logger.warn("Loaded user consent preferences. The user previously declined consent.");
        } else if (source === CONSENT_SOURCE_NEW && this.awaitConsent !== awaitOut) {
          logger.warn("User declined consent.");
        }

        discardAll();
        this.awaitConsent = awaitOut;
      }
    },
    pending: function pending(source) {
      if (source === CONSENT_SOURCE_DEFAULT) {
        logger.info("User consent preferences not found. Default consent of pending will be used. Some commands may be delayed.");
      }

      this.awaitConsent = awaitPending;
    },
    awaitConsent: awaitInitial
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createConsent = function createConsent(_ref14) {
  var generalConsentState = _ref14.generalConsentState,
      logger = _ref14.logger;

  var _setConsent = function setConsent(consentByPurpose, source) {
    switch (consentByPurpose[GENERAL]) {
      case IN:
        generalConsentState["in"](source);
        break;

      case OUT:
        generalConsentState.out(source);
        break;

      case PENDING:
        generalConsentState.pending(source);
        break;

      default:
        logger.warn("Unknown consent value: ".concat(consentByPurpose[GENERAL]));
        break;
    }
  };

  return {
    initializeConsent: function initializeConsent(defaultConsentByPurpose, storedConsentByPurpose) {
      if (storedConsentByPurpose[GENERAL]) {
        _setConsent(storedConsentByPurpose, CONSENT_SOURCE_INITIAL);
      } else {
        _setConsent(defaultConsentByPurpose, CONSENT_SOURCE_DEFAULT);
      }
    },
    setConsent: function setConsent(consentByPurpose) {
      _setConsent(consentByPurpose, CONSENT_SOURCE_NEW);
    },
    suspend: function suspend() {
      generalConsentState.pending();
    },
    awaitConsent: function awaitConsent() {
      return generalConsentState.awaitConsent();
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createEvent = function createEvent() {
  var content = {};
  var userXdm;
  var userData;
  var _documentMayUnload = false;
  var isFinalized = false;
  var shouldSendEvent = true;

  var throwIfEventFinalized = function throwIfEventFinalized(methodName) {
    if (isFinalized) {
      throw new Error("".concat(methodName, " cannot be called after event is finalized."));
    }
  };

  var event = {
    setUserXdm: function setUserXdm(value) {
      throwIfEventFinalized("setUserXdm");
      userXdm = value;
    },
    setUserData: function setUserData(value) {
      throwIfEventFinalized("setUserData");
      userData = value;
    },
    mergeXdm: function mergeXdm(xdm) {
      throwIfEventFinalized("mergeXdm");

      if (xdm) {
        deepAssign(content, {
          xdm: xdm
        });
      }
    },
    mergeMeta: function mergeMeta(meta) {
      throwIfEventFinalized("mergeMeta");

      if (meta) {
        deepAssign(content, {
          meta: meta
        });
      }
    },
    mergeQuery: function mergeQuery(query) {
      throwIfEventFinalized("mergeQuery");

      if (query) {
        deepAssign(content, {
          query: query
        });
      }
    },
    documentMayUnload: function documentMayUnload() {
      _documentMayUnload = true;
    },
    finalize: function finalize(onBeforeEventSend) {
      if (isFinalized) {
        return;
      }

      if (userXdm) {
        event.mergeXdm(userXdm);
      }

      if (userData) {
        content.data = userData;
      } // the event should already be considered finalized in case onBeforeEventSend throws an error


      isFinalized = true;

      if (onBeforeEventSend) {
        // assume that the onBeforeEventSend callback will fail (in-case of an error)
        shouldSendEvent = false; // this allows the user to replace the xdm and data properties
        // on the object passed to the callback

        var tempContent = {
          xdm: content.xdm || {},
          data: content.data || {}
        };
        var result = onBeforeEventSend(tempContent);
        shouldSendEvent = result !== false;
        content.xdm = tempContent.xdm || {};
        content.data = tempContent.data || {};

        if (isEmptyObject(content.xdm)) {
          delete content.xdm;
        }

        if (isEmptyObject(content.data)) {
          delete content.data;
        }
      }
    },
    getDocumentMayUnload: function getDocumentMayUnload() {
      return _documentMayUnload;
    },
    isEmpty: function isEmpty() {
      return isEmptyObject(content) && (!userXdm || isEmptyObject(userXdm)) && (!userData || isEmptyObject(userData));
    },
    shouldSend: function shouldSend() {
      return shouldSendEvent;
    },
    getViewName: function getViewName() {
      if (!userXdm || !userXdm.web || !userXdm.web.webPageDetails) {
        return undefined;
      }

      return userXdm.web.webPageDetails.viewName;
    },
    toJSON: function toJSON() {
      if (!isFinalized) {
        throw new Error("toJSON called before finalize");
      }

      return content;
    }
  };
  return event;
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var RETRY_AFTER = "Retry-After";
var ADOBE_EDGE = "x-adobe-edge";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Creates a representation of a gateway response with the addition of
 * helper methods.
 * @returns Response
 */

var injectCreateResponse = function injectCreateResponse(_ref15) {
  var extractEdgeInfo = _ref15.extractEdgeInfo;
  return function (_ref16) {
    var _ref16$content = _ref16.content,
        content = _ref16$content === void 0 ? {} : _ref16$content,
        getHeader = _ref16.getHeader;
    var _content$handle = content.handle,
        handle = _content$handle === void 0 ? [] : _content$handle,
        _content$errors = content.errors,
        errors = _content$errors === void 0 ? [] : _content$errors,
        _content$warnings = content.warnings,
        warnings = _content$warnings === void 0 ? [] : _content$warnings;
    /**
     * Response object.
     * @typedef {Object} Response
     */

    return {
      /**
       * Returns matching fragments of the response by type.
       * @param {String} type A string with the current format: <namespace:action>
       *
       * @example
       * getPayloadsByType("identity:persist")
       */
      getPayloadsByType: function getPayloadsByType(type) {
        return flatMap(handle.filter(function (fragment) {
          return fragment.type === type;
        }), function (fragment) {
          return fragment.payload;
        });
      },

      /**
       * Returns all errors.
       */
      getErrors: function getErrors() {
        return errors;
      },

      /**
       * Returns all warnings.
       */
      getWarnings: function getWarnings() {
        return warnings;
      },

      /**
       * Returns an object containing the regionId from the x-adobe-edge header
       */
      getEdge: function getEdge() {
        return extractEdgeInfo(getHeader(ADOBE_EDGE));
      },
      toJSON: function toJSON() {
        return content;
      }
    };
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var coreCommands = {
  CONFIGURE: "configure",
  SET_DEBUG: "setDebug"
};

var injectExecuteCommand = function injectExecuteCommand(_ref17) {
  var logger = _ref17.logger,
      configureCommand = _ref17.configureCommand,
      setDebugCommand = _ref17.setDebugCommand,
      handleError = _ref17.handleError,
      validateCommandOptions = _ref17.validateCommandOptions;
  var configurePromise;

  var getExecutor = function getExecutor(commandName, options) {
    var executor;

    if (commandName === coreCommands.CONFIGURE) {
      if (configurePromise) {
        throw new Error("The library has already been configured and may only be configured once.");
      }

      executor = function executor() {
        configurePromise = configureCommand(options);
        return configurePromise.then(function () {// Don't expose internals to the user.
        });
      };
    } else {
      if (!configurePromise) {
        throw new Error("The library must be configured first. Please do so by executing the configure command.");
      }

      if (commandName === coreCommands.SET_DEBUG) {
        executor = function executor() {
          return setDebugCommand(options);
        };
      } else {
        executor = function executor() {
          return configurePromise.then(function (componentRegistry) {
            var command = componentRegistry.getCommand(commandName);

            if (!command || !isFunction(command.run)) {
              var commandNames = values(coreCommands).concat(componentRegistry.getCommandNames()).join(", ");
              throw new Error("The ".concat(commandName, " command does not exist. List of available commands: ").concat(commandNames, "."));
            }

            var validatedOptions = validateCommandOptions({
              command: command,
              options: options
            });
            return command.run(validatedOptions);
          }, function () {
            logger.warn("An error during configuration is preventing the ".concat(commandName, " command from executing.")); // If configuration failed, we prevent the configuration
            // error from bubbling here because we don't want the
            // configuration error to be reported in the console every
            // time any command is executed. Only having it bubble
            // once when the configure command runs is sufficient.
            // Instead, for this command, we'll just return a promise
            // that never gets resolved.

            return new Promise(function () {});
          });
        };
      }
    }

    return executor;
  };

  return function (commandName) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve) {
      // We have to wrap the getExecutor() call in the promise so the promise
      // will be rejected if getExecutor() throws errors.
      var executor = getExecutor(commandName, options);
      logger.logOnBeforeCommand({
        commandName: commandName,
        options: options
      });
      resolve(executor());
    })["catch"](function (error) {
      return handleError(error, "".concat(commandName, " command"));
    })["catch"](function (error) {
      logger.logOnCommandRejected({
        commandName: commandName,
        options: options,
        error: error
      });
      throw error;
    }).then(function (rawResult) {
      // We should always be returning an object from every command.
      var result = isObject(rawResult) ? rawResult : {};
      logger.logOnCommandResolved({
        commandName: commandName,
        options: options,
        result: result
      });
      return result;
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var COMMAND_DOC_URI = "https://adobe.ly/2UH0qO7";

var validateCommandOptions = function validateCommandOptions(_ref18) {
  var command = _ref18.command,
      options = _ref18.options;
  var commandName = command.commandName,
      _command$documentatio = command.documentationUri,
      documentationUri = _command$documentatio === void 0 ? COMMAND_DOC_URI : _command$documentatio,
      optionsValidator = command.optionsValidator;
  var validatedOptions = options;

  if (optionsValidator) {
    try {
      validatedOptions = optionsValidator(options);
    } catch (validationError) {
      var invalidOptionsMessage = "Invalid ".concat(commandName, " command options:\n\t - ").concat(validationError, " For command documentation see: ").concat(documentationUri);
      throw new Error(invalidOptionsMessage);
    }
  }

  return validatedOptions;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Verifies user provided event options.
 * @param {*} options The user event options to validate
 * @param {*} logger
 * @returns {*} Validated options
 */


var validateUserEventOptions = function validateUserEventOptions(_ref19) {
  var options = _ref19.options,
      logger = _ref19.logger;
  var eventOptionsValidator = boundObjectOf({
    type: boundString(),
    xdm: boundObjectOf({
      eventType: boundString(),
      identityMap: validateIdentityMap
    }),
    data: boundObjectOf({}),
    renderDecisions: boundBoolean(),
    decisionScopes: boundArrayOf(boundString()),
    datasetId: boundString()
  }).required();
  var validatedOptions = eventOptionsValidator(options);
  var type = validatedOptions.type,
      xdm = validatedOptions.xdm;

  if (xdm && !xdm.eventType && !type) {
    logger.warn("No type or xdm.eventType specified.");
  }

  return validatedOptions;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createDataCollector = function createDataCollector(_ref20) {
  var eventManager = _ref20.eventManager,
      logger = _ref20.logger;
  return {
    commands: {
      sendEvent: {
        documentationUri: "https://adobe.ly/2r0uUjh",
        optionsValidator: function optionsValidator(options) {
          return validateUserEventOptions({
            options: options,
            logger: logger
          });
        },
        run: function run(options) {
          var xdm = options.xdm,
              data = options.data,
              _options$documentUnlo = options.documentUnloading,
              documentUnloading = _options$documentUnlo === void 0 ? false : _options$documentUnlo,
              type = options.type,
              mergeId = options.mergeId,
              _options$renderDecisi = options.renderDecisions,
              renderDecisions = _options$renderDecisi === void 0 ? false : _options$renderDecisi,
              _options$decisionScop = options.decisionScopes,
              decisionScopes = _options$decisionScop === void 0 ? [] : _options$decisionScop,
              datasetId = options.datasetId;
          var event = eventManager.createEvent();

          if (documentUnloading) {
            event.documentMayUnload();
          }

          event.setUserXdm(xdm);
          event.setUserData(data);

          if (type) {
            event.mergeXdm({
              eventType: type
            });
          }

          if (mergeId) {
            event.mergeXdm({
              eventMergeId: mergeId
            });
          }

          if (datasetId) {
            event.mergeMeta({
              collect: {
                datasetId: datasetId
              }
            });
          }

          return eventManager.sendEvent(event, {
            renderDecisions: renderDecisions,
            decisionScopes: decisionScopes
          });
        }
      }
    }
  };
};

createDataCollector.namespace = "DataCollector";
createDataCollector.configValidators = {};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createClickHandler = function createClickHandler(_ref21) {
  var eventManager = _ref21.eventManager,
      lifecycle = _ref21.lifecycle,
      handleError = _ref21.handleError;
  return function (clickEvent) {
    // TODO: Consider safeguarding from the same object being clicked multiple times in rapid succession?
    var clickedElement = clickEvent.target;
    var event = eventManager.createEvent();
    return lifecycle.onClick({
      event: event,
      clickedElement: clickedElement
    }).then(function () {
      if (event.isEmpty()) {
        return Promise.resolve();
      }

      return eventManager.sendEvent(event);
    }) // eventManager.sendEvent() will return a promise resolved to an
    // object and we want to avoid returning any value to the customer
    .then(noop)["catch"](function (error) {
      handleError(error, "click collection");
    });
  };
};

var attachClickActivityCollector = function attachClickActivityCollector(_ref22) {
  var config = _ref22.config,
      eventManager = _ref22.eventManager,
      lifecycle = _ref22.lifecycle,
      handleError = _ref22.handleError;
  var enabled = config.clickCollectionEnabled;

  if (!enabled) {
    return;
  }

  var clickHandler = createClickHandler({
    eventManager: eventManager,
    lifecycle: lifecycle,
    handleError: handleError
  });
  document.addEventListener("click", clickHandler, true);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var configValidators = {
  clickCollectionEnabled: boundBoolean()["default"](true),
  downloadLinkQualifier: boundString().regexp()["default"]("\\.(exe|zip|wav|mp3|mov|mpg|avi|wmv|pdf|doc|docx|xls|xlsx|ppt|pptx)$")
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var urlStartsWithScheme = function urlStartsWithScheme(url) {
  return url && /^[a-z0-9]+:\/\//i.test(url);
};

var getAbsoluteUrlFromAnchorElement = function getAbsoluteUrlFromAnchorElement(window, element) {
  var loc = window.location;
  var url = element.href ? element.href : "";
  var protocol = element.protocol,
      host = element.host;

  if (!urlStartsWithScheme(url)) {
    if (!protocol) {
      protocol = loc.protocol ? loc.protocol : "";
    }

    protocol = protocol ? "".concat(protocol, "//") : "";

    if (!host) {
      host = loc.host ? loc.host : "";
    }

    var path = "";

    if (url.substring(0, 1) !== "/") {
      var indx = loc.pathname.lastIndexOf("/");
      indx = indx < 0 ? 0 : indx;
      path = loc.pathname.substring(0, indx);
    }

    url = "".concat(protocol).concat(host).concat(path, "/").concat(url);
  }

  return url;
};

var isSupportedAnchorElement = function isSupportedAnchorElement(element) {
  if (element.href && (element.tagName === "A" || element.tagName === "AREA") && (!element.onclick || !element.protocol || element.protocol.toLowerCase().indexOf("javascript") < 0)) {
    return true;
  }

  return false;
};

var isDownloadLink = function isDownloadLink(downloadLinkQualifier, linkUrl, clickedObj) {
  var re = new RegExp(downloadLinkQualifier);
  return clickedObj.download ? true : re.test(linkUrl.toLowerCase());
};

var isExitLink = function isExitLink(window, linkUrl) {
  var currentHostname = window.location.hostname.toLowerCase();

  if (linkUrl.toLowerCase().indexOf(currentHostname) >= 0) {
    return false;
  }

  return true;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var determineLinkType = function determineLinkType(window, config, linkUrl, clickedObj) {
  var linkType = "other";

  if (isDownloadLink(config.downloadLinkQualifier, linkUrl, clickedObj)) {
    linkType = "download";
  } else if (isExitLink(window, linkUrl)) {
    linkType = "exit";
  }

  return linkType;
};

var findSupportedAnchorElement = function findSupportedAnchorElement(targetElement) {
  var node = targetElement;

  while (node) {
    if (isSupportedAnchorElement(node)) {
      return node;
    }

    node = node.parentNode;
  }

  return null;
};

var createLinkClick = function createLinkClick(window, config) {
  return function (event, targetElement) {
    // Search parent elements for an anchor element
    // TODO: Replace with generic DOM tool that can fetch configured properties
    var anchorElement = findSupportedAnchorElement(targetElement);

    if (!anchorElement) {
      return;
    }

    var linkUrl = getAbsoluteUrlFromAnchorElement(window, anchorElement);

    if (!linkUrl) {
      return;
    }

    var linkType = determineLinkType(window, config, linkUrl, anchorElement); // TODO: Update link name from the clicked element context

    var linkName = "Link Click";
    event.documentMayUnload();
    event.mergeXdm({
      eventType: "web.webinteraction.linkClicks",
      web: {
        webInteraction: {
          name: linkName,
          type: linkType,
          URL: linkUrl,
          linkClicks: {
            value: 1
          }
        }
      }
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createActivityCollector = function createActivityCollector(_ref23) {
  var config = _ref23.config,
      eventManager = _ref23.eventManager,
      handleError = _ref23.handleError;
  var linkClick = createLinkClick(window, config);
  return {
    lifecycle: {
      onComponentsRegistered: function onComponentsRegistered(tools) {
        var lifecycle = tools.lifecycle;
        attachClickActivityCollector({
          config: config,
          eventManager: eventManager,
          lifecycle: lifecycle,
          handleError: handleError
        }); // TODO: createScrollActivityCollector ...
      },
      onClick: function onClick(_ref24) {
        var event = _ref24.event,
            clickedElement = _ref24.clickedElement;
        linkClick(event, clickedElement);
      }
    }
  };
};

createActivityCollector.namespace = "ActivityCollector";
createActivityCollector.configValidators = configValidators;
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createResultLogMessage = function createResultLogMessage(idSync, success) {
  return "ID sync ".concat(success ? "succeeded" : "failed", ": ").concat(idSync.spec.url);
};

var injectProcessIdSyncs = function injectProcessIdSyncs(_ref25) {
  var fireReferrerHideableImage = _ref25.fireReferrerHideableImage,
      logger = _ref25.logger;
  return function (idSyncs) {
    var urlIdSyncs = idSyncs.filter(function (idSync) {
      return idSync.type === "url";
    });

    if (!urlIdSyncs.length) {
      return Promise.resolve();
    }

    return Promise.all(urlIdSyncs.map(function (idSync) {
      return fireReferrerHideableImage(idSync.spec).then(function () {
        logger.info(createResultLogMessage(idSync, true));
      })["catch"](function () {
        // We intentionally do not throw an error if id syncs fail. We
        // consider it a non-critical failure and therefore do not want it to
        // reject the promise handed back to the customer.
        logger.error(createResultLogMessage(idSync, false));
      });
    })).then(noop);
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var configValidators$1 = {
  thirdPartyCookiesEnabled: boundBoolean()["default"](true),
  idMigrationEnabled: boundBoolean()["default"](true)
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Verifies user provided event options.
 * @param {*} options The user event options to validate
 * @returns {*} Validated options
 */

var getIdentityOptionsValidator = function getIdentityOptionsValidator(options) {
  var getIdentityOptionsValidator = boundObjectOf({
    namespaces: boundArrayOf(boundLiteral("ECID")).nonEmpty()
  }).noUnknownFields();
  getIdentityOptionsValidator(options); // Return default options for now
  // To-Do: Accept namespace from given options

  return {
    namespaces: ["ECID"]
  };
};

var createComponent = function createComponent(_ref26) {
  var addEcidQueryToPayload = _ref26.addEcidQueryToPayload,
      ensureSingleIdentity = _ref26.ensureSingleIdentity,
      setLegacyEcid = _ref26.setLegacyEcid,
      handleResponseForIdSyncs = _ref26.handleResponseForIdSyncs,
      getEcidFromResponse = _ref26.getEcidFromResponse,
      getIdentity = _ref26.getIdentity,
      consent = _ref26.consent;
  var ecid;
  var edge = {};
  return {
    lifecycle: {
      onBeforeRequest: function onBeforeRequest(_ref27) {
        var request = _ref27.request,
            onResponse = _ref27.onResponse,
            onRequestFailure = _ref27.onRequestFailure;
        // Querying the ECID on every request to be able to set the legacy cookie, and make it
        // available for the `getIdentity` command.
        addEcidQueryToPayload(request.getPayload());
        return ensureSingleIdentity({
          request: request,
          onResponse: onResponse,
          onRequestFailure: onRequestFailure
        });
      },
      onResponse: function onResponse(_ref28) {
        var response = _ref28.response;

        if (!ecid) {
          ecid = getEcidFromResponse(response); // Only data collection calls will have an ECID in the response.
          // https://jira.corp.adobe.com/browse/EXEG-1234

          if (ecid) {
            setLegacyEcid(ecid);
          }
        } // For sendBeacon requests, getEdge() will return {}, so we are using assign here
        // so that sendBeacon requests don't override the edge info from before.


        edge = (0, _reactorObjectAssign["default"])(edge, response.getEdge());
        return handleResponseForIdSyncs(response);
      }
    },
    commands: {
      getIdentity: {
        optionsValidator: getIdentityOptionsValidator,
        run: function run(options) {
          return consent.awaitConsent().then(function () {
            return ecid ? undefined : getIdentity(options.namespaces);
          }).then(function () {
            return {
              identity: {
                ECID: ecid
              },
              edge: edge
            };
          });
        }
      }
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// Maybe default the domain in the cookieJar to apex while allowing overrides.


var apexDomain = getApexDomain(window, _reactorCookie["default"]);
/**
 * Handles migration of ECID to and from Visitor.js.
 */

var createLegacyIdentity = function createLegacyIdentity(_ref29) {
  var config = _ref29.config,
      getEcidFromVisitor = _ref29.getEcidFromVisitor;
  var idMigrationEnabled = config.idMigrationEnabled,
      orgId = config.orgId;
  var amcvCookieName = "AMCV_".concat(orgId);

  var getEcidFromLegacyCookies = function getEcidFromLegacyCookies() {
    var ecid = null;
    var secidCookieName = "s_ecid";

    var legacyEcidCookieValue = _reactorCookie["default"].get(secidCookieName) || _reactorCookie["default"].get(amcvCookieName);

    if (legacyEcidCookieValue) {
      var reg = /(^|\|)MCMID\|(\d+)($|\|)/;
      var matches = legacyEcidCookieValue.match(reg);

      if (matches) {
        // Destructuring arrays breaks in IE
        ecid = matches[2];
      }
    }

    return ecid;
  };

  return {
    getEcid: function getEcid() {
      if (idMigrationEnabled) {
        var ecid = getEcidFromLegacyCookies();

        if (ecid) {
          return Promise.resolve(ecid);
        }

        return getEcidFromVisitor();
      }

      return Promise.resolve();
    },
    setEcid: function setEcid(ecid) {
      if (idMigrationEnabled && !_reactorCookie["default"].get(amcvCookieName)) {
        _reactorCookie["default"].set(amcvCookieName, "MCMID|".concat(ecid), {
          domain: apexDomain,
          // Without `expires` this will be a session cookie.
          expires: 390 // days, or 13 months.

        });
      }
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var awaitVisitorOptIn = function awaitVisitorOptIn(_ref30) {
  var logger = _ref30.logger;
  return new Promise(function (resolve, reject) {
    if (isObject(window.adobe) && isObject(window.adobe.optIn)) {
      var optInOld = window.adobe.optIn;
      logger.info("Delaying request while waiting for legacy opt-in to let Visitor retrieve ECID from server.");
      optInOld.fetchPermissions(function () {
        if (optInOld.isApproved([optInOld.Categories.ECID])) {
          logger.info("Received legacy opt-in approval to let Visitor retrieve ECID from server.");
          resolve();
        } else {
          reject(new Error("Legacy opt-in was declined."));
        }
      }, true);
    } else {
      resolve();
    }
  });
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getVisitor = function getVisitor(window) {
  var Visitor = window.Visitor;
  return isFunction(Visitor) && isFunction(Visitor.getInstance) && Visitor;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectGetEcidFromVisitor = function injectGetEcidFromVisitor(_ref31) {
  var logger = _ref31.logger,
      orgId = _ref31.orgId,
      awaitVisitorOptIn = _ref31.awaitVisitorOptIn;
  var Visitor = getVisitor(window);
  return function () {
    if (Visitor) {
      // Need to explicitly wait for optIn because visitor will call callback
      // with invalid values prior to optIn being approved
      return awaitVisitorOptIn({
        logger: logger
      }).then(function () {
        logger.info("Delaying request while using Visitor to retrieve ECID from server.");
        return new Promise(function (resolve) {
          var visitor = Visitor.getInstance(orgId, {});
          visitor.getMarketingCloudVisitorID(function (ecid) {
            logger.info("Resuming previously delayed request that was waiting for ECID from Visitor.");
            resolve(ecid);
          }, true);
        });
      })["catch"](function (error) {
        // If consent was denied, get the ECID from experience edge. OptIn and AEP Web SDK
        // consent should operate independently, but during id migration AEP Web SDK needs
        // to wait for optIn object consent resolution so that only one ECID is generated.
        if (error) {
          logger.info("".concat(error.message, ", retrieving ECID from experience edge"));
        } else {
          logger.info("An error occurred while obtaining the ECID from Visitor.");
        }
      });
    }

    return Promise.resolve();
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectHandleResponseForIdSyncs = function injectHandleResponseForIdSyncs(_ref32) {
  var processIdSyncs = _ref32.processIdSyncs;
  return function (response) {
    return processIdSyncs(response.getPayloadsByType("identity:exchange"));
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// TO-DOCUMENT: We queue subsequent requests until we have an identity cookie.


var injectEnsureSingleIdentity = function injectEnsureSingleIdentity(_ref33) {
  var doesIdentityCookieExist = _ref33.doesIdentityCookieExist,
      setDomainForInitialIdentityPayload = _ref33.setDomainForInitialIdentityPayload,
      addLegacyEcidToPayload = _ref33.addLegacyEcidToPayload,
      awaitIdentityCookie = _ref33.awaitIdentityCookie,
      logger = _ref33.logger;
  var obtainedIdentityPromise;

  var allowRequestToGoWithoutIdentity = function allowRequestToGoWithoutIdentity(request) {
    setDomainForInitialIdentityPayload(request);
    return addLegacyEcidToPayload(request.getPayload());
  };
  /**
   * Ensures that if no identity cookie exists, we only let one request at a
   * time without an identity until its response returns. In the meantime,
   * we queue all other requests, otherwise the requests could result in
   * multiple ECIDs being minted for the user. Once we get an identity
   * cookie, we can let the queued requests be sent all at once, since they
   * will have the newly minted ECID.
   *
   * Konductor should make every effort to return an identity, but in
   * certain scenarios it may not. For example, in cases where the
   * request does not match what Konductor is expecting (ie 400s).
   * In cases where Konductor does not set an identity, there should be
   * no events recorded so we don't need to worry about multiple ECIDs
   * being minted for each user.
   *
   * The reason we allow for multiple sequential requests to be sent without
   * an identity is to prevent a single malformed request causing all other
   * requests to never send.
   */


  return function (_ref34) {
    var request = _ref34.request,
        onResponse = _ref34.onResponse,
        onRequestFailure = _ref34.onRequestFailure;

    if (doesIdentityCookieExist()) {
      request.setIsIdentityEstablished();
      return Promise.resolve();
    }

    if (obtainedIdentityPromise) {
      // We don't have an identity cookie, but at least one request has
      // been sent to get it. Konductor may set the identity cookie in the
      // response. We will hold up this request until the last request
      // requiring identity returns and awaitIdentityCookie confirms the
      // identity was set.
      logger.info("Delaying request while retrieving ECID from server.");
      var previousObtainedIdentityPromise = obtainedIdentityPromise; // This promise resolves when we have an identity cookie. Additional
      // requests are chained together so that only one is sent at a time
      // until we have the identity cookie.

      obtainedIdentityPromise = previousObtainedIdentityPromise["catch"](function () {
        return awaitIdentityCookie({
          onResponse: onResponse,
          onRequestFailure: onRequestFailure
        });
      }); // When this returned promise resolves, the request will go out.

      return previousObtainedIdentityPromise.then(function () {
        logger.info("Resuming previously delayed request.");
        request.setIsIdentityEstablished();
      }) // If Konductor did not set the identity cookie on the previous
      // request, then awaitIdentityCookie will reject its promise.
      // Catch the rejection here and allow this request to go out.
      ["catch"](function () {
        return allowRequestToGoWithoutIdentity(request);
      });
    } // For Alloy+Konductor communication to be as robust as possible and
    // to ensure we don't mint new ECIDs for requests that would otherwise
    // be sent in parallel, we'll let this request go out to fetch the
    // cookie


    obtainedIdentityPromise = awaitIdentityCookie({
      onResponse: onResponse,
      onRequestFailure: onRequestFailure
    });
    return allowRequestToGoWithoutIdentity(request);
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var ecidNamespace = "ECID";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var addEcidQueryToPayload = function addEcidQueryToPayload(payload) {
  payload.mergeQuery({
    identity: {
      fetch: [ecidNamespace]
    }
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var matchUserAgent = function matchUserAgent(regexs) {
  return function (userAgent) {
    var keys = Object.keys(regexs);

    for (var _i4 = 0; _i4 < keys.length; _i4 += 1) {
      var key = keys[_i4];
      var regex = regexs[key];

      if (regex.test(userAgent)) {
        return key;
      }
    }

    return UNKNOWN;
  };
};

var getBrowser = memoize(function (window) {
  var _matchUserAgent;

  return matchUserAgent((_matchUserAgent = {}, _defineProperty(_matchUserAgent, EDGE, /Edge\/([0-9\._]+)/), _defineProperty(_matchUserAgent, EDGE_CHROMIUM, /Edg\/([0-9\.]+)/), _defineProperty(_matchUserAgent, CHROME, /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/), _defineProperty(_matchUserAgent, FIREFOX, /Firefox\/([0-9\.]+)(?:\s|$)/), _defineProperty(_matchUserAgent, IE, /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/), _defineProperty(_matchUserAgent, SAFARI, /Version\/([0-9\._]+).*Safari/), _matchUserAgent))(window.navigator.userAgent);
});
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var injectSetDomainForInitialIdentityPayload = function injectSetDomainForInitialIdentityPayload(_ref35) {
  var thirdPartyCookiesEnabled = _ref35.thirdPartyCookiesEnabled,
      areThirdPartyCookiesSupportedByDefault = _ref35.areThirdPartyCookiesSupportedByDefault;
  return function (request) {
    if (thirdPartyCookiesEnabled && areThirdPartyCookiesSupportedByDefault(getBrowser(window))) {
      // If third-party cookies are enabled by the customer and
      // supported by the browser, we will send the request to a
      // a third-party identification domain that allows for more accurate
      // identification of the user through use of a third-party cookie.
      // If we have an identity to migrate, we still want to hit the
      // third-party identification domain because the third-party identification
      // domain will use our ECID to set the third-party cookie if the third-party
      // cookie isn't already set, which provides for better cross-domain
      // identification for future requests.
      request.setUseIdThirdPartyDomain();
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectAddLegacyEcidToPayload = function injectAddLegacyEcidToPayload(_ref36) {
  var getLegacyEcid = _ref36.getLegacyEcid,
      addEcidToPayload = _ref36.addEcidToPayload;
  return function (payload) {
    return getLegacyEcid().then(function (ecidToMigrate) {
      if (ecidToMigrate) {
        addEcidToPayload(payload, ecidToMigrate);
      }
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var addEcidToPayload = function addEcidToPayload(payload, ecid) {
  payload.addIdentity(ecidNamespace, {
    id: ecid
  });
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectAwaitIdentityCookie = function injectAwaitIdentityCookie(_ref37) {
  var orgId = _ref37.orgId,
      doesIdentityCookieExist = _ref37.doesIdentityCookieExist;

  /**
   * Returns a promise that will be resolved once an identity cookie exists.
   * If an identity cookie doesn't already exist, it should always exist after
   * the first response.
   */
  return function (_ref38) {
    var onResponse = _ref38.onResponse,
        onRequestFailure = _ref38.onRequestFailure;
    return new Promise(function (resolve, reject) {
      onResponse(function () {
        if (doesIdentityCookieExist()) {
          resolve();
        } else {
          // This logic assumes that the code setting the cookie is working as expected and that
          // the cookie was missing from the response.
          var noIdentityCookieError = new Error("An identity was not set properly. Please verify that the org ID ".concat(orgId, " configured in Alloy matches the org ID specified in the edge configuration.")); // Rejecting the promise will reject commands that were queued
          // by the Identity component while waiting on the response to
          // the initial request.

          reject(noIdentityCookieError); // Throwing an error will reject the event command that initiated
          // the request.

          throw noIdentityCookieError;
        }
      });
      onRequestFailure(function () {
        if (doesIdentityCookieExist()) {
          resolve();
        } else {
          // The error from the request failure will be logged separately. Rejecting this here
          // will tell ensureSingleIdentity to send the next request without identity
          reject(new Error("No identity was set on response."));
        }
      });
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getEcidFromResponse = function getEcidFromResponse(response) {
  var identityResultPayloads = response.getPayloadsByType("identity:result");
  var ecidPayload = find(identityResultPayloads, function (payload) {
    return payload.namespace && payload.namespace.code === ecidNamespace;
  });
  return ecidPayload ? ecidPayload.id : undefined;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createGetIdentity = function createGetIdentity(_ref39) {
  var sendEdgeNetworkRequest = _ref39.sendEdgeNetworkRequest,
      createIdentityRequestPayload = _ref39.createIdentityRequestPayload,
      createIdentityRequest = _ref39.createIdentityRequest;
  return function (namespaces) {
    var payload = createIdentityRequestPayload(namespaces);
    var request = createIdentityRequest(payload);
    return sendEdgeNetworkRequest({
      request: request
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createRequest = function createRequest(options) {
  var payload = options.payload,
      _getAction = options.getAction,
      _getUseSendBeacon = options.getUseSendBeacon;
  var id = v4_1();
  var shouldUseThirdPartyDomain = false;
  var isIdentityEstablished = false;
  return {
    getId: function getId() {
      return id;
    },
    getPayload: function getPayload() {
      return payload;
    },
    getAction: function getAction() {
      return _getAction({
        isIdentityEstablished: isIdentityEstablished
      });
    },
    getUseSendBeacon: function getUseSendBeacon() {
      return _getUseSendBeacon({
        isIdentityEstablished: isIdentityEstablished
      });
    },
    getUseIdThirdPartyDomain: function getUseIdThirdPartyDomain() {
      return shouldUseThirdPartyDomain;
    },
    setUseIdThirdPartyDomain: function setUseIdThirdPartyDomain() {
      shouldUseThirdPartyDomain = true;
    },
    setIsIdentityEstablished: function setIsIdentityEstablished() {
      isIdentityEstablished = true;
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createIdentityRequest = function createIdentityRequest(identityRequestPayload) {
  return createRequest({
    payload: identityRequestPayload,
    getAction: function getAction() {
      return "identity/acquire";
    },
    getUseSendBeacon: function getUseSendBeacon() {
      return false;
    }
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// request payloads share.


var createRequestPayload = function createRequestPayload(options) {
  var content = options.content,
      addIdentity = options.addIdentity;
  return {
    mergeState: createMerger(content, "meta.state"),
    mergeQuery: createMerger(content, "query"),
    addIdentity: addIdentity,
    toJSON: function toJSON() {
      return content;
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createAddIdentity = function createAddIdentity(content) {
  return function (namespaceCode, identity) {
    content.xdm = content.xdm || {};
    content.xdm.identityMap = content.xdm.identityMap || {};
    content.xdm.identityMap[namespaceCode] = content.xdm.identityMap[namespaceCode] || [];
    content.xdm.identityMap[namespaceCode].push(identity);
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createIdentityRequestPayload = function createIdentityRequestPayload(namespaces) {
  var content = {
    query: {
      identity: {
        fetch: namespaces
      }
    }
  };
  return createRequestPayload({
    content: content,
    addIdentity: createAddIdentity(content)
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createIdentity = function createIdentity(_ref40) {
  var config = _ref40.config,
      logger = _ref40.logger,
      consent = _ref40.consent,
      sendEdgeNetworkRequest = _ref40.sendEdgeNetworkRequest;
  var orgId = config.orgId,
      thirdPartyCookiesEnabled = config.thirdPartyCookiesEnabled;
  var getEcidFromVisitor = injectGetEcidFromVisitor({
    logger: logger,
    orgId: orgId,
    awaitVisitorOptIn: awaitVisitorOptIn
  });
  var legacyIdentity = createLegacyIdentity({
    config: config,
    getEcidFromVisitor: getEcidFromVisitor
  });
  var doesIdentityCookieExist = injectDoesIdentityCookieExist({
    orgId: orgId
  });
  var getIdentity = createGetIdentity({
    sendEdgeNetworkRequest: sendEdgeNetworkRequest,
    createIdentityRequestPayload: createIdentityRequestPayload,
    createIdentityRequest: createIdentityRequest
  });
  var setDomainForInitialIdentityPayload = injectSetDomainForInitialIdentityPayload({
    thirdPartyCookiesEnabled: thirdPartyCookiesEnabled,
    areThirdPartyCookiesSupportedByDefault: areThirdPartyCookiesSupportedByDefault
  });
  var addLegacyEcidToPayload = injectAddLegacyEcidToPayload({
    getLegacyEcid: legacyIdentity.getEcid,
    addEcidToPayload: addEcidToPayload
  });
  var awaitIdentityCookie = injectAwaitIdentityCookie({
    orgId: orgId,
    doesIdentityCookieExist: doesIdentityCookieExist
  });
  var ensureSingleIdentity = injectEnsureSingleIdentity({
    doesIdentityCookieExist: doesIdentityCookieExist,
    setDomainForInitialIdentityPayload: setDomainForInitialIdentityPayload,
    addLegacyEcidToPayload: addLegacyEcidToPayload,
    awaitIdentityCookie: awaitIdentityCookie,
    logger: logger
  });
  var processIdSyncs = injectProcessIdSyncs({
    fireReferrerHideableImage: fireReferrerHideableImage,
    logger: logger
  });
  var handleResponseForIdSyncs = injectHandleResponseForIdSyncs({
    processIdSyncs: processIdSyncs
  });
  return createComponent({
    ensureSingleIdentity: ensureSingleIdentity,
    addEcidQueryToPayload: addEcidQueryToPayload,
    setLegacyEcid: legacyIdentity.setEcid,
    handleResponseForIdSyncs: handleResponseForIdSyncs,
    getEcidFromResponse: getEcidFromResponse,
    getIdentity: getIdentity,
    consent: consent
  });
};

createIdentity.namespace = "Identity";
createIdentity.configValidators = configValidators$1;
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createResultLogMessage$1 = function createResultLogMessage$1(urlDestination, success) {
  return "URL destination ".concat(success ? "succeeded" : "failed", ": ").concat(urlDestination.spec.url);
};

var processUrls = function processUrls(fireReferrerHideableImage, logger, destinations) {
  var urlDestinations = destinations.filter(function (dest) {
    return dest.type === "url";
  });
  return Promise.all(urlDestinations.map(function (urlDestination) {
    return fireReferrerHideableImage(urlDestination.spec).then(function () {
      logger.info(createResultLogMessage$1(urlDestination, true));
    })["catch"](function () {
      // We intentionally do not throw an error if destinations fail. We
      // consider it a non-critical failure and therefore do not want it to
      // reject the promise handed back to the customer.
      logger.error(createResultLogMessage$1(urlDestination, false));
    });
  })).then(noop);
};

var processCookies = function processCookies(destinations) {
  var cookieDestinations = destinations.filter(function (dest) {
    return dest.type === "cookie";
  });
  cookieDestinations.forEach(function (dest) {
    var _dest$spec = dest.spec,
        name = _dest$spec.name,
        value = _dest$spec.value,
        domain = _dest$spec.domain,
        ttlDays = _dest$spec.ttlDays;

    _reactorCookie["default"].set(name, value || "", {
      domain: domain || "",
      expires: ttlDays || 10 // days

    });
  });
};

var injectProcessDestinations = function injectProcessDestinations(_ref41) {
  var fireReferrerHideableImage = _ref41.fireReferrerHideableImage,
      logger = _ref41.logger;
  return function (destinations) {
    processCookies(destinations);
    return processUrls(fireReferrerHideableImage, logger, destinations);
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createAudiences = function createAudiences(_ref42) {
  var logger = _ref42.logger;
  var processDestinations = injectProcessDestinations({
    fireReferrerHideableImage: fireReferrerHideableImage,
    logger: logger
  });

  var processDestinationsFromResponse = function processDestinationsFromResponse(_ref43) {
    var response = _ref43.response;
    var destinations = response.getPayloadsByType("activation:push");
    return processDestinations(destinations);
  };

  return {
    lifecycle: {
      onResponse: processDestinationsFromResponse
    },
    commands: {}
  };
};

createAudiences.namespace = "Audiences";
createAudiences.configValidators = {};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var PAGE_WIDE_SCOPE = "__view__";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var DOM_ACTION = "https://ns.adobe.com/personalization/dom-action";
var HTML_CONTENT_ITEM = "https://ns.adobe.com/personalization/html-content-item";
var JSON_CONTENT_ITEM = "https://ns.adobe.com/personalization/json-content-item";
var REDIRECT_ITEM = "https://ns.adobe.com/personalization/redirect-item";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createPersonalizationDetails = function createPersonalizationDetails(_ref44) {
  var renderDecisions = _ref44.renderDecisions,
      decisionScopes = _ref44.decisionScopes,
      event = _ref44.event,
      viewCache = _ref44.viewCache;
  var viewName = event.getViewName();
  return {
    isRenderDecisions: function isRenderDecisions() {
      return renderDecisions;
    },
    getViewName: function getViewName() {
      return viewName;
    },
    hasScopes: function hasScopes() {
      return decisionScopes.length > 0;
    },
    hasViewName: function hasViewName() {
      return isNonEmptyString(viewName);
    },
    createQueryDetails: function createQueryDetails() {
      var scopes = _toConsumableArray(decisionScopes);

      if (!this.isCacheInitialized() && !includes(scopes, PAGE_WIDE_SCOPE)) {
        scopes.push(PAGE_WIDE_SCOPE);
      }

      var schemas = [HTML_CONTENT_ITEM, JSON_CONTENT_ITEM, REDIRECT_ITEM];

      if (includes(scopes, PAGE_WIDE_SCOPE)) {
        schemas.push(DOM_ACTION);
      }

      return {
        schemas: schemas,
        decisionScopes: scopes
      };
    },
    isCacheInitialized: function isCacheInitialized() {
      return viewCache.isInitialized();
    },
    shouldFetchData: function shouldFetchData() {
      return this.hasScopes() || !this.isCacheInitialized();
    },
    shouldUseCachedData: function shouldUseCachedData() {
      return this.hasViewName() && this.isCacheInitialized();
    }
  };
};

var AUTHORING_ENABLED = "Rendering is disabled for authoring mode.";
var REDIRECT_EXECUTION_ERROR = "An error occurred while executing the redirect offer.";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createComponent$1 = function createComponent$1(_ref45) {
  var logger = _ref45.logger,
      fetchDataHandler = _ref45.fetchDataHandler,
      viewChangeHandler = _ref45.viewChangeHandler,
      onClickHandler = _ref45.onClickHandler,
      isAuthoringModeEnabled = _ref45.isAuthoringModeEnabled,
      mergeQuery = _ref45.mergeQuery,
      viewCache = _ref45.viewCache;
  return {
    lifecycle: {
      onBeforeEvent: function onBeforeEvent(_ref46) {
        var event = _ref46.event,
            renderDecisions = _ref46.renderDecisions,
            _ref46$decisionScopes = _ref46.decisionScopes,
            decisionScopes = _ref46$decisionScopes === void 0 ? [] : _ref46$decisionScopes,
            _ref46$onResponse = _ref46.onResponse,
            onResponse = _ref46$onResponse === void 0 ? noop : _ref46$onResponse,
            _ref46$onRequestFailu = _ref46.onRequestFailure,
            onRequestFailure = _ref46$onRequestFailu === void 0 ? noop : _ref46$onRequestFailu;

        if (isAuthoringModeEnabled()) {
          logger.warn(AUTHORING_ENABLED); // If we are in authoring mode we disable personalization

          mergeQuery(event, {
            enabled: false
          });
          return;
        }

        var personalizationDetails = createPersonalizationDetails({
          renderDecisions: renderDecisions,
          decisionScopes: decisionScopes,
          event: event,
          viewCache: viewCache
        });

        if (personalizationDetails.shouldFetchData()) {
          var decisionsDeferred = defer();
          viewCache.storeViews(decisionsDeferred.promise);
          fetchDataHandler({
            decisionsDeferred: decisionsDeferred,
            personalizationDetails: personalizationDetails,
            event: event,
            onResponse: onResponse,
            onRequestFailure: onRequestFailure
          });
          return;
        }

        if (personalizationDetails.shouldUseCachedData()) {
          viewChangeHandler({
            personalizationDetails: personalizationDetails,
            onResponse: onResponse,
            onRequestFailure: onRequestFailure
          });
        }
      },
      onClick: function onClick(_ref47) {
        var event = _ref47.event,
            clickedElement = _ref47.clickedElement;
        onClickHandler({
          event: event,
          clickedElement: clickedElement
        });
      }
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createFragment = function createFragment(content) {
  return createNode(DIV, {}, {
    innerHTML: content
  });
};

var css_escape = createCommonjsModule(function (module, exports) {
  (function (root, factory) {
    // https://github.com/umdjs/umd/blob/master/returnExports.js
    {
      // For Node.js.
      module.exports = factory(root);
    }
  })(typeof commonjsGlobal != 'undefined' ? commonjsGlobal : commonjsGlobal, function (root) {
    if (root.CSS && root.CSS.escape) {
      return root.CSS.escape;
    } // https://drafts.csswg.org/cssom/#serialize-an-identifier


    var cssEscape = function cssEscape(value) {
      if (arguments.length == 0) {
        throw new TypeError('`CSS.escape` requires an argument.');
      }

      var string = String(value);
      var length = string.length;
      var index = -1;
      var codeUnit;
      var result = '';
      var firstCodeUnit = string.charCodeAt(0);

      while (++index < length) {
        codeUnit = string.charCodeAt(index); // Note: thereâ€™s no need to special-case astral symbols, surrogate
        // pairs, or lone surrogates.
        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
        // (U+FFFD).

        if (codeUnit == 0x0000) {
          result += "\uFFFD";
          continue;
        }

        if ( // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
        // U+007F, [â€¦]
        codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F || // If the character is the first character and is in the range [0-9]
        // (U+0030 to U+0039), [â€¦]
        index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 || // If the character is the second character and is in the range [0-9]
        // (U+0030 to U+0039) and the first character is a `-` (U+002D), [â€¦]
        index == 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit == 0x002D) {
          // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
          result += '\\' + codeUnit.toString(16) + ' ';
          continue;
        }

        if ( // If the character is the first character and is a `-` (U+002D), and
        // there is no second character, [â€¦]
        index == 0 && length == 1 && codeUnit == 0x002D) {
          result += '\\' + string.charAt(index);
          continue;
        } // If the character is not handled by one of the above rules and is
        // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
        // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
        // U+005A), or [a-z] (U+0061 to U+007A), [â€¦]


        if (codeUnit >= 0x0080 || codeUnit == 0x002D || codeUnit == 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {
          // the character itself
          result += string.charAt(index);
          continue;
        } // Otherwise, the escaped character.
        // https://drafts.csswg.org/cssom/#escape-a-character


        result += '\\' + string.charAt(index);
      }

      return result;
    };

    if (!root.CSS) {
      root.CSS = {};
    }

    root.CSS.escape = cssEscape;
    return cssEscape;
  });
});
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var EQ_START = ":eq(";
var EQ_PATTERN = /:eq\((\d+)\)/g;

var isNotEqSelector = function isNotEqSelector(str) {
  return str.indexOf(EQ_START) === -1;
};

var splitWithEq = function splitWithEq(selector) {
  return selector.split(EQ_PATTERN).filter(isNonEmptyString);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var CSS_IDENTIFIER_PATTERN = /(#|\.)(-?\w+)/g; // This is required to remove leading " > " from parsed pieces

var SIBLING_PATTERN = /^\s*>?\s*/;

var cleanUp = function cleanUp(str) {
  return str.replace(SIBLING_PATTERN, "").trim();
}; // Here we use CSS.escape() to make sure we get
// correct values for ID and CSS class
// Please check:  https://www.w3.org/TR/css-syntax-3/#escaping
// CSS.escape() polyfill can be found here: https://github.com/mathiasbynens/CSS.escape


var replaceIdentifier = function replaceIdentifier(_, $1, $2) {
  return "".concat($1).concat(css_escape($2));
};

var escapeIdentifiersInSelector = function escapeIdentifiersInSelector(selector) {
  return selector.replace(CSS_IDENTIFIER_PATTERN, replaceIdentifier);
};

var parseSelector = function parseSelector(rawSelector) {
  var result = [];
  var selector = escapeIdentifiersInSelector(rawSelector.trim());
  var parts = splitWithEq(selector);
  var length = parts.length;
  var i = 0;

  while (i < length) {
    var sel = cleanUp(parts[i]);
    var eq = parts[i + 1];

    if (eq) {
      result.push({
        sel: sel,
        eq: Number(eq)
      });
    } else {
      result.push({
        sel: sel
      });
    }

    i += 2;
  }

  return result;
};
/**
 * Returns an array of matched DOM nodes.
 * @param {String} selector that contains Sizzle "eq(...)" pseudo selector
 * @returns {Array} an array of DOM nodes
 */


var selectNodesWithEq = function selectNodesWithEq(selector) {
  var doc = document;

  if (isNotEqSelector(selector)) {
    return selectNodes(selector, doc);
  }

  var parts = parseSelector(selector);
  var length = parts.length;
  var result = [];
  var context = doc;
  var i = 0;

  while (i < length) {
    var _parts$i = parts[i],
        sel = _parts$i.sel,
        eq = _parts$i.eq;
    var nodes = selectNodes(sel, context);
    var nodesCount = nodes.length;

    if (nodesCount === 0) {
      break;
    }

    if (eq != null && eq > nodesCount - 1) {
      break;
    }

    if (i < length - 1) {
      if (eq == null) {
        var _nodes = _slicedToArray(nodes, 1);

        context = _nodes[0];
      } else {
        context = nodes[eq];
      }
    }

    if (i === length - 1) {
      if (eq == null) {
        result = nodes;
      } else {
        result = [nodes[eq]];
      }
    }

    i += 1;
  }

  return result;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns an array of matched DOM nodes.
 * @param {String} id
 * @param {Node} [context=document] defaults to document
 * @returns {HTMLElement} an element of null
 */


var getElementById = function getElementById(id) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return context.getElementById(id);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var setAttribute = function setAttribute(element, name, value) {
  element.setAttribute(name, value);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getAttribute = function getAttribute(element, name) {
  return element.getAttribute(name);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var removeAttribute = function removeAttribute(element, name) {
  element.removeAttribute(name);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var setStyle = function setStyle(element, name, value, priority) {
  var css;

  if (priority) {
    css = "".concat(name, ":").concat(value, " !").concat(priority, ";");
  } else {
    css = "".concat(name, ":").concat(value, ";");
  }

  element.style.cssText += ";".concat(css);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getParent = function getParent(element) {
  return element.parentNode;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getNextSibling = function getNextSibling(element) {
  return element.nextElementSibling;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var insertAfter = function insertAfter(container, element) {
  if (!container) {
    return;
  }

  var parent = getParent(container);

  if (parent) {
    parent.insertBefore(element, getNextSibling(container));
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var insertBefore = function insertBefore(container, element) {
  if (!container) {
    return;
  }

  var parent = getParent(container);

  if (parent) {
    parent.insertBefore(element, container);
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getChildren = function getChildren(element) {
  var children = element.children;

  if (children) {
    return toArray(children);
  }

  return [];
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getChildNodes = function getChildNodes(element) {
  var childNodes = element.childNodes;

  if (childNodes) {
    return toArray(childNodes);
  }

  return [];
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getFirstChild = function getFirstChild(element) {
  return element.firstElementChild;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var nonce;
/**
 * Returns the nonce if available.
 * @param {Node} [context=document] defaults to document
 * @returns {(String|undefined)} the nonce or undefined if not available
 */

var getNonce = function getNonce() {
  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

  if (nonce === undefined) {
    var n = context.querySelector("[nonce]"); // NOTE: We're keeping n.getAttribute("nonce") until it is safe to remove:
    //   ref: https://github.com/whatwg/html/issues/2369#issuecomment-280853946

    nonce = n && (n.nonce || n.getAttribute("nonce"));
  }

  return nonce;
}; // This function is only used for testing and removed when library is built (tree-shaking)

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var PREHIDING_ID = "alloy-prehiding";
var HIDING_STYLE_DEFINITION = "{ visibility: hidden }"; // Using global is OK since we have a single DOM
// so storing nodes even for multiple Alloy instances is fine

var styleNodes = {};

var hideElements = function hideElements(prehidingSelector) {
  // if we have different events with the same
  // prehiding selector we don't want to recreate
  // the style tag
  if (styleNodes[prehidingSelector]) {
    return;
  }

  var nonce = getNonce();

  var attrs = _objectSpread({}, nonce && {
    nonce: nonce
  });

  var props = {
    textContent: "".concat(prehidingSelector, " ").concat(HIDING_STYLE_DEFINITION)
  };
  var node = createNode(STYLE, attrs, props);
  appendNode(document.head, node);
  styleNodes[prehidingSelector] = node;
};

var showElements = function showElements(prehidingSelector) {
  var node = styleNodes[prehidingSelector];

  if (node) {
    removeNode(node);
    delete styleNodes[prehidingSelector];
  }
};

var hideContainers = function hideContainers(prehidingStyle) {
  if (!prehidingStyle) {
    return;
  } // If containers prehiding style has been added
  // by customer's prehiding snippet we don't
  // want to add the same node


  var node = getElementById(PREHIDING_ID);

  if (node) {
    return;
  }

  var nonce = getNonce();

  var attrs = _objectSpread({
    id: PREHIDING_ID
  }, nonce && {
    nonce: nonce
  });

  var props = {
    textContent: prehidingStyle
  };
  var styleNode = createNode(STYLE, attrs, props);
  appendNode(document.head, styleNode);
};

var showContainers = function showContainers() {
  // If containers prehiding style exists
  // we will remove it
  var node = getElementById(PREHIDING_ID);

  if (!node) {
    return;
  }

  removeNode(node);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var setText = function setText(container, text) {
  container.textContent = text;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var isImage = function isImage(element) {
  return element.tagName === IMG;
};

var loadImage = function loadImage(url) {
  return createNode(IMG, {
    src: url
  });
};

var loadImages = function loadImages(fragment) {
  var images = selectNodes(IMG, fragment);
  images.forEach(function (image) {
    var url = getAttribute(image, SRC);

    if (url) {
      loadImage(url);
    }
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var is = function is(element, tagName) {
  return element.tagName === tagName;
};

var isInlineStyleElement = function isInlineStyleElement(element) {
  return is(element, STYLE) && !getAttribute(element, SRC);
};

var addNonceToInlineStyleElements = function addNonceToInlineStyleElements(fragment) {
  var styleNodes = selectNodes(STYLE, fragment);
  var length = styleNodes.length;
  var nonce = getNonce();

  if (!nonce) {
    return;
  }
  /* eslint-disable no-continue */


  for (var _i5 = 0; _i5 < length; _i5 += 1) {
    var element = styleNodes[_i5];

    if (!isInlineStyleElement(element)) {
      continue;
    }

    element.nonce = nonce;
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var is$1 = function is$1(element, tagName) {
  return !!element && element.tagName === tagName;
};

var isInlineScript = function isInlineScript(element) {
  return is$1(element, SCRIPT) && !getAttribute(element, SRC);
};

var isRemoteScript = function isRemoteScript(element) {
  return is$1(element, SCRIPT) && getAttribute(element, SRC);
};

var getInlineScripts = function getInlineScripts(fragment) {
  var scripts = selectNodes(SCRIPT, fragment);
  var result = [];
  var length = scripts.length;
  var nonce = getNonce();

  var attributes = _objectSpread({}, nonce && {
    nonce: nonce
  });
  /* eslint-disable no-continue */


  for (var _i6 = 0; _i6 < length; _i6 += 1) {
    var element = scripts[_i6];

    if (!isInlineScript(element)) {
      continue;
    }

    var textContent = element.textContent;

    if (!textContent) {
      continue;
    }

    result.push(createNode(SCRIPT, attributes, {
      textContent: textContent
    }));
  }
  /* eslint-enable no-continue */


  return result;
};

var getRemoteScriptsUrls = function getRemoteScriptsUrls(fragment) {
  var scripts = selectNodes(SCRIPT, fragment);
  var result = [];
  var length = scripts.length;
  /* eslint-disable no-continue */

  for (var _i7 = 0; _i7 < length; _i7 += 1) {
    var element = scripts[_i7];

    if (!isRemoteScript(element)) {
      continue;
    }

    var url = getAttribute(element, SRC);

    if (!url) {
      continue;
    }

    result.push(url);
  }
  /* eslint-enable no-continue */


  return result;
};

var executeInlineScripts = function executeInlineScripts(container, scripts, func) {
  scripts.forEach(function (script) {
    return func(container, script);
  });
};

var executeRemoteScripts = function executeRemoteScripts(urls) {
  return Promise.all(urls.map(_reactorLoadScript["default"]));
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var appendHtml = function appendHtml(container, html) {
  var fragment = createFragment(html);
  addNonceToInlineStyleElements(fragment);
  var elements = getChildNodes(fragment);
  var scripts = getInlineScripts(fragment);
  var scriptsUrls = getRemoteScriptsUrls(fragment);
  loadImages(fragment);
  elements.forEach(function (element) {
    appendNode(container, element);
  });
  executeInlineScripts(container, scripts, appendNode);
  return executeRemoteScripts(scriptsUrls);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var clear = function clear(container) {
  // We want to remove ALL nodes, text, comments etc
  var childNodes = getChildNodes(container);
  childNodes.forEach(removeNode);
};

var setHtml = function setHtml(container, html) {
  clear(container);
  appendHtml(container, html);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var prependHtml = function prependHtml(container, html) {
  var fragment = createFragment(html);
  addNonceToInlineStyleElements(fragment);
  var elements = getChildNodes(fragment);
  var scripts = getInlineScripts(fragment);
  var scriptsUrls = getRemoteScriptsUrls(fragment);
  var length = elements.length;
  var i = length - 1; // We have to proactively load images to avoid flicker

  loadImages(fragment); // We are inserting elements in reverse order

  while (i >= 0) {
    var element = elements[i];
    var firstChild = getFirstChild(container);

    if (firstChild) {
      insertBefore(firstChild, element);
    } else {
      appendNode(container, element);
    }

    i -= 1;
  }

  executeInlineScripts(container, scripts, appendNode);
  return executeRemoteScripts(scriptsUrls);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var insertHtmlBefore = function insertHtmlBefore(container, html) {
  var fragment = createFragment(html);
  addNonceToInlineStyleElements(fragment);
  var elements = getChildNodes(fragment);
  var scripts = getInlineScripts(fragment);
  var scriptsUrls = getRemoteScriptsUrls(fragment);
  loadImages(fragment);
  elements.forEach(function (element) {
    insertBefore(container, element);
  });
  executeInlineScripts(container, scripts, insertBefore);
  return executeRemoteScripts(scriptsUrls);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var replaceHtml = function replaceHtml(container, html) {
  insertHtmlBefore(container, html);
  removeNode(container);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var insertHtmlAfter = function insertHtmlAfter(container, html) {
  var fragment = createFragment(html);
  addNonceToInlineStyleElements(fragment);
  var elements = getChildNodes(fragment);
  var scripts = getInlineScripts(fragment);
  var scriptsUrls = getRemoteScriptsUrls(fragment);
  loadImages(fragment);
  elements.forEach(function (element) {
    insertAfter(container, element);
  });
  executeInlineScripts(container, scripts, insertAfter);
  return executeRemoteScripts(scriptsUrls);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var setStyles = function setStyles(container, styles) {
  var priority = styles.priority,
      style = _objectWithoutProperties(styles, ["priority"]);

  Object.keys(style).forEach(function (key) {
    setStyle(container, key, style[key], priority);
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var setAttributes = function setAttributes(container, attributes) {
  Object.keys(attributes).forEach(function (key) {
    setAttribute(container, key, attributes[key]);
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var swapImage = function swapImage(container, url) {
  if (!isImage(container)) {
    return;
  } // Start downloading the image


  loadImage(url); // Remove "src" so there is no flicker

  removeAttribute(container, SRC); // Replace the image "src"

  setAttribute(container, SRC, url);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var rearrangeChildren = function rearrangeChildren(container, _ref48) {
  var from = _ref48.from,
      to = _ref48.to;
  var children = getChildren(container);
  var elementFrom = children[from];
  var elementTo = children[to];

  if (!elementFrom || !elementTo) {
    // TODO: We will need to add logging
    // to ease troubleshooting
    return;
  }

  if (from < to) {
    insertAfter(elementTo, elementFrom);
  } else {
    insertBefore(elementTo, elementFrom);
  }
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var _click = function click(settings, store) {
  var selector = settings.selector,
      meta = settings.meta;
  store({
    selector: selector,
    meta: meta
  });
  return Promise.resolve();
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var renderContent = function renderContent(elements, content, renderFunc) {
  var executions = elements.map(function (element) {
    return renderFunc(element, content);
  });
  return Promise.all(executions);
};

var createAction = function createAction(renderFunc) {
  return function (settings) {
    var selector = settings.selector,
        prehidingSelector = settings.prehidingSelector,
        content = settings.content,
        meta = settings.meta;
    hideElements(prehidingSelector);
    return awaitSelector(selector, selectNodesWithEq).then(function (elements) {
      return renderContent(elements, content, renderFunc);
    }).then(function () {
      // if everything is OK, show elements
      showElements(prehidingSelector);
      return {
        meta: meta
      };
    }, function (error) {
      // in case of awaiting timing or error, we need to remove the style tag
      // hence showing the pre-hidden elements
      showElements(prehidingSelector);
      return {
        meta: meta,
        error: error
      };
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var initDomActionsModules = function initDomActionsModules(store) {
  return {
    setHtml: createAction(setHtml),
    customCode: createAction(prependHtml),
    setText: createAction(setText),
    setAttribute: createAction(setAttributes),
    setImageSource: createAction(swapImage),
    setStyle: createAction(setStyles),
    move: createAction(setStyles),
    resize: createAction(setStyles),
    rearrange: createAction(rearrangeChildren),
    remove: createAction(removeNode),
    insertAfter: createAction(insertHtmlAfter),
    insertBefore: createAction(insertHtmlBefore),
    replaceHtml: createAction(replaceHtml),
    prependHtml: createAction(prependHtml),
    appendHtml: createAction(appendHtml),
    click: function click(settings) {
      return _click(settings, store);
    }
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Returns whether a string value is blank. Also returns true if the value is not a string.
 * @param {*} value
 * @returns {boolean}
 */


var isBlankString = function isBlankString(value) {
  return isString(value) ? !value.trim() : true;
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var APPEND_HTML = "appendHtml";
var HEAD_TAGS_SELECTOR = "SCRIPT,LINK,STYLE";

var filterHeadContent = function filterHeadContent(content) {
  var container = createFragment(content);
  var headNodes = selectNodes(HEAD_TAGS_SELECTOR, container);
  return headNodes.map(function (node) {
    return node.outerHTML;
  }).join("");
};

var preprocess = function preprocess(action) {
  var result = (0, _reactorObjectAssign["default"])({}, action);
  var content = result.content,
      selector = result.selector;

  if (isBlankString(content)) {
    return result;
  }

  var container = selectNodesWithEq(selector);

  if (!is$1(container[0], HEAD)) {
    return result;
  }

  result.type = APPEND_HTML;
  result.content = filterHeadContent(content);
  return result;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var logActionError = function logActionError(logger, action, error) {
  if (logger.enabled) {
    var details = JSON.stringify(action);
    var message = error.message,
        stack = error.stack;
    var errorMessage = "Failed to execute action ".concat(details, ". ").concat(message, " ").concat(stack ? "\n ".concat(stack) : "");
    logger.error(errorMessage);
  }
};

var logActionCompleted = function logActionCompleted(logger, action) {
  if (logger.enabled) {
    var details = JSON.stringify(action);
    logger.info("Action ".concat(details, " executed."));
  }
};

var executeAction = function executeAction(logger, modules, type, args) {
  var execute = modules[type];

  if (!execute) {
    var error = new Error("DOM action \"".concat(type, "\" not found"));
    logActionError(logger, args[0], error);
    throw error;
  }

  return execute.apply(void 0, _toConsumableArray(args));
};

var executeActions = function executeActions(actions, modules, logger) {
  var actionPromises = actions.map(function (action) {
    var processedAction = preprocess(action);
    var type = processedAction.type;
    return executeAction(logger, modules, type, [processedAction]).then(function (result) {
      logActionCompleted(logger, processedAction);
      return result;
    })["catch"](function (error) {
      logActionError(logger, processedAction, error);
      throw error;
    });
  });
  return Promise.all(actionPromises);
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createCollect = function createCollect(_ref49) {
  var eventManager = _ref49.eventManager,
      mergeDecisionsMeta = _ref49.mergeDecisionsMeta;
  // Called when a decision is auto-rendered for the __view__ scope (non-SPA view).
  return function (_ref50) {
    var decisionsMeta = _ref50.decisionsMeta,
        _ref50$documentMayUnl = _ref50.documentMayUnload,
        documentMayUnload = _ref50$documentMayUnl === void 0 ? false : _ref50$documentMayUnl;
    var event = eventManager.createEvent();
    event.mergeXdm({
      eventType: "display"
    });
    mergeDecisionsMeta(event, decisionsMeta);

    if (documentMayUnload) {
      event.documentMayUnload();
    }

    return eventManager.sendEvent(event);
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createViewCollect = function createViewCollect(_ref51) {
  var eventManager = _ref51.eventManager,
      mergeDecisionsMeta = _ref51.mergeDecisionsMeta;
  // Called when an offer for a specific SPA view is auto-rendered.
  return function (_ref52) {
    var decisionsMeta = _ref52.decisionsMeta,
        xdm = _ref52.xdm;
    var data = {
      eventType: "display"
    };
    var event = eventManager.createEvent();

    if (isNonEmptyArray(decisionsMeta)) {
      var viewName = decisionsMeta[0].scope;
      data.web = {
        webPageDetails: {
          viewName: viewName
        }
      };
      mergeDecisionsMeta(event, decisionsMeta);
    }

    event.mergeXdm(data);
    event.mergeXdm(xdm);
    return eventManager.sendEvent(event);
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var identity = function identity(item) {
  return item;
};

var buildActions = function buildActions(decision) {
  var meta = {
    id: decision.id,
    scope: decision.scope,
    scopeDetails: decision.scopeDetails
  };
  return decision.items.map(function (item) {
    return (0, _reactorObjectAssign["default"])({}, item.data, {
      meta: meta
    });
  });
};

var processMetas = function processMetas(collect, logger, actionResults) {
  var results = flatMap(actionResults, identity);
  var finalMetas = [];
  var set = new Set();
  results.forEach(function (item) {
    // for click actions we don't return an item
    if (!item) {
      return;
    }

    if (item.error) {
      logger.warn(item);
      return;
    }

    var meta = item.meta;

    if (set.has(meta.id)) {
      return;
    }

    set.add(meta.id);
    finalMetas.push(meta);
  });

  if (isNonEmptyArray(finalMetas)) {
    // collect here can either be the function from createCollect or createViewCollect.
    collect({
      decisionsMeta: finalMetas
    });
  }
};

var createExecuteDecisions = function createExecuteDecisions(_ref53) {
  var modules = _ref53.modules,
      logger = _ref53.logger,
      executeActions = _ref53.executeActions,
      collect = _ref53.collect;
  return function (decisions) {
    var actionResultsPromises = decisions.map(function (decision) {
      var actions = buildActions(decision);
      return executeActions(actions, modules, logger);
    });
    return Promise.all(actionResultsPromises).then(function (results) {
      return processMetas(collect, logger, results);
    })["catch"](function (error) {
      logger.error(error);
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createFetchDataHandler = function createFetchDataHandler(_ref54) {
  var config = _ref54.config,
      responseHandler = _ref54.responseHandler,
      showContainers = _ref54.showContainers,
      hideContainers = _ref54.hideContainers,
      mergeQuery = _ref54.mergeQuery;
  return function (_ref55) {
    var decisionsDeferred = _ref55.decisionsDeferred,
        personalizationDetails = _ref55.personalizationDetails,
        event = _ref55.event,
        onResponse = _ref55.onResponse,
        onRequestFailure = _ref55.onRequestFailure;
    var prehidingStyle = config.prehidingStyle;

    if (personalizationDetails.isRenderDecisions()) {
      hideContainers(prehidingStyle);
    }

    mergeQuery(event, personalizationDetails.createQueryDetails());
    onResponse(function (_ref56) {
      var response = _ref56.response;
      return responseHandler({
        decisionsDeferred: decisionsDeferred,
        personalizationDetails: personalizationDetails,
        response: response
      });
    });
    onRequestFailure(function () {
      decisionsDeferred.reject();
      showContainers();
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var matchesSelectorWithEq = function matchesSelectorWithEq(selector, element) {
  if (isNotEqSelector(selector)) {
    return matchesSelector(selector, element);
  } // Using node selection vs matches selector, because of :eq()
  // Find all nodes using document as context


  var nodes = selectNodesWithEq(selector);
  var result = false; // Iterate through all the identified elements
  // and reference compare with element

  for (var _i8 = 0; _i8 < nodes.length; _i8 += 1) {
    if (nodes[_i8] === element) {
      result = true;
      break;
    }
  }

  return result;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getMetasIfMatches = function getMetasIfMatches(clickedElement, selector, getClickMetasBySelector) {
  var _document = document,
      documentElement = _document.documentElement;
  var element = clickedElement;

  while (element && element !== documentElement) {
    if (matchesSelectorWithEq(selector, element)) {
      return getClickMetasBySelector(selector);
    }

    element = element.parentNode;
  }

  return null;
};

var collectClicks = function collectClicks(clickedElement, selectors, getClickMetasBySelector) {
  var result = [];

  for (var _i9 = 0; _i9 < selectors.length; _i9 += 1) {
    var metas = getMetasIfMatches(clickedElement, selectors[_i9], getClickMetasBySelector);

    if (metas) {
      result.push.apply(result, _toConsumableArray(metas));
    }
  }

  return result;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var isAuthoringModeEnabled = function isAuthoringModeEnabled() {
  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  return doc.location.href.indexOf("adobe_authoring_enabled") !== -1;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var mergeDecisionsMeta = function mergeDecisionsMeta(event, decisionsMeta) {
  event.mergeXdm({
    _experience: {
      decisioning: {
        propositions: decisionsMeta
      }
    }
  });
};

var mergeQuery = function mergeQuery(event, details) {
  event.mergeQuery({
    personalization: _objectSpread({}, details)
  });
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createOnClickHandler = function createOnClickHandler(_ref57) {
  var mergeDecisionsMeta = _ref57.mergeDecisionsMeta,
      collectClicks = _ref57.collectClicks,
      getClickSelectors = _ref57.getClickSelectors,
      getClickMetasBySelector = _ref57.getClickMetasBySelector;
  // Called when an element qualifying for conversion within an offer is clicked.
  return function (_ref58) {
    var event = _ref58.event,
        clickedElement = _ref58.clickedElement;
    var selectors = getClickSelectors();

    if (isNonEmptyArray(selectors)) {
      var decisionsMeta = collectClicks(clickedElement, selectors, getClickMetasBySelector);

      if (isNonEmptyArray(decisionsMeta)) {
        event.mergeXdm({
          eventType: "click"
        });
        mergeDecisionsMeta(event, decisionsMeta);
      }
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createExecuteCachedViewDecisions = function createExecuteCachedViewDecisions(_ref59) {
  var executeViewDecisions = _ref59.executeViewDecisions,
      collect = _ref59.collect;
  return function (_ref60) {
    var viewName = _ref60.viewName,
        viewDecisions = _ref60.viewDecisions;

    // if there are viewDecisions for current view we will execute them and then send the collect call
    if (isNonEmptyArray(viewDecisions)) {
      executeViewDecisions(viewDecisions);
      return; // return here is to avoid the following code to be executed, that one is meant for the condition when viewDecisions is empty
    } // if there are no viewDecisions for current view we will send a collect call


    var xdm = {
      web: {
        webPageDetails: {
          viewName: viewName
        }
      }
    }; // This collect function is not from createCollect. It's the function from createViewCollect.

    collect({
      decisionsMeta: [],
      xdm: xdm
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createViewCacheManager = function createViewCacheManager() {
  var viewStorage;
  var viewStorageDeferred = defer();

  var storeViews = function storeViews(decisionsPromise) {
    decisionsPromise.then(function (decisions) {
      if (viewStorage === undefined) {
        viewStorage = {};
      }

      (0, _reactorObjectAssign["default"])(viewStorage, decisions);
      viewStorageDeferred.resolve();
    })["catch"](function () {
      if (viewStorage === undefined) {
        viewStorage = {};
      }

      viewStorageDeferred.resolve();
    });
  };

  var getView = function getView(viewName) {
    return viewStorageDeferred.promise.then(function () {
      return viewStorage[viewName] || [];
    });
  };

  var isInitialized = function isInitialized() {
    return !(viewStorage === undefined);
  };

  return {
    storeViews: storeViews,
    getView: getView,
    isInitialized: isInitialized
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var addRenderAttemptedToDecisions = function addRenderAttemptedToDecisions(_ref61) {
  var decisions = _ref61.decisions,
      renderAttempted = _ref61.renderAttempted;
  return decisions.map(function (decision) {
    return (0, _reactorObjectAssign["default"])({
      renderAttempted: renderAttempted
    }, decision);
  });
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createViewChangeHandler = function createViewChangeHandler(_ref62) {
  var executeCachedViewDecisions = _ref62.executeCachedViewDecisions,
      viewCache = _ref62.viewCache,
      showContainers = _ref62.showContainers;
  return function (_ref63) {
    var personalizationDetails = _ref63.personalizationDetails,
        onResponse = _ref63.onResponse,
        onRequestFailure = _ref63.onRequestFailure;
    var viewName = personalizationDetails.getViewName();
    return viewCache.getView(viewName).then(function (currentViewDecisions) {
      if (personalizationDetails.isRenderDecisions()) {
        executeCachedViewDecisions({
          viewName: viewName,
          viewDecisions: currentViewDecisions
        });
      }

      onResponse(function () {
        return personalizationDetails.isRenderDecisions() ? {
          propositions: addRenderAttemptedToDecisions({
            decisions: currentViewDecisions,
            renderAttempted: true
          })
        } : {
          decisions: currentViewDecisions,
          propositions: addRenderAttemptedToDecisions({
            decisions: currentViewDecisions,
            renderAttempted: false
          })
        };
      });
      onRequestFailure(function () {
        showContainers();
      });
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var splitItems = function splitItems(items, schema) {
  var matched = [];
  var nonMatched = [];
  items.forEach(function (item) {
    if (item.schema === schema) {
      matched.push(item);
    } else {
      nonMatched.push(item);
    }
  });
  return [matched, nonMatched];
};

var createDecision = function createDecision(decision, items) {
  return {
    id: decision.id,
    scope: decision.scope,
    items: items,
    scopeDetails: decision.scopeDetails
  };
};

var splitDecisions = function splitDecisions(decisions, schema) {
  var matchedDecisions = [];
  var unmatchedDecisions = [];
  decisions.forEach(function (decision) {
    var _decision$items = decision.items,
        items = _decision$items === void 0 ? [] : _decision$items;

    var _splitItems = splitItems(items, schema),
        _splitItems2 = _slicedToArray(_splitItems, 2),
        matchedItems = _splitItems2[0],
        nonMatchedItems = _splitItems2[1];

    if (isNonEmptyArray(matchedItems)) {
      matchedDecisions.push(createDecision(decision, matchedItems));
    }

    if (isNonEmptyArray(nonMatchedItems)) {
      unmatchedDecisions.push(createDecision(decision, nonMatchedItems));
    }
  });
  return {
    matchedDecisions: matchedDecisions,
    unmatchedDecisions: unmatchedDecisions
  };
};

var extractDecisionsByScope = function extractDecisionsByScope(decisions, scope) {
  var pageWideScopeDecisions = [];
  var nonPageWideScopeDecisions = {};

  if (isNonEmptyArray(decisions)) {
    decisions.forEach(function (decision) {
      if (decision.scope === scope) {
        pageWideScopeDecisions.push(decision);
      } else {
        if (!nonPageWideScopeDecisions[decision.scope]) {
          nonPageWideScopeDecisions[decision.scope] = [];
        }

        nonPageWideScopeDecisions[decision.scope].push(decision);
      }
    });
  }

  return {
    pageWideScopeDecisions: pageWideScopeDecisions,
    nonPageWideScopeDecisions: nonPageWideScopeDecisions
  };
};

var groupDecisions = function groupDecisions(unprocessedDecisions) {
  var decisionsGroupedByRedirectItemSchema = splitDecisions(unprocessedDecisions, REDIRECT_ITEM);
  var decisionsGroupedByDomActionSchema = splitDecisions(decisionsGroupedByRedirectItemSchema.unmatchedDecisions, DOM_ACTION);

  var _extractDecisionsBySc = extractDecisionsByScope(decisionsGroupedByDomActionSchema.matchedDecisions, PAGE_WIDE_SCOPE),
      pageWideScopeDecisions = _extractDecisionsBySc.pageWideScopeDecisions,
      nonPageWideScopeDecisions = _extractDecisionsBySc.nonPageWideScopeDecisions;

  return {
    redirectDecisions: decisionsGroupedByRedirectItemSchema.matchedDecisions,
    pageWideScopeDecisions: pageWideScopeDecisions,
    viewDecisions: nonPageWideScopeDecisions,
    nonAutoRenderableDecisions: decisionsGroupedByDomActionSchema.unmatchedDecisions
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var DECISIONS_HANDLE = "personalization:decisions";

var createOnResponseHandler = function createOnResponseHandler(_ref64) {
  var autoRenderingHandler = _ref64.autoRenderingHandler,
      nonRenderingHandler = _ref64.nonRenderingHandler,
      groupDecisions = _ref64.groupDecisions,
      handleRedirectDecisions = _ref64.handleRedirectDecisions,
      showContainers = _ref64.showContainers;
  return function (_ref65) {
    var decisionsDeferred = _ref65.decisionsDeferred,
        personalizationDetails = _ref65.personalizationDetails,
        response = _ref65.response;
    var unprocessedDecisions = response.getPayloadsByType(DECISIONS_HANDLE);
    var viewName = personalizationDetails.getViewName(); // if personalization payload is empty return empty decisions array

    if (unprocessedDecisions.length === 0) {
      showContainers();
      decisionsDeferred.resolve({});
      return {
        decisions: [],
        propositions: []
      };
    }

    var _groupDecisions = groupDecisions(unprocessedDecisions),
        redirectDecisions = _groupDecisions.redirectDecisions,
        pageWideScopeDecisions = _groupDecisions.pageWideScopeDecisions,
        viewDecisions = _groupDecisions.viewDecisions,
        nonAutoRenderableDecisions = _groupDecisions.nonAutoRenderableDecisions;

    if (personalizationDetails.isRenderDecisions() && isNonEmptyArray(redirectDecisions)) {
      decisionsDeferred.resolve({});
      return handleRedirectDecisions(redirectDecisions);
    } // save decisions for views in local cache


    decisionsDeferred.resolve(viewDecisions);

    if (personalizationDetails.isRenderDecisions()) {
      return autoRenderingHandler({
        viewName: viewName,
        pageWideScopeDecisions: pageWideScopeDecisions,
        nonAutoRenderableDecisions: nonAutoRenderableDecisions
      });
    }

    return nonRenderingHandler({
      viewName: viewName,
      redirectDecisions: redirectDecisions,
      pageWideScopeDecisions: pageWideScopeDecisions,
      nonAutoRenderableDecisions: nonAutoRenderableDecisions
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var metasToArray = function metasToArray(metas) {
  return Object.keys(metas).map(function (key) {
    return {
      id: key,
      scope: metas[key].scope,
      scopeDetails: metas[key].scopeDetails
    };
  });
};

var createClickStorage = function createClickStorage() {
  var clickStorage = {};

  var storeClickMetrics = function storeClickMetrics(value) {
    if (!clickStorage[value.selector]) {
      clickStorage[value.selector] = {};
    }

    clickStorage[value.selector][value.meta.id] = {
      scope: value.meta.scope,
      scopeDetails: value.meta.scopeDetails
    };
  };

  var getClickSelectors = function getClickSelectors() {
    return Object.keys(clickStorage);
  };

  var getClickMetasBySelector = function getClickMetasBySelector(selector) {
    var metas = clickStorage[selector];

    if (!metas) {
      return {};
    }

    return metasToArray(clickStorage[selector]);
  };

  return {
    storeClickMetrics: storeClickMetrics,
    getClickSelectors: getClickSelectors,
    getClickMetasBySelector: getClickMetasBySelector
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getRedirectDetails = function getRedirectDetails(redirectDecisions) {
  var decision = redirectDecisions[0];
  var items = decision.items,
      id = decision.id,
      scope = decision.scope,
      scopeDetails = decision.scopeDetails;
  var content = items[0].data.content;
  return {
    content: content,
    decisions: [{
      id: id,
      scope: scope,
      scopeDetails: scopeDetails
    }]
  };
};

var createRedirectHandler = function createRedirectHandler(_ref66) {
  var collect = _ref66.collect,
      window = _ref66.window,
      logger = _ref66.logger,
      showContainers = _ref66.showContainers;
  return function (redirectDecisions) {
    var _getRedirectDetails = getRedirectDetails(redirectDecisions),
        content = _getRedirectDetails.content,
        decisions = _getRedirectDetails.decisions;

    var documentMayUnload = true;
    return collect({
      decisionsMeta: decisions,
      documentMayUnload: documentMayUnload
    }).then(function () {
      window.location.replace(content);
    })["catch"](function () {
      showContainers();
      logger.warn(REDIRECT_EXECUTION_ERROR);
    });
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createAutorenderingHandler = function createAutorenderingHandler(_ref67) {
  var viewCache = _ref67.viewCache,
      executeDecisions = _ref67.executeDecisions,
      executeCachedViewDecisions = _ref67.executeCachedViewDecisions,
      showContainers = _ref67.showContainers;
  return function (_ref68) {
    var viewName = _ref68.viewName,
        pageWideScopeDecisions = _ref68.pageWideScopeDecisions,
        nonAutoRenderableDecisions = _ref68.nonAutoRenderableDecisions;

    if (viewName) {
      return viewCache.getView(viewName).then(function (currentViewDecisions) {
        executeDecisions(pageWideScopeDecisions);
        executeCachedViewDecisions({
          viewName: viewName,
          viewDecisions: currentViewDecisions
        });
        showContainers();
        return {
          decisions: _toConsumableArray(nonAutoRenderableDecisions),
          propositions: [].concat(_toConsumableArray(addRenderAttemptedToDecisions({
            decisions: [].concat(_toConsumableArray(pageWideScopeDecisions), _toConsumableArray(currentViewDecisions)),
            renderAttempted: true
          })), _toConsumableArray(addRenderAttemptedToDecisions({
            decisions: nonAutoRenderableDecisions,
            renderAttempted: false
          })))
        };
      });
    }

    executeDecisions(pageWideScopeDecisions);
    showContainers();
    return {
      decisions: _toConsumableArray(nonAutoRenderableDecisions),
      propositions: [].concat(_toConsumableArray(addRenderAttemptedToDecisions({
        decisions: pageWideScopeDecisions,
        renderAttempted: true
      })), _toConsumableArray(addRenderAttemptedToDecisions({
        decisions: nonAutoRenderableDecisions,
        renderAttempted: false
      })))
    };
  };
};
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getViewPropositions = function getViewPropositions(_ref69) {
  var viewCache = _ref69.viewCache,
      viewName = _ref69.viewName,
      propositions = _ref69.propositions;

  if (!viewName) {
    return propositions;
  }

  return viewCache.getView(viewName).then(function (viewPropositions) {
    return [].concat(_toConsumableArray(viewPropositions), _toConsumableArray(propositions));
  });
};

var buildFinalResult = function buildFinalResult(_ref70) {
  var propositions = _ref70.propositions;
  return {
    decisions: propositions,
    propositions: addRenderAttemptedToDecisions({
      decisions: propositions,
      renderAttempted: false
    })
  };
};

var createNonRenderingHandler = function createNonRenderingHandler(_ref71) {
  var viewCache = _ref71.viewCache;
  return function (_ref72) {
    var viewName = _ref72.viewName,
        redirectDecisions = _ref72.redirectDecisions,
        pageWideScopeDecisions = _ref72.pageWideScopeDecisions,
        nonAutoRenderableDecisions = _ref72.nonAutoRenderableDecisions;
    var propositions = [].concat(_toConsumableArray(redirectDecisions), _toConsumableArray(pageWideScopeDecisions), _toConsumableArray(nonAutoRenderableDecisions));
    return Promise.resolve(propositions).then(function (items) {
      return getViewPropositions({
        viewCache: viewCache,
        viewName: viewName,
        propositions: items
      });
    }).then(function (items) {
      return buildFinalResult({
        propositions: items
      });
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createPersonalization = function createPersonalization(_ref73) {
  var config = _ref73.config,
      logger = _ref73.logger,
      eventManager = _ref73.eventManager;
  var collect = createCollect({
    eventManager: eventManager,
    mergeDecisionsMeta: mergeDecisionsMeta
  });
  var viewCollect = createViewCollect({
    eventManager: eventManager,
    mergeDecisionsMeta: mergeDecisionsMeta
  });

  var _createClickStorage = createClickStorage(),
      getClickMetasBySelector = _createClickStorage.getClickMetasBySelector,
      getClickSelectors = _createClickStorage.getClickSelectors,
      storeClickMetrics = _createClickStorage.storeClickMetrics;

  var viewCache = createViewCacheManager();
  var modules = initDomActionsModules(storeClickMetrics);
  var executeDecisions = createExecuteDecisions({
    modules: modules,
    logger: logger,
    executeActions: executeActions,
    collect: collect
  });
  var executeViewDecisions = createExecuteDecisions({
    modules: modules,
    logger: logger,
    executeActions: executeActions,
    collect: viewCollect
  });
  var handleRedirectDecisions = createRedirectHandler({
    collect: collect,
    window: window,
    logger: logger,
    showContainers: showContainers
  });
  var executeCachedViewDecisions = createExecuteCachedViewDecisions({
    viewCache: viewCache,
    executeViewDecisions: executeViewDecisions,
    collect: viewCollect
  });
  var autoRenderingHandler = createAutorenderingHandler({
    viewCache: viewCache,
    executeDecisions: executeDecisions,
    executeCachedViewDecisions: executeCachedViewDecisions,
    showContainers: showContainers
  });
  var nonRenderingHandler = createNonRenderingHandler({
    viewCache: viewCache
  });
  var responseHandler = createOnResponseHandler({
    autoRenderingHandler: autoRenderingHandler,
    nonRenderingHandler: nonRenderingHandler,
    groupDecisions: groupDecisions,
    handleRedirectDecisions: handleRedirectDecisions,
    showContainers: showContainers
  });
  var fetchDataHandler = createFetchDataHandler({
    config: config,
    responseHandler: responseHandler,
    showContainers: showContainers,
    hideContainers: hideContainers,
    mergeQuery: mergeQuery
  });
  var onClickHandler = createOnClickHandler({
    mergeDecisionsMeta: mergeDecisionsMeta,
    collectClicks: collectClicks,
    getClickSelectors: getClickSelectors,
    getClickMetasBySelector: getClickMetasBySelector
  });
  var viewChangeHandler = createViewChangeHandler({
    executeCachedViewDecisions: executeCachedViewDecisions,
    viewCache: viewCache,
    showContainers: showContainers
  });
  return createComponent$1({
    logger: logger,
    fetchDataHandler: fetchDataHandler,
    viewChangeHandler: viewChangeHandler,
    onClickHandler: onClickHandler,
    isAuthoringModeEnabled: isAuthoringModeEnabled,
    mergeQuery: mergeQuery,
    viewCache: viewCache
  });
};

createPersonalization.namespace = "Personalization";
createPersonalization.configValidators = {
  prehidingStyle: boundString().nonEmpty()
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var injectWeb = function injectWeb(window) {
  return function (xdm) {
    var web = {
      webPageDetails: {
        URL: window.location.href || window.location
      },
      webReferrer: {
        URL: window.document.referrer
      }
    };
    deepAssign(xdm, {
      web: web
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var getScreenOrientationViaProperty = function getScreenOrientationViaProperty(window) {
  var orientation = window.screen.orientation;

  if (orientation == null || orientation.type == null) {
    return null;
  }

  var parts = orientation.type.split("-");

  if (parts.length === 0) {
    return null;
  }

  if (parts[0] !== "portrait" && parts[0] !== "landscape") {
    return null;
  }

  return parts[0];
};

var getScreenOrientationViaMediaQuery = function getScreenOrientationViaMediaQuery(window) {
  if (window.matchMedia("(orientation: portrait)").matches) {
    return "portrait";
  }

  if (window.matchMedia("(orientation: landscape)").matches) {
    return "landscape";
  }

  return null;
};

var injectDevice = function injectDevice(window) {
  return function (xdm) {
    var _window$screen = window.screen,
        width = _window$screen.width,
        height = _window$screen.height;
    var device = {
      screenHeight: height,
      screenWidth: width
    };
    var orientation = getScreenOrientationViaProperty(window) || getScreenOrientationViaMediaQuery(window);

    if (orientation) {
      device.screenOrientation = orientation;
    }

    deepAssign(xdm, {
      device: device
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectEnvironment = function injectEnvironment(window) {
  return function (xdm) {
    var _window$document$docu = window.document.documentElement;
    _window$document$docu = _window$document$docu === void 0 ? {} : _window$document$docu;
    var clientWidth = _window$document$docu.clientWidth,
        clientHeight = _window$document$docu.clientHeight;
    var environment = {
      type: "browser"
    };

    if (isNumber(clientWidth) && clientWidth >= 0 && isNumber(clientHeight) && clientHeight >= 0) {
      environment.browserDetails = {
        viewportWidth: Math.round(clientWidth),
        viewportHeight: Math.round(clientHeight)
      };
    }

    deepAssign(xdm, {
      environment: environment
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectPlaceContext = function injectPlaceContext(dateProvider) {
  return function (xdm) {
    var date = dateProvider();
    var placeContext = {
      localTime: toISOStringLocal(date),
      localTimezoneOffset: date.getTimezoneOffset()
    };
    deepAssign(xdm, {
      placeContext: placeContext
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectTimestamp = function injectTimestamp(dateProvider) {
  return function (xdm) {
    var timestamp = dateProvider().toISOString();
    deepAssign(xdm, {
      timestamp: timestamp
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var libraryName = "https://ns.adobe.com/experience/alloy";
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// The __VERSION__ keyword will be replace at alloy build time with the package.json version.
// see babel-plugin-version

var libraryVersion = "2.6.4";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var implementationDetails = function implementationDetails(xdm) {
  var implementationDetails = {
    name: libraryName,
    version: libraryVersion,
    environment: "browser"
  };
  deepAssign(xdm, {
    implementationDetails: implementationDetails
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createComponent$2 = function createComponent$2(config, logger, availableContexts, requiredContexts) {
  var configuredContexts = config.context;
  var contexts = flatMap(configuredContexts, function (context, i) {
    if (availableContexts[context]) {
      return [availableContexts[context]];
    }

    logger.warn("Invalid context[".concat(i, "]: '").concat(context, "' is not available."));
    return [];
  }).concat(requiredContexts);
  return {
    namespace: "Context",
    lifecycle: {
      onBeforeEvent: function onBeforeEvent(_ref74) {
        var event = _ref74.event;
        var xdm = {};
        contexts.forEach(function (context) {
          return context(xdm);
        });
        event.mergeXdm(xdm);
      }
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var web = injectWeb(window);
var device = injectDevice(window);
var environment = injectEnvironment(window);
var placeContext = injectPlaceContext(function () {
  return new Date();
});
var timestamp = injectTimestamp(function () {
  return new Date();
});
var optionalContexts = {
  web: web,
  device: device,
  environment: environment,
  placeContext: placeContext
};
var requiredContexts = [timestamp, implementationDetails];

var createContext = function createContext(_ref75) {
  var config = _ref75.config,
      logger = _ref75.logger;
  return createComponent$2(config, logger, optionalContexts, requiredContexts);
};

createContext.namespace = "Context";
createContext.configValidators = {
  context: boundArrayOf(boundString())["default"](Object.keys(optionalContexts))
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createComponent$3 = function createComponent$3(_ref76) {
  var storedConsent = _ref76.storedConsent,
      taskQueue = _ref76.taskQueue,
      defaultConsent = _ref76.defaultConsent,
      consent = _ref76.consent,
      sendSetConsentRequest = _ref76.sendSetConsentRequest,
      validateSetConsentOptions = _ref76.validateSetConsentOptions,
      consentHashStore = _ref76.consentHashStore,
      doesIdentityCookieExist = _ref76.doesIdentityCookieExist;

  var defaultConsentByPurpose = _defineProperty({}, GENERAL, defaultConsent);

  var storedConsentByPurpose = storedConsent.read();
  var identityCookieExists = doesIdentityCookieExist();
  var consentCookieExists = storedConsentByPurpose[GENERAL] !== undefined;

  if (!identityCookieExists || !consentCookieExists) {
    consentHashStore.clear();
  } // If the identity cookie is gone, remove the consent cookie because the
  // consent info is tied to the identity.


  if (!identityCookieExists) {
    storedConsent.clear();
    storedConsentByPurpose = {};
  }

  consent.initializeConsent(defaultConsentByPurpose, storedConsentByPurpose);

  var readCookieIfQueueEmpty = function readCookieIfQueueEmpty() {
    if (taskQueue.length === 0) {
      var storedConsentObject = storedConsent.read(); // Only read cookies when there are no outstanding setConsent
      // requests. This helps with race conditions.

      if (storedConsentObject[GENERAL] !== undefined) {
        consent.setConsent(storedConsentObject);
      }
    }
  };

  return {
    commands: {
      setConsent: {
        optionsValidator: validateSetConsentOptions,
        run: function run(_ref77) {
          var consentOptions = _ref77.consent,
              identityMap = _ref77.identityMap;
          consent.suspend();
          var consentHashes = consentHashStore.lookup(consentOptions);
          return taskQueue.addTask(function () {
            if (consentHashes.isNew()) {
              return sendSetConsentRequest({
                consentOptions: consentOptions,
                identityMap: identityMap
              });
            }

            return Promise.resolve();
          }).then(function () {
            return consentHashes.save();
          })["finally"](readCookieIfQueueEmpty);
        }
      }
    },
    lifecycle: {
      // Read the cookie here too because the consent cookie may change on any request
      onResponse: readCookieIfQueueEmpty,
      // Even when we get a failure HTTP status code, the consent cookie can
      // still get updated. This could happen, for example, if the user is
      // opted out in AudienceManager, but no consent cookie exists on the
      // client. The request will be sent and the server will respond with a
      // 403 Forbidden and a consent cookie.
      onRequestFailure: readCookieIfQueueEmpty
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var serialize = function serialize(obj) {
  if (Array.isArray(obj)) {
    return obj.map(function (i) {
      return serialize(i);
    });
  }

  if (_typeof(obj) === "object" && obj !== null) {
    return Object.keys(obj).sort().reduce(function (memo, key) {
      memo[key] = serialize(obj[key]);
      return memo;
    }, {});
  }

  return obj;
};

var computeConsentHash = function computeConsentHash(obj) {
  return crc32(JSON.stringify(serialize(obj)));
};

var getKey = function getKey(_ref78) {
  var standard = _ref78.standard,
      version = _ref78.version;
  return "".concat(standard, ".").concat(version);
};

var createConsentHashStore = function createConsentHashStore(_ref79) {
  var storage = _ref79.storage;
  return {
    clear: function clear() {
      storage.clear();
    },
    lookup: function lookup(consentObjects) {
      var currentHashes = {};

      var getCurrentHash = function getCurrentHash(consentObject) {
        var key = getKey(consentObject);

        var standard = consentObject.standard,
            version = consentObject.version,
            rest = _objectWithoutProperties(consentObject, ["standard", "version"]);

        if (!currentHashes[key]) {
          currentHashes[key] = computeConsentHash(rest).toString();
        }

        return currentHashes[key];
      };

      return {
        isNew: function isNew() {
          return consentObjects.some(function (consentObject) {
            var key = getKey(consentObject);
            var previousHash = storage.getItem(key);
            return previousHash === null || previousHash !== getCurrentHash(consentObject);
          });
        },
        save: function save() {
          consentObjects.forEach(function (consentObject) {
            var key = getKey(consentObject);
            storage.setItem(key, getCurrentHash(consentObject));
          });
        }
      };
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createConsentRequestPayload = function createConsentRequestPayload() {
  var content = {};
  var payload = createRequestPayload({
    content: content,
    addIdentity: function addIdentity(namespaceCode, identity) {
      content.identityMap = content.identityMap || {};
      content.identityMap[namespaceCode] = content.identityMap[namespaceCode] || [];
      content.identityMap[namespaceCode].push(identity);
    }
  });

  payload.setConsent = function (consent) {
    content.consent = consent;
  };

  return payload;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createConsentRequest = function createConsentRequest(consentRequestPayload) {
  return createRequest({
    payload: consentRequestPayload,
    getAction: function getAction() {
      return "privacy/set-consent";
    },
    getUseSendBeacon: function getUseSendBeacon() {
      return false;
    }
  });
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createStoredConsent = function createStoredConsent(_ref80) {
  var parseConsentCookie = _ref80.parseConsentCookie,
      orgId = _ref80.orgId,
      cookieJar = _ref80.cookieJar;
  var consentCookieName = getNamespacedCookieName(orgId, CONSENT);
  return {
    read: function read() {
      var cookieValue = cookieJar.get(consentCookieName);
      return cookieValue ? parseConsentCookie(cookieValue) : {};
    },
    clear: function clear() {
      cookieJar.remove(consentCookieName);
    }
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectSendSetConsentRequest = function injectSendSetConsentRequest(_ref81) {
  var createConsentRequestPayload = _ref81.createConsentRequestPayload,
      createConsentRequest = _ref81.createConsentRequest,
      sendEdgeNetworkRequest = _ref81.sendEdgeNetworkRequest;
  return function (_ref82) {
    var consentOptions = _ref82.consentOptions,
        identityMap = _ref82.identityMap;
    var payload = createConsentRequestPayload();
    payload.setConsent(consentOptions);

    if (isObject(identityMap)) {
      Object.keys(identityMap).forEach(function (key) {
        identityMap[key].forEach(function (identity) {
          payload.addIdentity(key, identity);
        });
      });
    }

    var request = createConsentRequest(payload);
    return sendEdgeNetworkRequest({
      request: request
    }).then(function () {// Don't let response data disseminate beyond this
      // point unless necessary.
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * Parses a consent cookie.
 * @param {string} cookieValue Must be in the format a=b;c=d
 * @returns {Object} An object where the keys are purpose names and the values
 * are the consent status for the purpose.
 */


var parseConsentCookie = function parseConsentCookie(cookieValue) {
  var categoryPairs = cookieValue.split(";");
  return categoryPairs.reduce(function (consentByPurpose, categoryPair) {
    var _categoryPair$split = categoryPair.split("="),
        _categoryPair$split2 = _slicedToArray(_categoryPair$split, 2),
        name = _categoryPair$split2[0],
        value = _categoryPair$split2[1];

    consentByPurpose[name] = value;
    return consentByPurpose;
  }, {});
};

var validateSetConsentOptions = boundObjectOf({
  consent: boundArrayOf(boundAnything()).required().nonEmpty(),
  identityMap: validateIdentityMap
}).noUnknownFields().required();
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createPrivacy = function createPrivacy(_ref83) {
  var config = _ref83.config,
      consent = _ref83.consent,
      sendEdgeNetworkRequest = _ref83.sendEdgeNetworkRequest,
      createNamespacedStorage = _ref83.createNamespacedStorage;
  var orgId = config.orgId,
      defaultConsent = config.defaultConsent;
  var storedConsent = createStoredConsent({
    parseConsentCookie: parseConsentCookie,
    orgId: orgId,
    cookieJar: _reactorCookie["default"]
  });
  var taskQueue = createTaskQueue();
  var sendSetConsentRequest = injectSendSetConsentRequest({
    createConsentRequestPayload: createConsentRequestPayload,
    createConsentRequest: createConsentRequest,
    sendEdgeNetworkRequest: sendEdgeNetworkRequest
  });
  var storage = createNamespacedStorage("".concat(sanitizeOrgIdForCookieName(orgId), ".consentHashes."));
  var consentHashStore = createConsentHashStore({
    storage: storage.persistent
  });
  var doesIdentityCookieExist = injectDoesIdentityCookieExist({
    orgId: orgId
  });
  return createComponent$3({
    storedConsent: storedConsent,
    taskQueue: taskQueue,
    defaultConsent: defaultConsent,
    consent: consent,
    sendSetConsentRequest: sendSetConsentRequest,
    validateSetConsentOptions: validateSetConsentOptions,
    consentHashStore: consentHashStore,
    doesIdentityCookieExist: doesIdentityCookieExist
  });
};

createPrivacy.namespace = "Privacy";
/*
Copyright 20219 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createEventMergeId = function createEventMergeId() {
  return {
    eventMergeId: v4_1()
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


exports.createEventMergeId = createEventMergeId;

var createComponent$4 = function createComponent$4(_ref84) {
  var createEventMergeId = _ref84.createEventMergeId;
  return {
    commands: {
      createEventMergeId: {
        run: createEventMergeId
      }
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createEventMerge = function createEventMerge() {
  return createComponent$4({
    createEventMergeId: createEventMergeId
  });
};

createEventMerge.namespace = "EventMerge";
createEventMerge.configValidators = {};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createLibraryInfo = function createLibraryInfo() {
  return {
    commands: {
      getLibraryInfo: {
        run: function run() {
          return {
            libraryInfo: {
              version: libraryVersion
            }
          };
        }
      }
    }
  };
};

createLibraryInfo.namespace = "LibraryInfo";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// TODO: Figure out how sub-components will be made available/registered

var componentCreators = [createDataCollector, createActivityCollector, createIdentity, createAudiences, createPersonalization, createContext, createPrivacy, createEventMerge, createLibraryInfo];
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var CONFIG_DOC_URI = "https://adobe.ly/2M4ErNE";

var buildSchema = function buildSchema(coreConfigValidators, componentCreators) {
  var schema = {};
  (0, _reactorObjectAssign["default"])(schema, coreConfigValidators);
  componentCreators.forEach(function (createComponent) {
    var configValidators = createComponent.configValidators;
    (0, _reactorObjectAssign["default"])(schema, configValidators);
  });
  return schema;
};

var transformOptions = function transformOptions(schema, options) {
  try {
    var validator = boundObjectOf(schema).noUnknownFields().required();
    return validator(options);
  } catch (e) {
    throw new Error("Resolve these configuration problems:\n\t - ".concat(e.message.split("\n").join("\n\t - "), "\nFor configuration documentation see: ").concat(CONFIG_DOC_URI));
  }
};

var buildAndValidateConfig = function buildAndValidateConfig(_ref85) {
  var options = _ref85.options,
      componentCreators = _ref85.componentCreators,
      coreConfigValidators = _ref85.coreConfigValidators,
      createConfig = _ref85.createConfig,
      logger = _ref85.logger,
      setDebugEnabled = _ref85.setDebugEnabled;
  var schema = buildSchema(coreConfigValidators, componentCreators);
  var config = createConfig(transformOptions(schema, options));
  setDebugEnabled(config.debugEnabled, {
    fromConfig: true
  });
  logger.logOnInstanceConfigured({
    config: config
  });
  return config;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var initializeComponents = function initializeComponents(_ref86) {
  var componentCreators = _ref86.componentCreators,
      lifecycle = _ref86.lifecycle,
      componentRegistry = _ref86.componentRegistry,
      getImmediatelyAvailableTools = _ref86.getImmediatelyAvailableTools;
  componentCreators.forEach(function (createComponent) {
    var namespace = createComponent.namespace; // TO-DOCUMENT: Helpers that we inject into factories.

    var tools = getImmediatelyAvailableTools(namespace);
    var component;

    try {
      component = createComponent(tools);
    } catch (error) {
      throw stackError({
        error: error,
        message: "[".concat(namespace, "] An error occurred during component creation.")
      });
    }

    componentRegistry.register(namespace, component);
  });
  return lifecycle.onComponentsRegistered({
    lifecycle: lifecycle
  }).then(function () {
    return componentRegistry;
  });
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createConfig = function createConfig(options) {
  return (0, _reactorObjectAssign["default"])({}, options);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var EDGE$1 = "edge.adobedc.net";
var ID_THIRD_PARTY = "adobedc.demdex.net";
var EDGE_BASE_PATH = "ee";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var createCoreConfigs = function createCoreConfigs() {
  return {
    debugEnabled: boundBoolean()["default"](false),
    defaultConsent: boundEnumOf(IN, OUT, PENDING)["default"](IN),
    edgeConfigId: boundString().unique().required(),
    edgeDomain: boundString().domain()["default"](EDGE$1),
    edgeBasePath: boundString().nonEmpty()["default"](EDGE_BASE_PATH),
    orgId: boundString().unique().required(),
    onBeforeEventSend: boundCallback()["default"](noop)
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectHandleError = function injectHandleError(_ref87) {
  var errorPrefix = _ref87.errorPrefix,
      logger = _ref87.logger;
  return function (error, operation) {
    var err = toError(error); // In the case of declined consent, we've opted to not reject the promise
    // returned to the customer, but instead resolve the promise with an
    // empty result object.

    if (err.code === DECLINED_CONSENT_ERROR_CODE) {
      logger.warn("The ".concat(operation, " could not fully complete. ").concat(err.message));
      return {};
    }

    updateErrorMessage({
      error: err,
      message: "".concat(errorPrefix, " ").concat(err.message)
    });
    throw err;
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectSendFetchRequest = function injectSendFetchRequest(_ref88) {
  var fetch = _ref88.fetch;
  return function (url, body) {
    return fetch(url, {
      method: "POST",
      cache: "no-cache",
      credentials: "include",
      // To set the cookie header in the request.
      headers: {
        "Content-Type": "text/plain; charset=UTF-8"
      },
      referrer: "client",
      body: body
    }).then(function (response) {
      return response.text().then(function (responseBody) {
        return {
          statusCode: response.status,
          // We expose headers through a function instead of creating an object
          // with all the headers up front largely because the native
          // request.getResponseHeader method is case-insensitive but also because it prevents
          // us from having to add header parsing logic when using XHR to make requests.
          getHeader: function getHeader(name) {
            return response.headers.get(name);
          },
          body: responseBody
        };
      });
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectSendXhrRequest = function injectSendXhrRequest(_ref89) {
  var XMLHttpRequest = _ref89.XMLHttpRequest;
  return function (url, body) {
    return new Promise(function (resolve, reject) {
      var request = new XMLHttpRequest();

      request.onreadystatechange = function () {
        if (request.readyState === 4) {
          if (request.status === 0) {
            reject(new Error("Request aborted."));
          } else {
            resolve({
              statusCode: request.status,
              // We expose headers through a function instead of creating an object
              // with all the headers up front because:
              // 1. It avoids having to add header parsing code to get all headers.
              // 2. The native request.getResponseHeader method is case-insensitive.
              getHeader: function getHeader(name) {
                return request.getResponseHeader(name);
              },
              body: request.responseText
            });
          }
        }
      };

      request.onloadstart = function () {
        request.responseType = "text";
      };

      request.open("POST", url, true);
      request.setRequestHeader("Content-Type", "text/plain; charset=UTF-8");
      request.withCredentials = true;
      request.onerror = reject;
      request.onabort = reject;
      request.send(body);
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var injectSendBeaconRequest = function injectSendBeaconRequest(_ref90) {
  var sendBeacon = _ref90.sendBeacon,
      sendFetchRequest = _ref90.sendFetchRequest,
      logger = _ref90.logger;
  return function (url, body) {
    var blob = new Blob([body], {
      type: "text/plain; charset=UTF-8"
    });

    if (!sendBeacon(url, blob)) {
      logger.info("Unable to use `sendBeacon`; falling back to `fetch`.");
      return sendFetchRequest(url, body);
    } // Using sendBeacon, we technically don't get a response back from
    // the server, but we'll resolve the promise with an object to maintain
    // consistency with other network strategies.


    return Promise.resolve({
      statusCode: 204,
      getHeader: function getHeader() {
        return null;
      },
      body: ""
    });
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createLogger = function createLogger(_ref91) {
  var getDebugEnabled = _ref91.getDebugEnabled,
      console = _ref91.console,
      getMonitors = _ref91.getMonitors,
      context = _ref91.context;
  var prefix = "[".concat(context.instanceName, "]");

  if (context.componentName) {
    prefix += " [".concat(context.componentName, "]");
  }

  var notifyMonitors = function notifyMonitors(method, data) {
    var monitors = getMonitors();

    if (monitors.length > 0) {
      var dataWithContext = (0, _reactorObjectAssign["default"])({}, context, data);
      monitors.forEach(function (monitor) {
        if (monitor[method]) {
          monitor[method](dataWithContext);
        }
      });
    }
  };

  var log = function log(level) {
    for (var _len6 = arguments.length, rest = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      rest[_key6 - 1] = arguments[_key6];
    }

    notifyMonitors("onBeforeLog", {
      level: level,
      arguments: rest
    });

    if (getDebugEnabled()) {
      console[level].apply(console, [prefix].concat(rest));
    }
  };

  return {
    get enabled() {
      return getMonitors().length > 0 || getDebugEnabled();
    },

    logOnInstanceCreated: function logOnInstanceCreated(data) {
      notifyMonitors("onInstanceCreated", data);
      log("info", "Instance initialized.");
    },
    logOnInstanceConfigured: function logOnInstanceConfigured(data) {
      notifyMonitors("onInstanceConfigured", data);
      log("info", "Instance configured. Computed configuration:", data.config);
    },
    logOnBeforeCommand: function logOnBeforeCommand(data) {
      notifyMonitors("onBeforeCommand", data);
      log("info", "Executing ".concat(data.commandName, " command. Options:"), data.options);
    },
    logOnCommandResolved: function logOnCommandResolved(data) {
      notifyMonitors("onCommandResolved", data);
      log("info", "".concat(data.commandName, " command resolved. Result:"), data.result);
    },
    logOnCommandRejected: function logOnCommandRejected(data) {
      notifyMonitors("onCommandRejected", data);
      log("error", "".concat(data.commandName, " command was rejected. Error:"), data.error);
    },
    logOnBeforeNetworkRequest: function logOnBeforeNetworkRequest(data) {
      notifyMonitors("onBeforeNetworkRequest", data);
      log("info", "Request ".concat(data.requestId, ": Sending request."), data.payload);
    },
    logOnNetworkResponse: function logOnNetworkResponse(data) {
      notifyMonitors("onNetworkResponse", data);
      var messagesSuffix = data.parsedBody || data.body ? "response body:" : "no response body.";
      log("info", "Request ".concat(data.requestId, ": Received response with status code ").concat(data.statusCode, " and ").concat(messagesSuffix), data.parsedBody || data.body);
    },
    logOnNetworkError: function logOnNetworkError(data) {
      notifyMonitors("onNetworkError", data);
      log("error", "Request ".concat(data.requestId, ": Network request failed."), data.error);
    },

    /**
     * Outputs informational message to the web console. In some
     * browsers a small "i" icon is displayed next to these items
     * in the web console's log.
     * @param {...*} arg Any argument to be logged.
     */
    info: log.bind(null, "info"),

    /**
     * Outputs a warning message to the web console.
     * @param {...*} arg Any argument to be logged.
     */
    warn: log.bind(null, "warn"),

    /**
     * Outputs an error message to the web console.
     * @param {...*} arg Any argument to be logged.
     */
    error: log.bind(null, "error")
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var EVENT_CANCELLATION_MESSAGE = "Event was canceled because the onBeforeEventSend callback returned false.";

var createEventManager = function createEventManager(_ref92) {
  var config = _ref92.config,
      logger = _ref92.logger,
      lifecycle = _ref92.lifecycle,
      consent = _ref92.consent,
      createEvent = _ref92.createEvent,
      createDataCollectionRequestPayload = _ref92.createDataCollectionRequestPayload,
      createDataCollectionRequest = _ref92.createDataCollectionRequest,
      sendEdgeNetworkRequest = _ref92.sendEdgeNetworkRequest;
  var onBeforeEventSend = config.onBeforeEventSend;
  return {
    createEvent: createEvent,

    /**
     * Sends an event. This includes running the event and payload through
     * the appropriate lifecycle hooks, sending the request to the server,
     * and handling the response.
     * @param {Object} event This will be JSON stringified and used inside
     * the request payload.
     * @param {Object} [options]
     * @param {boolean} [options.renderDecisions=false]
     * @param {Array} [options.decisionScopes]
     * This will be passed to components
     * so they can take appropriate action.
     * @returns {*}
     */
    sendEvent: function sendEvent(event) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$renderDecisi2 = options.renderDecisions,
          renderDecisions = _options$renderDecisi2 === void 0 ? false : _options$renderDecisi2,
          decisionScopes = options.decisionScopes;
      var payload = createDataCollectionRequestPayload();
      var request = createDataCollectionRequest(payload);
      var onResponseCallbackAggregator = createCallbackAggregator();
      var onRequestFailureCallbackAggregator = createCallbackAggregator();
      return lifecycle.onBeforeEvent({
        event: event,
        renderDecisions: renderDecisions,
        decisionScopes: decisionScopes,
        onResponse: onResponseCallbackAggregator.add,
        onRequestFailure: onRequestFailureCallbackAggregator.add
      }).then(function () {
        payload.addEvent(event);
        return consent.awaitConsent();
      }).then(function () {
        try {
          // NOTE: this calls onBeforeEventSend callback (if configured)
          event.finalize(onBeforeEventSend);
        } catch (error) {
          var throwError = function throwError() {
            throw error;
          };

          onRequestFailureCallbackAggregator.add(lifecycle.onRequestFailure);
          return onRequestFailureCallbackAggregator.call({
            error: error
          }).then(throwError, throwError);
        } // if the callback returns false, the event should not be sent


        if (!event.shouldSend()) {
          onRequestFailureCallbackAggregator.add(lifecycle.onRequestFailure);
          logger.info(EVENT_CANCELLATION_MESSAGE);
          var error = new Error(EVENT_CANCELLATION_MESSAGE);
          return onRequestFailureCallbackAggregator.call({
            error: error
          }).then(function () {// Ensure the promise gets resolved with undefined instead
            // of an array of return values from the callbacks.
          });
        }

        return sendEdgeNetworkRequest({
          request: request,
          runOnResponseCallbacks: onResponseCallbackAggregator.call,
          runOnRequestFailureCallbacks: onRequestFailureCallbackAggregator.call
        });
      });
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var STATE_STORE_HANDLE_TYPE = "state:store";

var createCookieTransfer = function createCookieTransfer(_ref93) {
  var cookieJar = _ref93.cookieJar,
      orgId = _ref93.orgId,
      apexDomain = _ref93.apexDomain;
  return {
    /**
     * When sending to a third-party endpoint, the endpoint won't be able to
     * access first-party cookies, therefore we transfer cookies into
     * the request body so they can be read by the server.
     */
    cookiesToPayload: function cookiesToPayload(payload, endpointDomain) {
      var isEndpointFirstParty = endsWith(endpointDomain, apexDomain);
      var state = {
        domain: apexDomain,
        cookiesEnabled: true
      }; // If the endpoint is first-party, there's no need to transfer cookies
      // to the payload since they'll be automatically passed through cookie
      // headers.

      if (!isEndpointFirstParty) {
        var cookies = cookieJar.get();
        var entries = Object.keys(cookies).filter(function (name) {
          // We have a contract with the server that we will pass
          // all cookies whose names are namespaced according to the
          // logic in isNamespacedCookieName as well as any legacy
          // cookie names (so that the server can handle migrating
          // identities on websites previously using Visitor.js)
          return isNamespacedCookieName(orgId, name);
        }).map(function (qualifyingCookieName) {
          return {
            key: qualifyingCookieName,
            value: cookies[qualifyingCookieName]
          };
        });

        if (entries.length) {
          state.entries = entries;
        }
      }

      payload.mergeState(state);
    },

    /**
     * When receiving from a third-party endpoint, the endpoint won't be able to
     * write first-party cookies, therefore we write first-party cookies
     * as directed in the response body.
     */
    responseToCookies: function responseToCookies(response) {
      response.getPayloadsByType(STATE_STORE_HANDLE_TYPE).forEach(function (stateItem) {
        var options = {
          domain: apexDomain
        };

        if (stateItem.maxAge !== undefined) {
          // cookieJar expects "expires" in days
          options.expires = convertTimes(SECOND, DAY, stateItem.maxAge);
        }

        cookieJar.set(stateItem.key, stateItem.value, options);
      });
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createDataCollectionRequestPayload = function createDataCollectionRequestPayload() {
  var content = {};
  var payload = createRequestPayload({
    content: content,
    addIdentity: createAddIdentity(content)
  });

  payload.addEvent = function (event) {
    content.events = content.events || [];
    content.events.push(event);
  };

  payload.getDocumentMayUnload = function () {
    return (content.events || []).some(function (event) {
      return event.getDocumentMayUnload();
    });
  };

  return payload;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createDataCollectionRequest = function createDataCollectionRequest(dataCollectionRequestPayload) {
  var getUseSendBeacon = function getUseSendBeacon(_ref94) {
    var isIdentityEstablished = _ref94.isIdentityEstablished;
    // When the document may be unloading, we still hit the interact endpoint
    // using fetch if an identity has not been established. If we were instead
    // to hit the collect endpoint using sendBeacon in this case, one of three
    // things would occur:
    //
    // 1. The document ultimately isn't unloaded and Alloy receives an empty
    // response back from the collect endpoint, resulting in an error being
    // thrown by Alloy because we weren't able to establish an identity.
    // This is bad.
    // 2. The document is unloaded, but Alloy receives the empty
    // response back from the collect endpoint before navigation is completed,
    // resulting in an error being thrown by Alloy because we weren't able to
    // establish an identity. This is bad.
    // 3. The document is unloaded and Alloy does not receive the empty response
    // back from the collect endpoint before navigation is completed. No error
    // will be thrown, but no identity was established either. This is okay,
    // though no identity was established.
    //
    // By hitting the interact endpoint using fetch, one of the three things
    // would occur:
    //
    // 1. The document ultimately isn't unloaded and Alloy receives a
    // response with an identity back from the interact endpoint. No
    // error will be thrown and an identity is established. This is good.
    // 2. The document is unloaded and Alloy receives a response with an
    // identity back from the interact endpoint before navigation is completed.
    // No error will be thrown and an identity is established. This is good.
    // 3. The document is unloaded and Alloy does not receive the empty response
    // back from the collect endpoint before navigation is completed. In this
    // case, no error is thrown, but no identity was established and it's
    // more likely that the request never makes it to the server because we're
    // using fetch instead of sendBeacon.
    //
    // The second approach seemed preferable.
    return dataCollectionRequestPayload.getDocumentMayUnload() && isIdentityEstablished;
  };

  return createRequest({
    payload: dataCollectionRequestPayload,
    getAction: function getAction(_ref95) {
      var isIdentityEstablished = _ref95.isIdentityEstablished;
      return getUseSendBeacon({
        isIdentityEstablished: isIdentityEstablished
      }) ? "collect" : "interact";
    },
    getUseSendBeacon: getUseSendBeacon
  });
};

var apiVersion = "v1";
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var injectSendEdgeNetworkRequest = function injectSendEdgeNetworkRequest(_ref96) {
  var config = _ref96.config,
      lifecycle = _ref96.lifecycle,
      cookieTransfer = _ref96.cookieTransfer,
      sendNetworkRequest = _ref96.sendNetworkRequest,
      createResponse = _ref96.createResponse,
      processWarningsAndErrors = _ref96.processWarningsAndErrors;
  var edgeDomain = config.edgeDomain,
      edgeBasePath = config.edgeBasePath,
      edgeConfigId = config.edgeConfigId;
  /**
   * Sends a network request that is aware of payload interfaces,
   * lifecycle methods, configured edge domains, response structures, etc.
   */

  return function (_ref97) {
    var request = _ref97.request,
        _ref97$runOnResponseC = _ref97.runOnResponseCallbacks,
        runOnResponseCallbacks = _ref97$runOnResponseC === void 0 ? noop : _ref97$runOnResponseC,
        _ref97$runOnRequestFa = _ref97.runOnRequestFailureCallbacks,
        runOnRequestFailureCallbacks = _ref97$runOnRequestFa === void 0 ? noop : _ref97$runOnRequestFa;
    var onResponseCallbackAggregator = createCallbackAggregator();
    onResponseCallbackAggregator.add(lifecycle.onResponse);
    onResponseCallbackAggregator.add(runOnResponseCallbacks);
    var onRequestFailureCallbackAggregator = createCallbackAggregator();
    onRequestFailureCallbackAggregator.add(lifecycle.onRequestFailure);
    onRequestFailureCallbackAggregator.add(runOnRequestFailureCallbacks);
    return lifecycle.onBeforeRequest({
      request: request,
      onResponse: onResponseCallbackAggregator.add,
      onRequestFailure: onRequestFailureCallbackAggregator.add
    }).then(function () {
      var endpointDomain = request.getUseIdThirdPartyDomain() ? ID_THIRD_PARTY : edgeDomain;
      var url = "https://".concat(endpointDomain, "/").concat(edgeBasePath, "/").concat(apiVersion, "/").concat(request.getAction(), "?configId=").concat(edgeConfigId, "&requestId=").concat(request.getId());
      cookieTransfer.cookiesToPayload(request.getPayload(), endpointDomain);
      return sendNetworkRequest({
        requestId: request.getId(),
        url: url,
        payload: request.getPayload(),
        useSendBeacon: request.getUseSendBeacon()
      });
    }).then(function (networkResponse) {
      processWarningsAndErrors(networkResponse);
      return networkResponse;
    })["catch"](function (error) {
      // Regardless of whether the network call failed, an unexpected status
      // code was returned, or the response body was malformed, we want to call
      // the onRequestFailure callbacks, but still throw the exception.
      var throwError = function throwError() {
        throw error;
      };

      return onRequestFailureCallbackAggregator.call({
        error: error
      }).then(throwError, throwError);
    }).then(function (_ref98) {
      var parsedBody = _ref98.parsedBody,
          getHeader = _ref98.getHeader;
      // Note that networkResponse.parsedBody may be undefined if it was a
      // 204 No Content response. That's fine.
      var response = createResponse({
        content: parsedBody,
        getHeader: getHeader
      });
      cookieTransfer.responseToCookies(response); // Notice we're calling the onResponse lifecycle method even if there are errors
      // inside the response body. This is because the full request didn't actually fail--
      // only portions of it that are considered non-fatal (a specific, non-critical
      // Konductor plugin, for example).

      return onResponseCallbackAggregator.call({
        response: response
      }).then(function (returnValues) {
        // Merges all returned objects from all `onResponse` callbacks into
        // a single object that can later be returned to the customer.
        var lifecycleOnResponseReturnValues = returnValues.shift() || [];
        var consumerOnResponseReturnValues = returnValues.shift() || [];
        var lifecycleOnBeforeRequestReturnValues = returnValues;
        return _reactorObjectAssign["default"].apply(void 0, [{}].concat(_toConsumableArray(lifecycleOnResponseReturnValues), _toConsumableArray(consumerOnResponseReturnValues), _toConsumableArray(lifecycleOnBeforeRequestReturnValues)));
      });
    });
  };
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var NO_CONTENT = 204;
var TOO_MANY_REQUESTS = 429;
var BAD_GATEWAY = 502;
var SERVICE_UNAVAILABLE = 503;
var GATEWAY_TIMEOUT = 504;
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var MESSAGE_PREFIX = "The server responded with a";

var injectProcessWarningsAndErrors = function injectProcessWarningsAndErrors(_ref99) {
  var logger = _ref99.logger;
  return function (networkResponse) {
    var statusCode = networkResponse.statusCode,
        body = networkResponse.body,
        parsedBody = networkResponse.parsedBody;

    if (statusCode < 200 || statusCode >= 300 || !parsedBody && statusCode !== NO_CONTENT || parsedBody && !Array.isArray(parsedBody.handle)) {
      var bodyToLog = parsedBody ? JSON.stringify(parsedBody, null, 2) : body;
      var messageSuffix = bodyToLog ? "response body:\n".concat(bodyToLog) : "no response body.";
      throw new Error("".concat(MESSAGE_PREFIX, " status code ").concat(statusCode, " and ").concat(messageSuffix));
    }

    if (parsedBody) {
      var _parsedBody$warnings = parsedBody.warnings,
          warnings = _parsedBody$warnings === void 0 ? [] : _parsedBody$warnings,
          _parsedBody$errors = parsedBody.errors,
          errors = _parsedBody$errors === void 0 ? [] : _parsedBody$errors;
      warnings.forEach(function (warning) {
        logger.warn("".concat(MESSAGE_PREFIX, " warning:"), warning);
      });
      errors.forEach(function (error) {
        logger.error("".concat(MESSAGE_PREFIX, " non-fatal error:"), error);
      });
    }
  };
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var MAX_RETRIES = 3;
var RETRYABLE_STATUS_CODES = [TOO_MANY_REQUESTS, SERVICE_UNAVAILABLE, BAD_GATEWAY, GATEWAY_TIMEOUT]; // These rules are in accordance with
// https://git.corp.adobe.com/pages/experience-edge/konductor/#/apis/errors?id=handling-4xx-and-5xx-responses

var isRequestRetryable = function isRequestRetryable(_ref100) {
  var response = _ref100.response,
      retriesAttempted = _ref100.retriesAttempted;
  return retriesAttempted < MAX_RETRIES && includes(RETRYABLE_STATUS_CODES, response.statusCode);
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var FIRST_DELAY_MILLIS = 1000;
var INCREMENTAL_DELAY_MILLIS = 1000; // When the target delay is randomized, make it within the range of this percentage above or below the target delay.

var MAX_RANDOM_VARIANCE_PERCENTAGE = 0.3;

var calculateRetryDelay = function calculateRetryDelay(retriesAttempted) {
  var targetDelay = FIRST_DELAY_MILLIS + retriesAttempted * INCREMENTAL_DELAY_MILLIS;
  var maxVariance = targetDelay * MAX_RANDOM_VARIANCE_PERCENTAGE;
  var minDelay = targetDelay - maxVariance;
  var maxDelay = targetDelay + maxVariance;
  var randomizedDelayWithinRange = Math.round(minDelay + Math.random() * (maxDelay - minDelay));
  return randomizedDelayWithinRange;
};

var getDelayFromHeader = function getDelayFromHeader(response) {
  // According to the HTTP spec, if the header is defined, its value will be a string that
  // represents either:
  //  * An integer indicating the number of seconds to delay.
  //  * A date after which a retry may occur. The date would be in HTTP-date
  //    format (https://tools.ietf.org/html/rfc7231#section-7.1.1.1). When debugging, it can
  //    be helpful to know that this is the same format that a JavaScript date's
  //    toGMTString() returns.
  var headerValue = response.getHeader(RETRY_AFTER);
  var delayInMillis;

  if (headerValue) {
    var headerValueInt = parseInt(headerValue, 10);

    if (isInteger(headerValueInt)) {
      delayInMillis = headerValueInt * 1000;
    } else {
      delayInMillis = Math.max(0, new Date(headerValue).getTime() - new Date().getTime());
    }
  }

  return delayInMillis;
}; // These rules are in accordance with
// https://git.corp.adobe.com/pages/experience-edge/konductor/#/apis/errors?id=handling-4xx-and-5xx-responses
// For retry delays that don't come from a Retry-After response header, we try to stick with the following best
// practices outlined in https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults:
//  * Incremental retry
//  * Random interval


var getRequestRetryDelay = function getRequestRetryDelay(_ref101) {
  var response = _ref101.response,
      retriesAttempted = _ref101.retriesAttempted;
  // Technically, only 429 or 503 responses should have a Retry-After header, but we'll respect the
  // header if we find it on any response.
  var delayInMillis = getDelayFromHeader(response); // Note that the value of delay may be 0 at this point, which would be a valid delay we want to use
  // and not override, which is why we don't do:
  // if (!delay) { ... }

  if (delayInMillis === undefined) {
    delayInMillis = calculateRetryDelay(retriesAttempted);
  }

  return delayInMillis;
};
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var createNamespacedStorage = injectStorage(window);
var _window = window,
    console = _window.console,
    fetch = _window.fetch,
    navigator = _window.navigator,
    XMLHttpRequest = _window.XMLHttpRequest; // set this up as a function so that monitors can be added at anytime

var coreConfigValidators = createCoreConfigs();
var apexDomain$1 = getApexDomain(window, _reactorCookie["default"]);
var sendFetchRequest = isFunction(fetch) ? injectSendFetchRequest({
  fetch: fetch
}) : injectSendXhrRequest({
  XMLHttpRequest: XMLHttpRequest
});

var createExecuteCommand = function createExecuteCommand(_ref102) {
  var instanceName = _ref102.instanceName,
      _ref102$logController = _ref102.logController,
      setDebugEnabled = _ref102$logController.setDebugEnabled,
      logger = _ref102$logController.logger,
      createComponentLogger = _ref102$logController.createComponentLogger;
  var componentRegistry = createComponentRegistry();
  var lifecycle = createLifecycle(componentRegistry);

  var setDebugCommand = function setDebugCommand(options) {
    setDebugEnabled(options.enabled, {
      fromConfig: false
    });
  };

  var configureCommand = function configureCommand(options) {
    var config = buildAndValidateConfig({
      options: options,
      componentCreators: componentCreators,
      coreConfigValidators: coreConfigValidators,
      createConfig: createConfig,
      logger: logger,
      setDebugEnabled: setDebugEnabled
    });
    var cookieTransfer = createCookieTransfer({
      cookieJar: _reactorCookie["default"],
      orgId: config.orgId,
      apexDomain: apexDomain$1
    });
    var sendBeaconRequest = isFunction(navigator.sendBeacon) ? injectSendBeaconRequest({
      // Without the bind(), the browser will complain about an
      // illegal invocation.
      sendBeacon: navigator.sendBeacon.bind(navigator),
      sendFetchRequest: sendFetchRequest,
      logger: logger
    }) : sendFetchRequest;
    var sendNetworkRequest = injectSendNetworkRequest({
      logger: logger,
      sendFetchRequest: sendFetchRequest,
      sendBeaconRequest: sendBeaconRequest,
      isRequestRetryable: isRequestRetryable,
      getRequestRetryDelay: getRequestRetryDelay
    });
    var processWarningsAndErrors = injectProcessWarningsAndErrors({
      logger: logger
    });
    var extractEdgeInfo = injectExtractEdgeInfo({
      logger: logger
    });
    var createResponse = injectCreateResponse({
      extractEdgeInfo: extractEdgeInfo
    });
    var sendEdgeNetworkRequest = injectSendEdgeNetworkRequest({
      config: config,
      lifecycle: lifecycle,
      cookieTransfer: cookieTransfer,
      sendNetworkRequest: sendNetworkRequest,
      createResponse: createResponse,
      processWarningsAndErrors: processWarningsAndErrors
    });
    var generalConsentState = createConsentStateMachine({
      logger: logger
    });
    var consent = createConsent({
      generalConsentState: generalConsentState,
      logger: logger
    });
    var eventManager = createEventManager({
      config: config,
      logger: logger,
      lifecycle: lifecycle,
      consent: consent,
      createEvent: createEvent,
      createDataCollectionRequestPayload: createDataCollectionRequestPayload,
      createDataCollectionRequest: createDataCollectionRequest,
      sendEdgeNetworkRequest: sendEdgeNetworkRequest
    });
    return initializeComponents({
      componentCreators: componentCreators,
      lifecycle: lifecycle,
      componentRegistry: componentRegistry,
      getImmediatelyAvailableTools: function getImmediatelyAvailableTools(componentName) {
        var componentLogger = createComponentLogger(componentName);
        return {
          config: config,
          consent: consent,
          eventManager: eventManager,
          logger: componentLogger,
          lifecycle: lifecycle,
          sendEdgeNetworkRequest: sendEdgeNetworkRequest,
          handleError: injectHandleError({
            errorPrefix: "[".concat(instanceName, "] [").concat(componentName, "]"),
            logger: componentLogger
          }),
          createNamespacedStorage: createNamespacedStorage
        };
      }
    });
  };

  var handleError = injectHandleError({
    errorPrefix: "[".concat(instanceName, "]"),
    logger: logger
  });
  var executeCommand = injectExecuteCommand({
    logger: logger,
    configureCommand: configureCommand,
    setDebugCommand: setDebugCommand,
    handleError: handleError,
    validateCommandOptions: validateCommandOptions
  });
  return executeCommand;
};
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/


var _window2 = window,
    console$1 = _window2.console;
var createNamespacedStorage$1 = injectStorage(window);

var createInstance = function createInstance() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var eventOptionsValidator = boundObjectOf({
    name: boundString()["default"]("alloy"),
    monitors: boundArrayOf(boundObjectOf({}))["default"]([])
  }).noUnknownFields();

  var _eventOptionsValidato = eventOptionsValidator(options),
      name = _eventOptionsValidato.name,
      monitors = _eventOptionsValidato.monitors; // this is a function so that window.__alloyMonitors can be set or added to at any time
  // eslint-disable-next-line no-underscore-dangle


  var getMonitors = function getMonitors() {
    return (window.__alloyMonitors || []).concat(monitors);
  };

  var logController = createLogController({
    console: console$1,
    locationSearch: window.location.search,
    createLogger: createLogger,
    instanceName: name,
    createNamespacedStorage: createNamespacedStorage$1,
    getMonitors: getMonitors
  });
  var instance = createExecuteCommand({
    instanceName: name,
    logController: logController
  });
  logController.logger.logOnInstanceCreated({
    instance: instance
  });
  return instance;
};

exports.createInstance = createInstance;
          }

        },
        "adobe-alloy/dist/lib/instanceManager/createInstanceManager.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
module.exports = function (_ref) {
  var turbine = _ref.turbine,
      window = _ref.window,
      createInstance = _ref.createInstance,
      _createEventMergeId = _ref.createEventMergeId,
      orgId = _ref.orgId,
      wrapOnBeforeEventSend = _ref.wrapOnBeforeEventSend;

  var _turbine$getExtension = turbine.getExtensionSettings(),
      instancesSettings = _turbine$getExtension.instances;

  var instanceByName = {};
  instancesSettings.forEach(function (_ref2) {
    var name = _ref2.name,
        edgeConfigId = _ref2.edgeConfigId,
        stagingEdgeConfigId = _ref2.stagingEdgeConfigId,
        developmentEdgeConfigId = _ref2.developmentEdgeConfigId,
        onBeforeEventSend = _ref2.onBeforeEventSend,
        options = _objectWithoutProperties(_ref2, ["name", "edgeConfigId", "stagingEdgeConfigId", "developmentEdgeConfigId", "onBeforeEventSend"]);

    var instance = createInstance({
      name: name
    });
    window[name] = instance;
    instanceByName[name] = instance;
    var computedEdgeConfigId = turbine.environment.stage === "development" && developmentEdgeConfigId || turbine.environment.stage === "staging" && stagingEdgeConfigId || edgeConfigId;
    instance("configure", _objectSpread(_objectSpread({}, options), {}, {
      edgeConfigId: computedEdgeConfigId,
      debugEnabled: turbine.debugEnabled,
      orgId: options.orgId || orgId,
      onBeforeEventSend: wrapOnBeforeEventSend(onBeforeEventSend)
    }));
    turbine.onDebugChanged(function (enabled) {
      instance("setDebug", {
        enabled: enabled
      });
    });
  });
  return {
    /**
     * Returns an instance by name.
     * @param name
     * @returns {Function}
     */
    getInstance: function getInstance(name) {
      return instanceByName[name];
    },

    /**
     * Synchronously creates an event merge ID.
     * @returns {string}
     */
    createEventMergeId: function createEventMergeId() {
      return _createEventMergeId();
    }
  };
};
          }

        },
        "adobe-alloy/dist/lib/instanceManager/injectWrapOnBeforeEventSend.js": {
          "script": function(module, exports, require, turbine) {
"use strict";

/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
module.exports = function (_ref) {
  var version = _ref.version;
  return function (onBeforeEventSend) {
    return function (content) {
      content.xdm.implementationDetails.name = "".concat(content.xdm.implementationDetails.name, "/reactor");
      content.xdm.implementationDetails.version = "".concat(content.xdm.implementationDetails.version, "+").concat(version);

      if (onBeforeEventSend) {
        return onBeforeEventSend(content);
      }

      return undefined;
    };
  };
};
          }

        }
      }
    }
  },
  "company": {
    "orgId": "9E1005A551ED61CA0A490D45@AdobeOrg"
  },
  "property": {
    "name": "global",
    "settings": {
      "domains": [
        "www.adobe.com"
      ],
      "undefinedVarsReturnEmpty": true,
      "ruleComponentSequencingEnabled": false
    },
    "id": "PR8b349c8b6c36453bad7e9a5f89d9fa3a"
  },
  "rules": [
    {
      "id": "RLd2d1af3b7832427cac6a6cafb5cdb176",
      "name": "am_InteractionTracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/click.js",
          "settings": {
            "elementSelector": "[daa-ll],[data-daa-ll]",
            "bubbleFireIfParent": true,
            "bubbleFireIfChildFired": false
          },
          "ruleOrder": 1.0
        },
        {
          "modulePath": "core/src/lib/events/click.js",
          "settings": {
            "elementSelector": "[daa-lh]:not([daa-ll]) a:not([daa-ll]),[data-daa-lh]:not([data-daa-ll]) a:not([data-daa-ll])",
            "bubbleFireIfParent": true,
            "bubbleFireIfChildFired": false
          },
          "ruleOrder": 50.0
        },
        {
          "modulePath": "core/src/lib/events/keyPress.js",
          "settings": {
            "elementSelector": "[daa-ll]",
            "bubbleFireIfParent": true,
            "bubbleFireIfChildFired": true
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if(window.location.href.indexOf('creativecloud')==-1 || window.location.href.indexOf('/plans')==-1 || window.location.href.indexOf('creativecloud/business/teams/plans.html')!==-1)
{
  return true;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if( typeof event.nativeEvent.keyCode !== 'undefined' ) {
  if(event.nativeEvent.keyCode == 13 ) {
    if(this.getAttribute('daa-ll') && this.getAttribute('daa-ll').indexOf(':enter') == -1) {
      this.setAttribute('daa-ll', this.getAttribute('daa-ll') + ':enter');
    }
    return true;
  }
}
else if (event.type === 'core.click') {
  return true;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  // adding snapshot and trigger logic info
var lhtext = '',
  lltext,
  stateView = false,
  w = window,
  imflag = 0,
  snapshot = w.digitalData._snapshot(),
  lhparent,
  ClosestFunction;

ClosestFunction = function (obj, target) {
  var findparent = obj;
  if(obj.closest)
    obj = obj.closest('['+target+']');
  else{
    do{
      findparent = findparent.parentNode;
      if(findparent.getAttribute(target))
      {
        obj = findparent;
        findparent=null;
      }
    }while(findparent && findparent.parentNode);
  }
  return obj;
};

snapshot._set('digitalData.adobe.experienceCloud.analytics.tag.logicTrigger', 'am_InteractionTracking');
if (this) {
  lhparent = this;
  do {
    if (lhparent.getAttribute('daa-im') || lhparent.getAttribute('data-daa-im') ) {
      imflag = 1;
    }
    if (lhparent.getAttribute('daa-dl')) {
      try {
        var dl, key;
        dl = lhparent.getAttribute('daa-dl');
        dl = JSON.parse(dl);
        for (key in dl) {
          if (!Object.prototype.hasOwnProperty.call(dl, key)) {
            continue;
          }
          snapshot._set(key, dl[key]);
        }
      } catch (e) {
        // ignore
      }
    }
    if (lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh')) {
      var selectortest = lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh');
      if (selectortest.indexOf('##') != -1)
      {
        var dynamicvalue = _satellite.getVar('adobe_dynamicValue');
        selectortest = dynamicvalue(selectortest);
      }
    }
    if (lhtext !== '' && (lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh'))) {
      lhtext = selectortest + '|' + lhtext;
    }
    else if(lhparent.getAttribute('daa-lh') || lhparent.getAttribute('data-daa-lh')) {
      lhtext = selectortest;
    }
    lhparent = lhparent.parentNode;
  } while (lhparent.parentNode);
  if (this.getAttribute('daa-ll') || this.getAttribute('data-daa-ll'))
    lltext = this.getAttribute('daa-ll') || this.getAttribute('data-daa-ll');
  else if(ClosestFunction(this, 'daa-ll') !== null)
    lltext = ClosestFunction(this, 'daa-ll').getAttribute('daa-ll');
  else if (this.text.trim() !== '')
  {
    var
      removePiiLogic = _satellite.getVar('adobe_removePiiLogic');
    lltext = removePiiLogic(this.text.trim());
  }
  else
    lltext = 'Image';
  
  if (lhtext !== '') {
    lhtext = lltext + '|' + lhtext;
  } else {
    lhtext = lltext;
  }
  lhtext = lhtext.split(',').join('');
  snapshot._set(
    'digitalData.primaryEvent.eventInfo.interaction.click',
    lhtext
  );
  if (imflag == 1) {
    snapshot._set(
      'digitalData.primaryEvent.eventInfo.interaction.iclick',
      'true'
    );
  }
  //Manage plan
  if (lhtext.indexOf('Manage plan') !== -1) {
    lhtext = 'accounts.adobe.com:plans:managePlanClick';
    w.digitalData._set(
      'digitalData.page.pageInfo.pageName',
      lhtext
    );
    _satellite.track('state', {
      // Send as a parameter a snapshot of the data layer at this point in time.
      // Note: if this is not set, we will handle take a snapshot within
      // the _satellite.track handler.
      digitalData: snapshot
    });
    stateView = true;
    lhtext = '';
  }
  if (w.digitalData._get('digitalData.page.pageInfo.siteSection') === 'account.adobe.com') {
    //Cancel click
    if (lhtext === 'Cancel Plan|Plan and Payment' || lhtext.indexOf('Cancel plan|Tetris Overview Page|Plan Pods|Plan Pod') !== -1 || lhtext.indexOf('Cancel plan|Manage Plan Modal|') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_selfCancelPlanButton';
    //Back
    if (lhtext === 'Back' || lhtext.indexOf('Back|Cancel Plan') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2AbandonCancelReasonsBtn';
    //Keep Current Plan
    if (lhtext.indexOf('Keep Current Plan') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2AbandonSwitchPlansBtn';
    //Continue
    if (lhtext.indexOf('Continue') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2SubmitReasonBtn';
    //view plan
    if (lhtext.indexOf('View Plans') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2OtherOptionsOtherPlansBtn';
    //Chat With Us
    if ((lhtext.indexOf('Get in touch') !== -1 || lhtext.indexOf('Chat') !== -1))
      lhtext = 'accounts.adobe.com:plans:onClick_sc2ChatMainOfferBtn';
    if ((lhtext.indexOf('Get in touch') !== -1 || lhtext.indexOf('Chat') !== -1) && document.getElementsByClassName('concession').length !== 0)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2OtherOptionsChatBtn';
    //Accept Offer
    if (lhtext.indexOf('Accept Offer') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2AcceptFreeTimeOfferBtn';
    //Donâ€™t Cancel
    if (lhtext.indexOf('Keep my plan|Cancel Plan') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2AbandonPlanCancelBtn';
    //Cancel
    if (lhtext.indexOf('Cancel Plan|Cancel Plan') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2ConfirmPlanCancelBtn';
    //switch plan
    if (lhtext === 'Change Plan|Plan and Payment' || lhtext.indexOf('Change plan|Tetris Overview Page|Plan Pods|Plan Pod') !== -1 || lhtext.indexOf('Change plan|Manage Plan Modal|') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_switchPlanButton';
    //change plan
    if (lhtext.indexOf('Select') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2SelectAlternatePlanBtn';
    //change plan Back
    if (lhtext.indexOf('Back|Change Plan') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_sc2AbandonSwitchPlansReviewBtn';
    //change plan complete
    if (lhtext === 'Confirm|Change Plan - Offer Details') {
      stateView = true;
      lhtext = '';
    }
    //Edit payment
    if (lhtext.indexOf('Manage Payment') !== -1)
      lhtext = 'accounts.adobe.com:plans:onClick_editPaymentButton';
  }
  if (!stateView) {
    // Commented out as need to maintain current value is not needed and can use the new value.          
    // if(this.getAttribute('data-analytics-events')){
    // digitalData._set(
    //  'digitalData.primaryEvent.eventInfo.eventName',
    //  this.getAttribute('data-analytics-events')
    //  );
    //  }
    //  else
    //  {
    snapshot._set(
      'digitalData.primaryEvent.eventInfo.eventName',
      lhtext
    );
    //  }
    _satellite.track('event', {
      // Send as a parameter a snapshot of the data layer at this point in time.
      // Note: if this is not set, we will handle take a snapshot within
      // the _satellite.track handler.
      digitalData: snapshot
    });
  }
  if (this.getAttribute('daa-state') === 'true')
    setTimeout(function () {
      _satellite.track('state');
    }, 500);
  return true;
}
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL64c0d2601c1e48728ca866b50fca3c65",
      "name": "thirdParty_CCHomePixels",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "state"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var h = window.location.hostname;
if (h == 'creativecloud.adobe.com') {
  return true;
} else { return false }
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC264f17de446d471685508e6b0b828d24-file.js'
          }
        }
      ]
    },
    {
      "id": "RL0ff575064f7d451ba1d3eb57e80de10a",
      "name": "thirdParty_pageLoadDC (Naver Pixel)",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageLoad-naverPixel"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCbe2100f2916f46cab35f1dffe43764af-file.js'
          }
        }
      ]
    },
    {
      "id": "RLca4c957d13c942e39004d6e9f17cb215",
      "name": "thirdParty_acrobat-Flashtalking",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "acrobat_flashtalking"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCb7359f2082e74c378e47927b4ebc6fef-file.js'
          }
        }
      ]
    },
    {
      "id": "RL4da49db252634bc9ac6f4fcdc8231062",
      "name": "trackPageload",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload"
          },
          "ruleOrder": 5.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTrue"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  l = w.location,
  h = l.hostname,
  p = l.pathname,
  digitalData = w.digitalData,

  // get the s object
  s = w.s_adobe,

  snapshot,
  setDigitalData,
  track,
  copy,
  copyLocation,
  didTrack = false,
  productLogic;

// if we should abort the page load pixel, do so here
if (_satellite.getVar('analytics_pageload_abort') && (!event.detail || (event.detail && !event.detail.statelogicflag)))
  return false;

// if we have already tracked a pageload hit.
// The page load hit can only be tracked once.  We enforce this because of 
// issues that arise with things like:
// - referrer
// - marketing channels
// - technology variables
// - etc.
// If you need track a single page application view change or render, please use 
// _satellite.track('state') instead.
if (s._pageloadTracked) {

  // stop processing and return false so that we don't erroneously send 
  // the hit or anything else in this rule multiple times
  return false;

  // otherwise
} else {

  // set the flag that we have already tracked the pageload hit
  s._pageloadTracked = true;

}

//------------------------------------------------------------------------------
// Convenience functions
//------------------------------------------------------------------------------
copy = function (source, target, path) {
  target._set(path, source._get(path));
};

// copy location
copyLocation = _satellite.getVar('adobe_copyLocation');

//------------------------------------------------------------------------------
// Get a snapshot and set the data
//------------------------------------------------------------------------------

// if we were passed data as the second parameter from the _satellite.track
// call, then use that
if (
  event.detail &&
  event.detail.digitalData
) {
  snapshot = event.detail.digitalData;

  // otherwise generate our snapshot it from the data layer
} else {
  snapshot = digitalData._snapshot();
}

// if this call was made before launch loaded, then make sure to update
// the snapshot with the global variables
if (
  event.detail &&
  event.detail._beforeSatelliteLoaded
) {

  // apply global digital data if it was called before _satellite was loaded
  setDigitalData = _satellite.getVar('adobe_digitalData');

  // apply the data elements on the snapshot
  setDigitalData(snapshot);
  // if this is made AFTER launch loaded
} else {
  // Note: We put all of this here because we have to capture the information at 
  // the very time when this call was made, and before we wait for things like
  // the page load hit to resolve, etc.  So, we make sure we set it right away
  // on the snapshot here.

  // digitalData.page
  //----------------------------------------------------------------------------

  // digitalData.page.pageInfo.location
  //-----------------------------------
  snapshot._set('page.pageInfo.location', copyLocation(w));
  copy(snapshot, digitalData, 'page.pageInfo.location');

  // digitalData.page.topFrameInfo.location
  //---------------------------------------
  /*snapshot._set('page.topFrameInfo.location', copyLocation(w.top));
  copy(snapshot, digitalData, 'page.topFrameInfo.location');*/

}

snapshot._set('digitalData.organization.demandbase', _satellite.getVar('digitalData.organization.demandbase'));
snapshot._set('digitalData.page.pageInfo.siteSection', _satellite.getVar('digitalData.page.pageInfo.siteSection'));
snapshot._set('digitalData.page.pageInfo.performanceTiming', _satellite.getVar('digitalData.page.pageInfo.performanceTiming'));

if (h.indexOf('adminconsole.adobe.com') == -1) {
  snapshot._set('digitalData.primaryEvent.eventInfo.interaction.impression', _satellite.getVar('digitalData.primaryEvent.eventInfo.interaction.impression'));
}

if (h.indexOf('adminconsole.adobe.com') !== -1) {
snapshot._set('digitalData.adminConsole.contractInfo', _satellite.getVar('digitalData.adminConsole.contractInfo'));
copy(snapshot, digitalData, 'digitalData.adminConsole.contractInfo');
}

if (typeof w.adobeIMS !== 'undefined' && digitalData.primaryUser.primaryProfile.profileInfo.authState === 'unknown') {
  snapshot._set('digitalData.primaryUser.primaryProfile.profileInfo', _satellite.getVar('digitalData.primaryUser.primaryProfile.profileInfo'));
  copy(snapshot, digitalData, 'digitalData.primaryUser.primaryProfile.profileInfo');
}
//Mini-plans page banner impression
snapshot._set('digitalData.plansPageAttributes.bannerImpression', _satellite.getVar('digitalData.plansPageAttributes.bannerImpression'));

//plans page
if (snapshot._get('page.pageInfo.pageName') && snapshot._get('page.pageInfo.pageName').indexOf('adobe.com:creativecloud') !== -1 && (snapshot._get('page.pageInfo.pageName').indexOf('plans') !== -1 || snapshot._get('page.pageInfo.pageName').indexOf('Plans') !== -1)) {
  snapshot._delete('digitalData.product');
  snapshot._delete('digitalData.plansPageAttributes.cardProductData');
  snapshot._delete('digitalData.plansPageAttributes.cardLayout');
}

// digitalData.page
//----------------------------------------------------------------------------

// digitalData.page.pageInfo.location
//-----------------------------------
// default it if we haven't set anything yet
if (!snapshot._get('initialPage.pageInfo.location')) {
  snapshot._set('initialPage.pageInfo.location', copyLocation(w));
  copy(snapshot, digitalData, 'initialPage.pageInfo.location');
}

// digitalData.adobe.experienceCloud.dxVisits
//-----------------------------------
// default it if we haven't set anything yet
if (!_satellite.getVar('analytics_pageload_abort')) {
  var dxhits = _satellite.getVar('digitalData.adobe.experienceCloud.dxVisits');
  if (dxhits && dxhits == '2') {
    snapshot._set('digitalData.adobe.experienceCloud.dxVisits', 'setEvent');
    copy(snapshot, digitalData, 'digitalData.adobe.experienceCloud.dxVisits');
  }
}


// digitalData.page.topFrameInfo.location
//---------------------------------------
/*
if (!snapshot._get('initialPage.topFrameInfo.location')) {
  snapshot._set('initialPage.topFrameInfo.location', copyLocation(w.top));
  copy(snapshot, digitalData, 'initialPage.topFrameInfo.location');
}
*/

//max specific Code
if (p.indexOf('/max') !== -1) {
  snapshot._set('digitalData.max', _satellite.getVar('digitalData.max'));
}

// ECP Dimensions   
if (localStorage && localStorage.getItem('ecp') !== 'undefined' && localStorage.getItem('ecp')) {
  var ecpDim = JSON.parse(localStorage.getItem('ecp'));
  snapshot._set(
    'digitalData.organization.ecp.geo',
    ecpDim.geo
  );
  copy(snapshot, digitalData, 'digitalData.organization.ecp.geo');
  snapshot._set(
    'digitalData.organization.ecp.market_area',
    ecpDim.market_area
  );
  copy(snapshot, digitalData, 'digitalData.organization.ecp.market_area');

  snapshot._set(
    'digitalData.organization.ecp.sub_std_name_key',
    ecpDim.sub_std_name_key
  );
  copy(snapshot, digitalData, 'digitalData.organization.ecp.sub_std_name_key');
}


//------------------------------------------------------------------------------
// Track it in the order that we need to
//------------------------------------------------------------------------------

// track function
track = function () {
  var
    variableOverrides = {},
    pageNameLogic,
    parseQueryParams,
    expires,
    removeParamLogic,
    sophiaLogic;

  // if we haven't tracked yet.  Note, this is to prevent this call from 
  // being made more than 1 time.
  if (!didTrack) {

    // set the flag so we only track one time for this call
    didTrack = true;

    //--------------------------------------------------------------------------
    // set digitalData properties here
    //--------------------------------------------------------------------------

    // digitalData.page
    //--------------------------------------------------------------------------
    pageNameLogic = _satellite.getVar('adobe_pageNameLogic');
    parseQueryParams = _satellite.getVar('adobe_parseQueryParams');
    removeParamLogic = _satellite.getVar('remove_url_parameters');
    sophiaLogic = _satellite.getVar('SophiaLogic');

    // digitalData.page.pageInfo.location
    //-----------------------------------
    // Note: We do this mainly because it is possible that the page location 
    // may have changed in the time that we started loading launch async and 
    // when it finishes loading.  initialPage is captured before launch loads.
    snapshot._set(
      'page.pageInfo.location',
      // can come from either snapshot or digitalData, it doesn't matter
      snapshot._get('initialPage.pageInfo.location')
    );
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.pageInfo.location');

    // digitalData.page.pageInfo.pageName
    //-----------------------------------
    if (w.location.pathname.indexOf('/apps/download/') == -1) {
      snapshot._set(
        'page.pageInfo.pageName',
        pageNameLogic(snapshot._get('page.pageInfo.location'))
      );
      w.s.pageName = snapshot._get('page.pageInfo.pageName');
    }

    // digitalData.page.pageInfo.pageName
    //-----------------------------------
    snapshot._set(
      'page.pageInfo.pageName',
      pageNameLogic(snapshot._get('page.pageInfo.location'))
    );

    snapshot._set(
      'sophiaResponse.listValue',
      // can come from either snapshot or digitalData, it doesn't matter
      sophiaLogic(snapshot)
    );

    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.pageInfo.pageName');

    // digitalData.page.pageInfo.queryParameters
    //------------------------------------------
    if (
      !snapshot._get('page.pageInfo.siteSection') ||
      (
        snapshot._get('page.pageInfo.siteSection') &&
        snapshot._get('page.pageInfo.siteSection') !== 'IMS'
      )
    ) {
      snapshot._set(
        'page.pageInfo.queryParameters',
        parseQueryParams(snapshot._get('page.pageInfo.location.search'))
      );
    }
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.pageInfo.queryParameters');

    // digitalData.page.topFrameInfo.location
    //---------------------------------------
    // Note: We do this mainly because it is possible that the page location 
    // may have changed in the time that we started loading launch async and 
    // when it finishs loading.  initialPage is captured before launch loads.
    snapshot._set(
      'page.topFrameInfo.location',
      // can come from either snapshot or digitalData, it doesn't matter
      snapshot._get('initialPage.topFrameInfo.location')
    );
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.topFrameInfo.location');


    // digitalData.page.topFrameInfo.pageName
    //---------------------------------------
    snapshot._set(
      'page.topFrameInfo.pageName',
      pageNameLogic(snapshot._get('page.topFrameInfo.location'))
    );
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.topFrameInfo.pageName');

    // digitalData.nglParams
    //---------------------------------------
    snapshot._set('nglParams', _satellite.getVar('digitalData.nglParams'));
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'nglParams');

    // digitalData.app.appInfo.appCtxId
    //---------------------------------------
    snapshot._set('app.appInfo.appCtxId', _satellite.getVar('digitalData.app.appInfo.appCtxId'));
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'app.appInfo.appCtxId');

    //digitalData.app.appInfo.campaignId
    //---------------------------------------
    snapshot._set('app.appInfo.campaignId', _satellite.getVar('digitalData.app.appInfo.campaignId'));
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'app.appInfo.campaignId');

    // digitalData.previousPage
    //--------------------------------------------------------------------------

    //Copied for state call
    //--------------------------------------------------------------------------
    //digitalData.search.filters (Helpx), (Project Alfred/Community)
    //---------------------------------------
    if ((snapshot._get('digitalData.page.pageInfo.pageName') &&

        /*(snapshot._get('digitalData.page.pageInfo.pageName').indexOf('adobe.com:search') !== -1 || 
          snapshot._get('digitalData.page.pageInfo.pageName').indexOf('adobe.com:globalsearch') !== -1) && */

        snapshot._get('digitalData.page.pageInfo.siteSection') == 'Support & Learning') ||
      (snapshot._get('digitalData.page.pageInfo.siteSection') && snapshot._get('digitalData.page.pageInfo.siteSection').indexOf('Community:') !== -1)) {
      //updating the filters for Processing Rule
      var filterLogic = _satellite.getVar('digitalData.search.filters');
      snapshot._set('digitalData.search.filters', filterLogic(snapshot));
      // copy from snapshot to global digitalData object
      copy(snapshot, digitalData, 'digitalData.search.filters');

      if (snapshot._get('digitalData.community')) {
        //updating the property for eVar203
        snapshot._set('digitalData.community.communityInfo.details', _satellite.getVar('digitalData.community.communityInfo.details'));
        // copy from snapshot to global digitalData object
        copy(snapshot, digitalData, 'digitalData.community.communityInfo.details');
      }
    }

    if (snapshot._get('digitalData.page.pageInfo.siteSection') && snapshot._get('digitalData.page.pageInfo.siteSection') === 'Support & Learning') {
      snapshot._set('digitalData.helpx.translatedStatus', _satellite.getVar('digitalData.helpx.translatedStatus'));
      copy(snapshot, digitalData, 'digitalData.helpx.translatedStatus');
    }

    if (_satellite.cookie.get('TRADEDOUBLER')) {
      snapshot._set('digitalData.campaign.external.arvato.campaignInfo.uid', _satellite.getVar('digitalData.campaign.external.arvato.campaignInfo.uid'));
      copy(snapshot, digitalData, 'digitalData.campaign.external.arvato.campaignInfo.uid');
    }


    //digitalData.language
    digitalData._set(
      'language',
      digitalData._get('page.pageInfo.language')
    );
    // digitalData.previousPage.pageInfo.pageName
    //-------------------------------------------
    // if I am to top frame
    if (w === w.top) {

      // get the previous pageName from the cookie
      snapshot._set(
        'previousPage.pageInfo.pageName',
        _satellite.cookie.get('gpv')
      );
      // copy from snapshot to global digitalData object
      copy(snapshot, digitalData, 'previousPage.pageInfo.pageName');

      // set updated previous page name to the current page name 
      expires = new Date();
      expires.setTime(expires.getTime() + 1800000);
      _satellite.cookie.set(
        'gpv',
        // can come from either snapshot or digitalData, it doesn't matter
        digitalData._get('page.pageInfo.pageName'), {
          expires: expires,
          domain: _satellite._getDomain()
        }
      );
    }

    //-------------------------------------------------------------------------
    //delete homepage pods informations
    //-------------------------------------------------------------------------
    snapshot._delete('pods');
    snapshot._delete('primaryPod');

    //-------------------------------------------------------------------------
    // Support for adding to impressions on unload and keep track of what impressions have been set currently.
    //-------------------------------------------------------------------------
    if (typeof window.tempImpression !== 'undefined' && window.tempImpression.length > 0 && typeof snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression') !== 'undefined')
      window.tempImpression = window.tempImpression + ',' + snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression');
    else if (typeof snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression') !== 'undefined')
      window.tempImpression = snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression');

    //remove  params
    snapshot._set(
      'page.topFrameInfo.pageName',
      pageNameLogic(snapshot._get('page.topFrameInfo.location'))
    );
    snapshot._set(
      'initialPage.pageInfo.location.href',
      removeParamLogic(snapshot._get('initialPage.pageInfo.location.href'), 'uri')
    );
    snapshot._set(
      'initialPage.pageInfo.location.search',
      removeParamLogic(snapshot._get('initialPage.pageInfo.location.search'), 'uri')
    );
    snapshot._set(
      'initialPage.topFrameInfo.location.href',
      removeParamLogic(snapshot._get('initialPage.topFrameInfo.location.href'), 'uri')
    );
    snapshot._set(
      'initialPage.topFrameInfo.location.search',
      removeParamLogic(snapshot._get('initialPage.topFrameInfo.location.search'), 'uri')
    );
    snapshot._set(
      'page.pageInfo.location.href',
      removeParamLogic(snapshot._get('page.pageInfo.location.href'), 'uri')
    );

    snapshot._set(
      'page.pageInfo.location.search',
      removeParamLogic(snapshot._get('page.pageInfo.location.search'), 'uri')
    );

    snapshot._set(
      'page.topFrameInfo.location.href',
      removeParamLogic(snapshot._get('page.topFrameInfo.location.href'), 'uri')
    );

    snapshot._set(
      'page.topFrameInfo.location.search',
      removeParamLogic(snapshot._get('page.topFrameInfo.location.search'), 'uri')
    );

    //copy
    copy(snapshot, digitalData, 'primaryUser.primaryProfile.profileInfo');

    //end of remove params


    //--------------------------------------------------------------------------
    // serialize the data layer into context data
    //--------------------------------------------------------------------------

    // set the data from the data layer
    variableOverrides.contextData =
      snapshot._flatten(snapshot, 'digitalData', false);

    // mark the hit as a pageload hit
    variableOverrides.contextData['hit.type'] = 'pageload';

    // special case for GDPR consent and server-side forwarding to AAM for id syncs
    // Please see this for additional information: 
    // https://marketing.adobe.com/resources/help/en_US/reference/ssf-gdpr.html
    variableOverrides.contextData['cm.ssf'] = 0;
    /*  variableOverrides.contextData['cm.ssf'] = (
      _satellite.getVar('isConsentGiven') ? 0 : 1
    );
*/
    // mark the hit as a pageView hit for marketing rules
    // variableOverrides.contextData['hitType'] = 'pageView';

    // TODO: set special contextData for a.state (whatever it should be)

    //--------------------------------------------------------------------------
    // manually copy pageURL
    //--------------------------------------------------------------------------

    // s.pageURL
    s.pageURL = variableOverrides.contextData['digitalData.page.pageInfo.location.href'];

    // strip query string
    if (_satellite.getVar('isDCWeb')) {
      if (!s.pageURL)
        s.pageURL = l.href;
      // remove hash
      s.pageURL = s.pageURL.split('#')[0];
      // remove query string
      s.pageURL = s.pageURL.split('?')[0];
    }


    productLogic = _satellite.getVar('s.productLogic');
    s.products = productLogic(snapshot);

    if (!s.products && _satellite.getVar('adobe_aec_pages') && _satellite.getVar('adobe_aec_products')) {
      s.products = _satellite.getVar('adobe_aec_products');
      variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventName'] = 'prodView|event3';
    } else if (h.indexOf('adminconsole.adobe.com') !== -1) {
      productLogic = _satellite.getVar('adobe_adminConsole_products');
      s.products = productLogic(snapshot);
    }
    //--------------------------------------------------------------------------
    // send the tracking call
    //--------------------------------------------------------------------------
    s.t(variableOverrides);

    _satellite.track('pageview', {
      digitalData: snapshot
    })

    s.products = '';
    // resolve the promise
    setTimeout(function () {
      s._pageLoadTrackedResolve();
    }, 1000);
  }

};

snapshot._resolved()

  .then(track);

// timeout for 10 seconds and then force track
setTimeout(track, 10 * 1000);

// before unload force track
_satellite._beforeUnload(track, -9);

// return true to say that this should be tracked and not hold anything up
return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL9e7f87607d4d4e608601276988e0eaf1",
      "name": "thirdParty_munchkin_tag_DXnext",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var h = window.location.host;

if(h==='business.stage.adobe.com' || h==='business.adobe.com'){
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC734a6c7885644c64aa3f0cdeb788459d-file.js'
          }
        }
      ]
    },
    {
      "id": "RL5f169ed65b9448438d6b73784bd47758",
      "name": "Clear After Tag",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload"
          },
          "ruleOrder": 50.0
        },
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "state"
          },
          "ruleOrder": 50.0
        },
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "event"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* global digitalData:true */
var
  // get the s object
  w = window,
  host = w.location.hostname,
  clear;

// if we have already tracked a pageload hit.
/*if (
  event.identifier && 
  event.identifier === 'pageload' &&
  s._pageloadTracked
) {

  // stop processing and return false so that we don't erroneously clear
  // data that shouldn't be cleared
  return false;
}*/

clear = function () {

  if (host.indexOf('cmo') !== -1 && event.identifier && event.identifier !== 'pageload') {
    digitalData._delete(
      'digitalData.primaryEvent.eventInfo.interaction.impression'
    );
  }

  else {
    digitalData._delete(
      'digitalData.primaryEvent.eventInfo.interaction.impression'
    );
  }
  digitalData._delete(
    'digitalData.marketingtech.diagnostic.stateTrigger'
  );
  digitalData._delete(
    'digitalData.page.pageInfo.pageLoadtime'
  );

  digitalData._delete(
    'digitalData.search.filters'
  );

};


clear();


return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL64b72840786e4b339d28c6d533ccd73b",
      "name": "initSophia",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 1.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var 
  w = window;

if (
  w.marketingtech &&
  w.marketingtech.sophia
) {
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCbb47518ad08d43699044c6ef46f39ebb-file.js'
          }
        }
      ]
    },
    {
      "id": "RLe8cecd1fab0145b693dc9307708a2891",
      "name": "thirdParty_pageLoadCommunityDotCom",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
   //window.thirdParty_pageLoad_AdobeCom = false;

if (_satellite.getVar('thirdPartyTags_allowedDomains') && _satellite.getVar('thirdPartyTags_allowedDomains') == 4 ) {
    return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC6275892cda0f470db4919723bf673652-file.js'
          }
        }
      ]
    },
    {
      "id": "RLf45aacec029b408db9d42ab7ac99f995",
      "name": "thirdParty_pageLoadAdobeDotCom (Sizmek)",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload-Sizmek tracking code - Elements pages"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCe63438f8ba2e4fadb8347962fd58ecfd-file.js'
          }
        }
      ]
    },
    {
      "id": "RL302ec7f2f06c4616b4cd168daaf30e9f",
      "name": "thirdParty_TheBigWillowAnalyticsPixel ",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "thirdPartyTBWTag"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCb1294bab1f7b4548a02c5330729a5c65-file.js'
          }
        }
      ]
    },
    {
      "id": "RL6a21c7aa2044438bb42579b4612e1c35",
      "name": "trackPageunload",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageunload"
          },
          "ruleOrder": 5.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  digitalData = w.digitalData,
  snapshot = new DigitalData(),
  copyLocation;

//------------------------------------------------------------------------------
// Convenience functions
//------------------------------------------------------------------------------
copy = function (source, target, path) {
  target._set(path, source._get(path));
};

// Blocking PageUnload Calls for mini-plans Page
if (typeof digitalData._get('page.pageInfo.pageName') != 'undefined' &&
  digitalData._get('page.pageInfo.pageName').indexOf('mini-plans') != -1) {
  return false;
}

// copy location
copyLocation = _satellite.getVar('adobe_copyLocation');
//------------------------------------------------------------------------------
// set data on data layer
//------------------------------------------------------------------------------
//snapshot = digitalData._snapshot();

// digitalData.primaryEvent
//------------------------------------------------------------------------------
snapshot._set('primaryEvent.eventInfo.eventName', 'page unload');

snapshot._set(
  'primaryEvent.eventInfo.interaction.impression',
  _satellite.getVar('digitalData.primaryEvent.eventInfo.interaction.impression')
);

// digitalData.page
//------------------------------------------------------------------------------
snapshot._set(
  'digitalData.page',
  digitalData._get('digitalData.page')
);

snapshot._set(
  'page.pageInfo.timeSpentOnPage',
  _satellite.getVar('digitalData.page.pageInfo.timeSpentOnPage')
);

snapshot._set(
  'digitalData.page.pageInfo.siteSection',
  _satellite.getVar('digitalData.page.pageInfo.siteSection')
);

snapshot._set(
  'digitalData.page.pageInfo.performanceTiming.unload',
  _satellite.getVar('digitalData.page.pageInfo.performanceTiming.unload')
);

/*snapshot._set('digitalData.diagnostic.page.timeToTarget', (
  window.timeToTarget || ''
));
*/
// digitalData.adobe
//------------------------------------------------------------------------------
snapshot._set(
  'digitalData.adobe.experienceCloud.analytics.tag.logicTrigger',
  'trackPageunload'
);

// digitalData.marketingTagInfo
//------------------------------------------------------------------------------
snapshot._set(
  'digitalData.marketingTags',
  _satellite.getVar('digitalData.marketingTags')
);

// Add DnB
if (
  (
    digitalData._get('digitalData.organization.dnb')
  )
) {
  snapshot._set(
    'digitalData.organization.dnb',
    digitalData._get('digitalData.organization.dnb'));
}

//max updates
if (window.location.pathname.indexOf('/max') !== -1) {
  snapshot._set(
    'digitalData.max.rf.userkey',
    digitalData._get('digitalData.max.rf.userkey'));

  snapshot._set(
    'digitalData.max.isregistered',
    digitalData._get('digitalData.max.isregistered'));
}

//adminconsole updates
if (digitalData._get('digitalData.adminConsole.organizationInfo')) {
  copy(digitalData, snapshot, 'digitalData.adminConsole.organizationInfo');
}

// track an event
_satellite.track('event', {
  digitalData: snapshot
});

// return true to say that this should be tracked and not hold anything up
return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL233542a53669406f814f59f746626d1e",
      "name": "search_ctr_tracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  l = w.location,
  h,
  p,
  hostnameContains,
  pathnameContains;

// parameter or default to location.hostname
h = l.hostname;
p = l.pathname;
// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function (string) {
  return p.indexOf(string) !== -1;
};

if (hostnameContains('services.adobe.com')) {
  return false;
} else if (hostnameContains('workflow') && hostnameContains('.licenses.adobe.com')) {
  return false;
} else if (hostnameContains('.adobe.com') &&
  pathnameContains('/mini-plans')
) {
  return false;
} else if (hostnameContains('.adobe.com')) {
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC6f46e43fa6d44dbeb45cc5801ffded0e-file.js'
          }
        }
      ]
    },
    {
      "id": "RL87ac102248de44bc8d47bfea2b142a85",
      "name": "initTargetV2",
      "events": [
        {
          "modulePath": "core/src/lib/events/customCode.js",
          "settings": {
            "source": function(trigger) {
  var w = window,
  loc = w.location,
  h = loc.host,
  href = loc.href,
  triggerTarget = {
    settings: {
      timeout: 2500,
      time: 0
    },
    waitForFeds: function (fedsLoaded) {
      if (window.feds && window.fedsConfig) {
        fedsLoaded();
      } else if (triggerTarget.settings.time >= triggerTarget.settings.timeout) {
        trigger();
      } else {
        triggerTarget.settings.time = triggerTarget.settings.time + 100;
        setTimeout(function () {
          triggerTarget.waitForFeds(fedsLoaded)
        }, 100);
      }
    },
    init: function () {
      window.feds.utilities.getUserEntitlements().then(function (entitlements) {
        //console.log(entitlements);
        trigger();
      });
    }
  };

if (h.indexOf('adobe.com') > -1 && href.indexOf('mini-plans') == -1) {
  triggerTarget.waitForFeds(function () {
    triggerTarget.init();
  });
} else {
  trigger();
}
}
          },
          "ruleOrder": 4.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTrue"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  
var 
  w = window,
  enable = _satellite.getVar('target_enable'),
  isEmpty,
  key,
  distinct;

if (enable) {
  
  w.ttMETA = w.ttMETA || [];
  
  isEmpty = function (val) { 
    return (
      val === undefined || 
      val == null || 
      val.length <= 0
    ) ? true : false; 
  }

  key = function (obj) { 
    return Object.keys(obj)
    .map(function(k) {
      return k + '' + obj[k];
    }) 
    .join(''); 
  } 

  distinct = function (arr) { 
    var result = arr.reduce(function(acc, e) { 
      acc[key(e)] = e; 
      return acc; 
    }, {}); 
    return Object.keys(result) 
    .map(function(k) {
      return result[k];
    }); 
  }

  document.addEventListener('at-request-succeeded', function (e) { 
    var
      tokens = e.detail.responseTokens,
      uniqueTokens;  

    if (!isEmpty(tokens)) {
      
      uniqueTokens = distinct(tokens);

      uniqueTokens.forEach(function(token) { 
        w.ttMETA.push({ 
          CampaignName: token['activity.name'],
          RecipeName: token['experience.name'],
          CampaignId : token['activity.id'],
          RecipeId: token['experience.id'],
          OfferId: token['option.id'],
          OfferName: token['option.name']
        });
      }); 
    }

  });
  
}

return enable;





}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "adobe-target-v2/lib/loadTarget.js",
          "settings": {
          }
        },
        {
          "modulePath": "adobe-target-v2/lib/addParams.js",
          "settings": {
            "params": {
              "mar_aud": {
                "value": "%mbox_parameter_mar_aud%",
                "checked": true
              },
              "entity.id": {
                "value": "%mbox_parameter_entityId%",
                "checked": true
              },
              "at_property": {
                "value": "%mbox_parameter_at_property%",
                "checked": true
              },
              "category.id": {
                "value": "%mbox_parameter_categoryId%",
                "checked": true
              },
              "entitlement_cloud": {
                "value": "%mbox_parameter_entitlement_cloud%",
                "checked": true
              },
              "entitlement_product": {
                "value": "%mbox_parameter_entitlement_product%",
                "checked": true
              }
            }
          }
        },
        {
          "modulePath": "adobe-target-v2/lib/firePageLoad.js",
          "settings": {
            "bodyHiddenStyle": "body {opacity: 0}",
            "bodyHidingEnabled": true
          }
        }
      ]
    },
    {
      "id": "RL9b3459061af14a9cab903c5120e88c7e",
      "name": "trackState",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "state"
          },
          "ruleOrder": 5.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTrue"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  hostname = w.location.hostname,
  pathname = w.location.pathname,
  digitalData = w.digitalData;
//BLock state calls for adobe MAX - that has event name = 'Collection Changed'
if (hostname.indexOf('adobe.com') != -1 && pathname.indexOf('max') != -1 && digitalData._get('primaryEvent.eventInfo.eventName') && digitalData._get('primaryEvent.eventInfo.eventName') == 'Collection Changed') {
  return false;
} else return true;
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  hostname = w.location.hostname,
  digitalData = w.digitalData,

  // get the s object
  s = w.s_adobe,

  snapshot,
  setDigitalData,
  track,
  copy,
  copyLocation,
  didTrack = false,
  setStateDigitalData = _satellite.getVar('adobe_digitalData_State');

// if we should abort the page load pixel, do so here
if (_satellite.getVar('analytics_pageload_abort') && !s._firststate && !s._pageloadTracked) {

  if (
    event.detail &&
    event.detail.digitalData &&
    event.detail._beforeSatelliteLoaded
  ) {
    _satellite.track('pageload', {
      statelogicflag: true,
      digitalData: event.detail.digitalData,
      _beforeSatelliteLoaded: event.detail._beforeSatelliteLoaded
    });
    // otherwise generate our snapshot it from the data layer
  } else if (
    event.detail &&
    event.detail.digitalData
  ) {
    _satellite.track('pageload', {
      statelogicflag: true,
      digitalData: event.detail.digitalData
    });
    // otherwise generate our snapshot it from the data layer
  } else {
    _satellite.track('pageload', {
      statelogicflag: true
    });
  }
  s._firststate = true;
  return true;
}

if (typeof digitalData._get('digitalData.page.pageInfo.location.pathname') !== 'undefined' && w.location.pathname !== digitalData._get('digitalData.page.pageInfo.location.pathname'))
  w.tempImpression = '';
// track an unload of the previous page if they don't call pageload
//if(window.pageUnloadAbort===undefined || !window.pageUnloadAbort){

// disabled unload as there are some concerns over if this should be part of a state call. Main concern is around how we ask page owners to update the current stage of the page before triggering the state call. So having unload would cause a conflict with the correct page data.
//_satellite.track('pageunload');
//}

_satellite._timeSpentOnPage.restart();

// apply them on the global digitalData object.  This is the only place
// that we set the digital data layer properties that are our responsibility.
setStateDigitalData(window.digitalData);



copy = function (source, target, path) {
  target._set(path, source._get(path));
};

// copy location
copyLocation = _satellite.getVar('adobe_copyLocation');

//------------------------------------------------------------------------------
// Get a snapshot and set the data
//------------------------------------------------------------------------------

// if we were passed data as the second parameter from the _satellite.track
// call, then use that
if (
  event.detail &&
  event.detail.digitalData
) {
  snapshot = event.detail.digitalData;

  // otherwise generate our snapshot it from the data layer
} else {
  snapshot = digitalData._snapshot();
}
// if this call was made before launch loaded, then make sure to update
// the snapshot with the global variables
if (
  event.detail &&
  event.detail._beforeSatelliteLoaded
) {

  // apply global digital data if it was called before _satellite was loaded
  setDigitalData = _satellite.getVar('adobe_digitalData');

  // apply the data elements on the snapshot
  setDigitalData(snapshot);

  // if this is made AFTER launch loaded
} else {
  // Note: We put all of this here because we have to capture the information at 
  // the very time when this call was made, and before we wait for things like
  // the page load hit to resolve, etc.  So, we make sure we set it right away
  // on the snapshot here.

  // digitalData.page
  //----------------------------------------------------------------------------

  // digitalData.page.pageInfo.location
  //-----------------------------------
  snapshot._set('page.pageInfo.location', copyLocation(w));
  copy(snapshot, digitalData, 'page.pageInfo.location');

  // digitalData.page.topFrameInfo.location
  //---------------------------------------
  /*snapshot._set('page.topFrameInfo.location', copyLocation(w.top));
  copy(snapshot, digitalData, 'page.topFrameInfo.location');*/

}

snapshot._set('digitalData.primaryUser.primaryProfile.profileInfo', _satellite.getVar('digitalData.primaryUser.primaryProfile.profileInfo'));


if (hostname.indexOf('adminconsole.adobe.com') == -1) {
  snapshot._set('digitalData.primaryEvent.eventInfo.interaction.impression', _satellite.getVar('digitalData.primaryEvent.eventInfo.interaction.impression'));
}

if (hostname.indexOf('adminconsole.adobe.com') !== -1) {
  snapshot._set('digitalData.adminConsole.contractInfo', _satellite.getVar('digitalData.adminConsole.contractInfo'));
  copy(snapshot, digitalData, 'digitalData.adminConsole.contractInfo');
}
//plans page
if (snapshot._get('page.pageInfo.pageName') && snapshot._get('page.pageInfo.pageName').indexOf('adobe.com:creativecloud') !== -1 && (snapshot._get('page.pageInfo.pageName').indexOf('plans') !== -1 || snapshot._get('page.pageInfo.pageName').indexOf('Plans') !== -1)) {
  snapshot._set(
    'digitalData.page.pageInfo.language',
    digitalData._get('language')
  );
  copy(snapshot, digitalData, 'digitalData.page.pageInfo.language');
  digitalData._set(
    'modalName',
    digitalData._get('digitalData.page.pageInfo.pageName')
  );
  snapshot._delete('digitalData.product');
  snapshot._delete('digitalData.plansPageAttributes.cardProductData');
}

// ECP Dimensions 

if (localStorage && localStorage.getItem('ecp') !== 'undefined' && localStorage.getItem('ecp')) {
  var ecpDim = JSON.parse(localStorage.getItem('ecp'));

  snapshot._set(
    'digitalData.organization.ecp.geo',
    ecpDim.geo
  );
  copy(snapshot, digitalData, 'digitalData.organization.ecp.geo');

  snapshot._set(
    'digitalData.organization.ecp.market_area',
    ecpDim.market_area
  );
  copy(snapshot, digitalData, 'digitalData.organization.ecp.market_area');

  snapshot._set(
    'digitalData.organization.ecp.sub_std_name_key',
    ecpDim.sub_std_name_key
  );
  copy(snapshot, digitalData, 'digitalData.organization.ecp.sub_std_name_key');
}


//------------------------------------------------------------------------------
// Track it in the order that we need to
//------------------------------------------------------------------------------

// track function
track = function () {
  var
    variableOverrides = {},
    pageNameLogic,
    parseQueryParams,
    sophiaLogic,
    expires;

  // if we haven't tracked yet
  if (!didTrack) {

    // set the flag so we only track one time for this call
    didTrack = true;

    //--------------------------------------------------------------------------
    // set digitalData properties here
    //--------------------------------------------------------------------------

    // digitalData.page
    //--------------------------------------------------------------------------
    pageNameLogic = _satellite.getVar('adobe_pageNameLogic');
    parseQueryParams = _satellite.getVar('adobe_parseQueryParams');
    sophiaLogic = _satellite.getVar('SophiaLogic');

    snapshot._set(
      'sophiaResponse.listValue',
      // can come from either snapshot or digitalData, it doesn't matter
      sophiaLogic(snapshot)
    );
    // digitalData.page.pageInfo.location
    //-----------------------------------
    // Note: We don't set pageInfo.location here on the snapshot because the 
    // snapshot will have the correct page information already.  Just copy it.
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.pageInfo.location');

    // digitalData.page.pageInfo.pageName
    //-----------------------------------
    if (w.location.pathname.indexOf('/apps/download/') == -1) {
      snapshot._set(
        'page.pageInfo.pageName',
        pageNameLogic(snapshot._get('page.pageInfo.location'))
      );
      w.s.pageName = snapshot._get('page.pageInfo.pageName');
    }
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.pageInfo.pageName');

    // digitalData.page.pageInfo.queryParameters
    //------------------------------------------
    snapshot._set(
      'page.pageInfo.queryParameters',
      parseQueryParams(snapshot._get('page.pageInfo.location.search'))
    );
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.pageInfo.queryParameters');

    // digitalData.page.topFrameInfo.location
    //---------------------------------------
    // Note: We don't set pageInfo.location here on the snapshot because the 
    // snapshot will have the correct page information already.  Just copy it.
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.topFrameInfo.location');


    // digitalData.page.topFrameInfo.pageName
    //---------------------------------------
    snapshot._set(
      'page.topFrameInfo.pageName',
      pageNameLogic(snapshot._get('page.topFrameInfo.location'))
    );
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'page.topFrameInfo.pageName');

    // digitalData.nglParams
    //---------------------------------------
    snapshot._set('nglParams', _satellite.getVar('digitalData.nglParams'));
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'nglParams');

    // digitalData.app.appInfo.appCtxId
    //---------------------------------------
    snapshot._set('app.appInfo.appCtxId', _satellite.getVar('digitalData.app.appInfo.appCtxId'));
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'app.appInfo.appCtxId');

    //digitalData.app.appInfo.campaignId
    //---------------------------------------
    snapshot._set('app.appInfo.campaignId', _satellite.getVar('digitalData.app.appInfo.campaignId'));
    // copy from snapshot to global digitalData object
    copy(snapshot, digitalData, 'app.appInfo.campaignId');

    //digitalData.search.filters (Helpx), (Project Alfred/Community)
    //---------------------------------------
    if (
      (snapshot._get('digitalData.page.pageInfo.pageName') &&
        /*(snapshot._get('digitalData.page.pageInfo.pageName').indexOf('adobe.com:search') !== -1 ||
          snapshot._get('digitalData.page.pageInfo.pageName').indexOf('adobe.com:globalsearch') !== -1) &&*/

        snapshot._get('digitalData.page.pageInfo.siteSection') == 'Support & Learning') ||
      (snapshot._get('digitalData.page.pageInfo.siteSection') && snapshot._get('digitalData.page.pageInfo.siteSection').indexOf('Community:') !== -1)) {
      //updating the filters for Processing Rule
      //updating the filters for Processing Rule
      var filterLogic = _satellite.getVar('digitalData.search.filters');
      snapshot._set('digitalData.search.filters', filterLogic(snapshot));
      // copy from snapshot to global digitalData object
      copy(snapshot, digitalData, 'digitalData.search.filters');

      if (snapshot._get('digitalData.community')) {
        //updating the property for eVar203
        snapshot._set('digitalData.community.communityInfo.details', _satellite.getVar('digitalData.community.communityInfo.details'));
        // copy from snapshot to global digitalData object
        copy(snapshot, digitalData, 'digitalData.community.communityInfo.details');
      }
    }

    if (snapshot._get('digitalData.page.pageInfo.siteSection') && snapshot._get('digitalData.page.pageInfo.siteSection') === 'Support & Learning') {
      snapshot._set('digitalData.helpx.translatedStatus', _satellite.getVar('digitalData.helpx.translatedStatus'));
      copy(snapshot, digitalData, 'digitalData.helpx.translatedStatus');
    }

    // digitalData.adobe.experienceCloud.dxVisits
    //-----------------------------------
    // default it if we haven't set anything yet
    var dxhits = _satellite.getVar('digitalData.adobe.experienceCloud.dxVisits');
    if (dxhits && dxhits == '2') {
      snapshot._set('digitalData.adobe.experienceCloud.dxVisits', 'setEvent');
      copy(snapshot, digitalData, 'digitalData.adobe.experienceCloud.dxVisits');
    }

    /*eVar142 Fix*/
    if (_satellite.cookie.get('TRADEDOUBLER')) {
      snapshot._set('digitalData.campaign.external.arvato.campaignInfo.uid', _satellite.getVar('digitalData.campaign.external.arvato.campaignInfo.uid'));
      copy(snapshot, digitalData, 'digitalData.campaign.external.arvato.campaignInfo.uid');
    }

    if (typeof window.tempImpression !== 'undefined' && window.tempImpression && window.tempImpression.length > 0 && typeof snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression') !== 'undefined')
      window.tempImpression = window.tempImpression + ',' + snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression');
    else if (typeof snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression') !== 'undefined')
      window.tempImpression = snapshot._get('digitalData.primaryEvent.eventInfo.interaction.impression');

    // digitalData.previousPage
    //--------------------------------------------------------------------------

    // digitalData.previousPage.pageInfo.pageName
    //-------------------------------------------
    // if I am to top frame
    if (w === w.top) {

      // get the previous pageName from the cookie
      snapshot._set(
        'previousPage.pageInfo.pageName',
        _satellite.cookie.get('gpv')
      );
      // copy from snapshot to global digitalData object
      copy(snapshot, digitalData, 'previousPage.pageInfo.pageName');

      // set updated previous page name to the current page name 
      expires = new Date();
      expires.setTime(expires.getTime() + 1800000);
      _satellite.cookie.set(
        'gpv',
        // can come from either snapshot or digitalData, it doesn't matter
        digitalData._get('page.pageInfo.pageName'), {
          expires: expires,
          domain: _satellite._getDomain()
        }
      );
    }

    //--------------------------------------------------------------------------
    // delete the data layer properties
    //--------------------------------------------------------------------------
    if (_satellite.getVar('topFrameInfo_abort')) {
      snapshot._delete('page.topFrameInfo');
      snapshot._delete('page.pageInfo.queryParameters');
      snapshot._delete('page.pageInfo.location.href');
      snapshot._delete('page.pageInfo.location.search');
      snapshot._delete('page.pageInfo.location.hash');
      snapshot._delete('initialPage');
    }

    //copy
    copy(snapshot, digitalData, 'primaryUser.primaryProfile.profileInfo');

    //--------------------------------------------------------------------------
    // serialize the data layer into context data
    //--------------------------------------------------------------------------

    // set the data from the data layer
    variableOverrides.contextData =
      snapshot._flatten(snapshot, 'digitalData', false);

    // mark the hit as a pageload hit
    variableOverrides.contextData['hit.type'] = 'state';

    // special case for GDPR consent and server-side forwarding to AAM for id syncs
    // Please see this for additional information: 
    // https://marketing.adobe.com/resources/help/en_US/reference/ssf-gdpr.html
    variableOverrides.contextData['cm.ssf'] = 0;
    /*variableOverrides.contextData['cm.ssf'] = (
      _satellite.getVar('isConsentGiven') ? 0 : 1
    );*/

    // TODO: set special contextData for a.state (whatever it should be)

    //--------------------------------------------------------------------------
    // manually copy pageURL
    //--------------------------------------------------------------------------

    // s.pageURL
    s.pageURL = variableOverrides.contextData['digitalData.page.pageInfo.location.href'];


    // strip query string
    if (_satellite.getVar('isDCWeb')) {
      // remove hash
      s.pageURL = s.pageURL.split('#')[0];
      // remove query string
      s.pageURL = s.pageURL.split('?')[0];
    }

    var productLogic;
    // AM product variable with offerID
    if (snapshot._get('product.productInfo.jil.offerId')) {
      var
        offerIdLogic;
      offerIdLogic = _satellite.getVar('adobe_AM_offerid');
      s.products = offerIdLogic(snapshot);
    }
    // AC Product Variable Logic
    else if (hostname.indexOf('adminconsole.adobe.com') !== -1) {
      productLogic = _satellite.getVar('adobe_adminConsole_products');
      s.products = productLogic(snapshot);
    }
    // General Product Variable for all uses cases except AC and AM
    else {
      productLogic = _satellite.getVar('s.productLogic');
      s.products = productLogic(snapshot);
    }

    //--------------------------------------------------------------------------
    // send the tracking call
    //--------------------------------------------------------------------------

    s.t(variableOverrides);

    _satellite.track('pageview', {
      digitalData: snapshot
    })

    // unset the products string
    s.products = '';


  }

};

// make sure that we have a promise created if we haven't done that already
s._lastHitPromise = s._lastHitPromise || Promise.resolve();

// update the s._lastHitPromise to be me
s._lastHitPromise =

  // only track after dependencies
  Promise.all([
    // wait for the page load
    s._pageloadTrackedPromise,
    // wait until the data layer snapshot is resolved
    snapshot._resolved(),
    // wait until the last hit was sent
    s._lastHitPromise
  ])

  .then(track);


// timeout for 15 seconds and then force track
setTimeout(track, 15 * 1000);

// before unload force track
_satellite._beforeUnload(track);


//set pageunload flag to true
//window.pageUnloadAbort = false;


// return true to say that this should be tracked and not hold anything up
return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLdf32447aa1514b40b4370d4ffccf10e5",
      "name": "thirdParty_adCloud-FB-PPBU",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "thirdParty_PPBU-adCloud"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC1071e4b1b2df49deaa8a7bb6a62d55ac-source.js',
            "language": "javascript",
            "isExternal": true
          }
        }
      ]
    },
    {
      "id": "RL1eafb7ea82414cc5871a633d60ac0534",
      "name": "test clicktale_new",
      "events": [
        {
          "modulePath": "core/src/lib/events/customCode.js",
          "settings": {
            "source": function(trigger) {
  // eslint-disable-next-line no-unused-vars
/* global trigger:true */
var
  w = window,
  // d = document,
  wait,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (noThirdParty) {
  return false;
}

wait = function () {
  setTimeout(trigger, 100);
};

//------------------------------------------------------------------------------
// determine whether consent has been granted or if we should wait for it
//------------------------------------------------------------------------------
determineConsent = function () {

  // if consent is given
  if (_satellite.getVar('isConsentGiven')) {
    wait();

  // otherwise, wait until the PrivacyConsent event fires and consent is given
  } else {
    w.addEventListener('adobePrivacy:PrivacyConsent', wait);
  }

};

// if the ready state has already been fired
// NOTE: this is because launch can fire after window.load has already fired...
// it is unlikely, but we have to cover this case
if (document.readyState === 'complete') {
  determineConsent();

// if it hasn't fired yet
} else {
  w.addEventListener('load', determineConsent);
}
}
          },
          "ruleOrder": 55.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if(_satellite._getQueryParam('clicktaleEnable') === 'true'){
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCd510ed13afc642a3a4a10f92a3336d75-source.js',
            "language": "javascript",
            "isExternal": true
          }
        }
      ]
    },
    {
      "id": "RL989fbd756a45484ca69a6421cc6f4a48",
      "name": "thirdParty_drift",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "initTrackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* eslint-disable no-undef */
var
  href = window.location.href,
  host = window.location.hostname,
  hrefContains,
  langContains,
  path = window.location.pathname,
  specificURLs;
hrefContains = function (string) {
  return href.indexOf(string) !== -1;
};

langContains = function (string) {
  return (
    digitalData._get('page.pageInfo.language') &&
    digitalData._get('page.pageInfo.language').toLowerCase().indexOf(string) !== -1);
};

function newFunction() {

  if(hrefContains('business.stage.adobe.com') || hrefContains('business.adobe.com')){
    return true
  }
  if (
    (
      (hrefContains('adobe.com')) && (!hrefContains('acrobat.adobe.com'))
    ) &&
    (
      langContains('uk') ||
      langContains('de') ||
      langContains('fr') ||
      langContains('de-at') ||
      langContains('de-ch') ||
      langContains('fr-ch') ||
      langContains('en-be') ||
      langContains('fr-be')
    ) &&
    (
      hrefContains('/marketing-cloud') ||
      hrefContains('/insights') ||
      hrefContains('/industries') ||
      hrefContains('/sensei') ||
      hrefContains('/products/xml-documentation-for-experience-manager') ||
      hrefContains('/request-consultation/') ||
      hrefContains('/customershowcase') ||
      hrefContains('/marketing/') ||
      hrefContains('/advertising/') ||
      hrefContains('/commerce/')
    )
  ) {
    return true;
  }
  if (
    (
      hrefContains('adobe.com')  && (!hrefContains('acrobat.adobe.com'))
    )  &&
      (
        langContains('us') ||
        langContains('au') ||
        langContains('nz') ||
        langContains('in') ||
        langContains('uk') ||
        langContains('de') ||
        langContains('fr') ||
        langContains('ja') ||
        langContains('en-be') ||
        langContains('de-at') ||
        langContains('de-ch') ||
        langContains('fr-ch') ||
        langContains('fr-be') 
      ) &&
      (
        hrefContains('/marketing/experience-manager') ||
        hrefContains('/experience-cloud') ||
        hrefContains('/what-is-adobe-experience-cloud') ||
        hrefContains('/advertising/adobe-advertising-cloud') ||
        hrefContains('/analytics/a') ||
        hrefContains('/marketing/campaign') ||
        hrefContains('/commerce/magento') ||
        hrefContains('/marketing/target') ||
        hrefContains('/experience-platform') ||
        hrefContains('/marketing/marketo') ||
        hrefContains('/request-consultation/advertising-cloud') ||
        hrefContains('/summit') ||
        hrefContains('/events/') ||
        hrefContains('/max/') ||
        hrefContains('/lead/experiencecloud/') ||
        hrefContains('/marketing-cloud') ||
        hrefContains('/real-time-customer-data-platform') ||
        hrefContains('/industries/') 
      )
    )
   {
    return true;
  } 
  
  if (hrefContains('adobe.com') && langContains('us') &&
    (
      hrefContains('/sign') ||
      hrefContains('/documentcloud/industries/') ||
      hrefContains('/documentcloud/departments/') ||
      hrefContains('/documentcloud/verticals.html') ||
      hrefContains('/documentcloud/integrations') ||
      hrefContains('/documentcloud/resources')
    )
  ) {
    return true;
  }
  
if ((hrefContains('www.marketo.com') || host == 'blog.marketo.com' || host == 'stage-blog.marketo.com' || hrefContains('au.marketo.com') ||hrefContains('uk.marketo.com') ||
		hrefContains('de.marketo.com') || hrefContains('es.marketo.com') || hrefContains('fr.marketo.com')) && 
		path.indexOf('fearless-forum') == -1 && path.indexOf('success-series') == -1){
	return true;
  }

 if(host.indexOf('magento.com') > -1 || host.indexOf('dc-stage.magedevteam') > -1 || host.indexOf('dc-stage.magedecteam.com') > -1){
    return true
  }
  //query param is chat=drift , then trigger drift
  if (hrefContains('?chat=drift')) {
    return true;
  }

  else {
    return false;
  }
}

return newFunction();
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC99cfe6fdc2c344ad8b937a84d693ea2e-file.js'
          }
        }
      ]
    },
    {
      "id": "RL4b12fc37ef8e4453882d491815ce840c",
      "name": "SearchCTR_tracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  l = w.location,
  h,
  hostnameContains;
// parameter or default to location.hostname
h = l.hostname;
// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

//Only for search results page
if (hostnameContains('adobe.com') && window.location.pathname === '/search.html') {
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCafc2f6388f5940a194f10bbb98836494-file.js'
          }
        }
      ]
    },
    {
      "id": "RL703822b8f85048b8b4998faa5fa38a8f",
      "name": "aep_trackEvent",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "aepEvent"
          },
          "ruleOrder": 45.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%aep_enable%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  //only if eventname exist
if((event && event.detail && event.detail.digitalData && event.detail.digitalData._get('AEPeventName')) || digitalData._get('AEPeventName')){
    return true
   }
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if (
  event.detail &&
  event.detail.digitalData
) {
  digitalData = event.detail.digitalData;
}

return true;
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC1674e0ea4dce447aad8dad64d01bb270-source.js',
            "language": "javascript",
            "isExternal": true
          }
        }
      ]
    },
    {
      "id": "RL75ea12d39be748ae9445693be1e3d17e",
      "name": "thirdParty_Madison Logic Campaign Tag",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload-MadisonlogicTag"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC71bc24c934aa48b5ac073dba921d9926-source.js',
            "language": "javascript",
            "isExternal": true
          }
        }
      ]
    },
    {
      "id": "RL1781b3733880462ab5adb9fe248ab6ab",
      "name": "thirdParty_pageLoadClicktaleGlobalProperty",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "initTrackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
  loc = w.location,
  h = loc.hostname,
  p = loc.pathname;

if ((marketingtech && marketingtech.integrate && marketingtech.integrate.contentSquare) &&
  (_satellite.groupEnabled && _satellite.groupEnabled('C0002'))
) {
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCe2a21049769940f19652c159e2e718eb-file.js'
          }
        }
      ]
    },
    {
      "id": "RL8ecbed2dbe6f4e839ab48925d2718d6d",
      "name": "thirdPartypageLoad_DC_SRI_Clicktale(contentSquare)",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "clicktaleSRI"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC250c4d5ed8394c68adcd27675d42feba-file.js'
          }
        }
      ]
    },
    {
      "id": "RLe912d4faee1e4992b63201bb76fb9422",
      "name": "thirdParty_Facebook_fontsdotadobe",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "initTrackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (!noThirdParty) {
  return true;
}

}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* Domain condition for fonts.adobe.com*/
var w = window,
  l = w.location,
  h = l.hostname;

if (h == 'fonts.adobe.com') {
  return true;
} else {
  return false;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "equals"
            },
            "leftOperand": "%thirdParty_isAbort%",
            "rightOperand": "yes"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%isStudent%"
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC6b6f7be61ee043bbb3ccc6227c2d7296-file.js'
          }
        }
      ]
    },
    {
      "id": "RL540be8ca4243469ea4eb9b148c407a46",
      "name": "trackMarketoForms",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackMarketoForm"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCbc1a19aea273457b98640357c5bd09ec-file.js'
          }
        }
      ]
    },
    {
      "id": "RLfb0dd4a9054549bfb60ed96e0e9399ac",
      "name": "thirdParty_AMOtag-StockEnterprise",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackGroupConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if (window.location.hostname == 'stockenterprise.adobe.com') {
  return true;
} else { return false; }
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC60bc5ff5181041b597097a25663e55e7-file.js'
          }
        }
      ]
    },
    {
      "id": "RL10d4a185a2974c0dbe5ece19530cac8d",
      "name": "thirdParty_FB_FT - XD download",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload-xdDownload"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCeaab041d6a6743e0b1459d1b341181a5-file.js'
          }
        }
      ]
    },
    {
      "id": "RL4055bf4b61384f16b5ec9d9b5bc38523",
      "name": "initSatellitePlugins",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 1.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  
// initialize libraries and other things that we need immediately

//------------------------------------------------------------------------------
// _satellite Plugins
//------------------------------------------------------------------------------

/* eslint-disable */

/*******************************************************************************
* Setting the global window level variables in satellite object scopr
*
* Version: 1.0
*
* Dependencies:
*   - none
* 
* Parameters:

*
* Returns:
*   
*******************************************************************************/
(function () {
  _satellite.win = window;
  _satellite.loc = _satellite.win.location;
  _satellite.host = _satellite.loc.hostname;
  _satellite.path = _satellite.loc.pathname;
  
}());

/*******************************************************************************
* _getQueryParam(name): Returns the query parameter with that name.
*
* Version: 1.0
*
* Dependencies:
*   - none
* 
* Parameters:
*   name = The query parameter string that we should get
*   search = The url query parameters string
*
* Returns:
*   The query parameter with that name
*******************************************************************************/
(function () {
  'use strict';

  _satellite._getQueryParam = function (name, search) {
    var
      keyValuePairs,
      keyValue,
      i, il,
      decode;

    // default
    search = search || window.location.search;

    // if we weren't sent a name, return
    if (!name) {
      return '';
    }

    // create uri decode function
    decode = function (string) {
      var 
        decoded = string;

      try {
        decoded = decodeURIComponent(string);
      } catch (err) {}

      return decoded;
    };

    // if serach starts with ? remove it
    if (search.indexOf('?') === 0) {
      search = search.substring(1);
    }

    // split up the search
    keyValuePairs = search.split('&');

    // loop through each
    for (i = 0, il = keyValuePairs.length; i < il; i++) {
      keyValue = keyValuePairs[i].split('=');

      if (
        keyValue[0] &&
        decode(keyValue[0]) === name
      ) {
        return decode(keyValue[1]);
      }

    }

    return '';
  };

  _satellite._getQueryParam.version = '1.0';

}());

/*******************************************************************************
* _getDomain(): Function to determine the highest level domain on which we can 
*   set cookies
*
* Version: 2.0
*   1.1 - made a change to path to set on '/' instead of current path
*   1.2 - changed cookie name and value to sat_domain=A, implemented caching
*     of domain for subsequent calls to _getDomain(), and set expire time to
*     1000 milliseconds so it will expire quickly
*   2.0 - migrated to be compatable with Adobe Launch
*
* Dependencies:
*   _satellite.cookie.get = Launch's built in function for reading cookies
*   _satellite.cookie.set = Launch's built in function for writing cookies
* 
* Parameters:
*   none
*
* Returns:
*   string representing the effective domain or '' if couldn't set a cookie
*******************************************************************************/
(function () {
  'use strict';

  var effectiveDomain = '';

  _satellite._getDomain = function () {
    if (effectiveDomain) {
      return effectiveDomain;
    }

    var 
      _this = this,
      parts = window.location.hostname.toLowerCase().split('.'),
      domain = [],
      part = '',
      date = null,
      successfullySet = false;

    // we know we can't set on tld, so just skip tld
    part = parts.pop();
    domain.unshift(part);

    while (parts.length > 0) {
      part = parts.pop();

      domain.unshift(part);

      date = new Date();
      date.setTime(date.getTime() + 1000);

      try {
        _this.cookie.set('sat_domain', 'A', {
          expires: date,
          domain: domain.join('.')
        });
      } catch (err) {
        break;
      }

      if (_this.cookie.get('sat_domain') === 'A') {
        successfullySet = true;
        effectiveDomain = domain.join('.');
        break;
      }
    }

    return successfullySet ? effectiveDomain : '';
  };

  _satellite._getDomain.version = '2.0';

}());

/*******************************************************************************
* _getDomainPeriods(): Function to determine the number of domain periods to use
*   in setting s.cookieDomainPeriods in Adobe Analytics
*
* Version: 1.0
*
* Dependencies:
*   _satellite._getDomain = Satellite plugin for getting root domain to which a cookie
*     can be set in a browser without failing
* 
* Parameters:
*   none
*
* Returns:
*   number representing the number of cookieDomainPeriods
*******************************************************************************/
(function () {
  'use strict';

  _satellite._getDomainPeriods = function () {
    var domain = this._getDomain();
    return domain ? domain.split('.').length : 2;
  };

  _satellite._getDomainPeriods.version = '1.0';

}());


/*******************************************************************************
* _murmurHash3(b): Generate a hash using murmurhash3 algorithm.
*
* Version: 1.0
*
* Dependencies:
*   - (none)
* 
* Parameters:
*   - [required] value (string) - String to hash
*   - [optional] seed (integer) (default=1) - integer seed
*
* Returns:
*   - hash (string) - Hexidecimal string
*******************************************************************************/
(function () {
  'use strict';

  /**
   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
   * License (MIT)
   *
   * Copyright (c) 2011 Gary Court
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy 
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
   * copies of the Software, and to permit persons to whom the Software is 
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in 
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
   * SOFTWARE
   * 
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   * 
   * @param {string} key ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash 
   */
  function murmurhash3_32_gc(key, seed) {
    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
    
    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;
    
    while (i < bytes) {
      k1 = 
        ((key.charCodeAt(i) & 0xff)) |
        ((key.charCodeAt(++i) & 0xff) << 8) |
        ((key.charCodeAt(++i) & 0xff) << 16) |
        ((key.charCodeAt(++i) & 0xff) << 24);
      ++i;
      
      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

      h1 ^= k1;
          h1 = (h1 << 13) | (h1 >>> 19);
      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }
    
    k1 = 0;
    
    switch (remainder) {
      case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16; //jshint ignore:line
      case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8; //jshint ignore:line
      case 1: k1 ^= (key.charCodeAt(i) & 0xff);
      
      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
    }
    
    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
  }

  _satellite._murmurHash3 = function (value, seed) {
    seed = seed || 1; // default to 1
    return murmurhash3_32_gc(value, seed).toString(16).toUpperCase();
  };

  _satellite._murmurHash3.version = '1.0';

}());


/*******************************************************************************
* _spiderWeb: A plugin for capturing any page event and track it automatically.
* 
*   Version: 1.0
*
*   Dependencies:
*     _satellite._murmurHash3 - a hashing function
* 
*   Methods:
*     __________________________________________________________________________
*     _spiderWeb(webConfigs): Initialize spiderWeb plugin with webs
*       (configuration objects).
*       
*       Parameters: 
*         - [required] webConfigs (array) - An array of configuration objects.
*           Each object in the array should conform to config parameter 
*           described in _spiderWeb.addWeb.
*       Returns: 
*         - status (boolean) = true if successfully configured, false if 
*           unsuccessful
*
*     __________________________________________________________________________
*     _spiderWeb.addWeb(config): Adds another web configuration to the list of
*       webs (configuration objects).
*       
*       Parameters:
*         - [required] config (object) - a config object with the following 
*           properties:
*           - [optional] callback (function) |default = null| - optional
*             callback to call when the click occurs.  Callback should be in the
*             form: function (info, event) {} Parameters: 
*             - information (object) - An object with the following properties
*               - location (object) - object with properties:
*                 - href (string) - window.location.href
*                 - protocol (string) - window.location.protocol
*                 - host (string) - window.location.host
*                 - hostname (string) - window.location.hostname.toLowerCase()
*                 - port (string) - window.location.port
*                 - pathname (string) - window.location.pathname
*                 - search (string) - window.location.search
*                 - hash (string) - window.location.hash
*               - id (string) - alternate id 1
*               - id1 (string) - alternate id 1
*               - id2 (string) - alternate id 1
*               - id3 (string) - alternate id 1
*               - id4 (string) - alternate id 1
*               - id5 (string) - alternate id 1
*               - pageName (string) - s.pageName
*               - destination (object) - destination/href of the closest 
*                   anscestor A or AREA tag
*                 - href (string) - element.href
*                 - protocol (string) - element.protocol
*                 - host (string) - element.host
*                 - hostname (string) - element.hostname.toLowerCase()
*                 - port (string) - element.port
*                 - pathname (string) - element.pathname
*                 - search (string) - element.search
*                 - hash (string) - element.hash
*               - element (object) - An object representing parts of the element 
*                 - nodeName: element.nodeName
*                 - tagName: element.tagName
*                 - target: element.target
*               - linkElement (Element object) - The actual object if it is a 
*                 link, or the nearest parent link element (A or AREA) 
*               - shouldNavigate (boolean) - An indication as to whether this 
*                 click will lead to navigation of the browser in some way
*               - isExitLink (boolean) - True if it is an exit link, false 
*                 otherwise
*             - event (Event object) - The DOM event object that was clicked
*           - [optional] root (Element object) |default = 
*             document.body| - A DOM Element object on which we should stop DOM
*             traversal backwards.  This is for generating the main unique Id.
*             It also affects how much of the page you will track.
*           - [optional] s (AppMeasurement object) |default = null| - The s
*             object to use to get values like s.pageName and other variables.
*           - [optional] keys (array) |default = []| - An array of format 
*             templates to use for generating a list of keys.
*       
*       Returns: 
*         - status (boolean) - true if successfully added, false if unsuccessful
*     __________________________________________________________________________
*     _spiderWeb.getInformationForElement(element, web, e): Gets all of the 
*       information available for a specific element.  Additional can pass web
*       configuration object similar to what is specified above.
*       
*       Parameters: 
*         - [required] element (Element object) - The DOM Element for which you 
*           want to generate an id.
*         - [optional] web (object) |default = document.body| - a config object 
*           with the following properties:
*           - [optional] root (Element object) |default = document.body| - A DOM
*             Element object on which we should stop DOM traversal backwards.  
*             This is for generating the main unique Id.  It also affects how 
*             much of the page you will track.
*           - [optional] s (AppMeasurement object) |default = null| - The s
*             object to use to get values like s.pageName and other variables.
*         - [optional] e (Event object) |default = null| - An event object to
*           get information like coordinates of a click, or name of the event,
*           etc.
*
*       Returns: 
*         - information (object) - An object containing information about the 
*           element including the above information.
*
*     __________________________________________________________________________
*     _spiderWeb.generateKey(format, information): Generates a unique key given
*       an information object.
*       
*       Parameters: 
*         - [required] format (string) - A string template for replacing items
*           in the information object.  
*            Example: "{{location.hostname}}-{{location.pathname}}"
*         - [required] information (object) - An information object obtained by
*           getInformationForElement method.
*
*       Returns: 
*         - key (string) - A key string with the given information replaced into
*            the format template string.
*
*     __________________________________________________________________________
*     _spiderWeb.getUniqueIdForElement(element, root): Generates a unique id for
*       the node/element.  Allows an optional root parameter to know how far up
*       in the DOM tree structure to generate the id.
*       
*       Parameters: 
*         - [required] element (Element object) - The DOM Element for which you 
*           want to generate an id.
*         - [optional] root (Element object) |default = document.body| - A DOM 
*           Element object on which we should stop DOM traversal backwards.  
*           This is for generating the main unique Id.  It also affects how 
*           much of the page you will track.
*
*       Returns: 
*         - id (string) - The generated id if the element is a descendent of
*           the root, or a blank string '' if not.
*
*     __________________________________________________________________________
*     _spiderWeb.getSelectorForUniqueId(id): Generates the css3 selector given
*       a unique id.  
*       
*       Parameters: 
*         - [required] id (string) - The unique id of the element you would like
*           to select.
*
*       Returns: 
*         - selector (string) - The css3 selector string that you could use to 
*           uniquely select that element.
*
*     __________________________________________________________________________
*     _spiderWeb.getElementByUniqueId(id, root): Finds the element in the DOM by
*       the generated unique id. Allows for optional root parameter to tell the
*       method where to start searching for the id.
*       
*       Parameters: 
*         - [required] id (string) - The uniqueID if the element you want 
*           to find.
*         - [optional] root (Element object) |default = document.body| - A DOM 
*           Element object on which we should stop DOM traversal backwards.  
*           This is for generating the main unique Id.  It also affects how 
*           much of the page you will track.
*       
*       Returns: 
*         - element (Element object) - The DOM Element that corresponds to the 
*           id, or null if it cannot resolve the id.
*
*     __________________________________________________________________________
*     _spiderWeb.getLinkElement(element, root): Gets the nearest anscestor that
*       is either an A or AREA node.
*       
*       Parameters: 
*         - [required] element (Element object) - Any DOM object for which you 
*           would like to find its corresponding anscestor link element or 
*           itself if it is a link element
*         - [optional] root (Element object) |default = document.body| - A DOM 
*           Element object on which we should stop DOM traversal backwards.  
*           This is for figuring out if the element is actually a child of the
*           root or not.
*       
*       Returns: 
*         - linkElement (Element object) - The DOM Element that corresponds to 
*           the ancestor link object
*
*     __________________________________________________________________________
*     _spiderWeb.isExitLink(href):  Checks whether the give url/href is an exit
*       link given a list of linkInternalFilters and linkExternalFilters.
*       
*       Parameters: 
*         - [required] href (string) - A string representing a url or link 
*       
*       Returns: 
*         - isExitLink (booleam) - true if this link is considered an exit link,
*           false if not considered an exit link
*
*     __________________________________________________________________________
*     _spiderWeb.shouldNavigate(linkElement): Tells whther the given link object
*       should cause a browse navigation.
*       
*       Parameters: 
*         - [required] linkElement (Element object) - Specifically a DOM link 
*           object (A or AREA) to check
*       
*       Returns: 
*         - shouldNavigate (boolean) - true if the link should cause the window
*           to navigate in some way (either through popup, through own window,
*           or another tab)
*
*     __________________________________________________________________________
*     _spiderWeb.flatten(object): Flattens a multi-level objects down to a 
*       single level object.
*       
*       Parameters: 
*         - [required] object (object) - An object to flatten (cannot have 
*           recursive references)
*       
*       Returns: 
*         - newObject (object) - A new object that is flat.
* 
*     __________________________________________________________________________
*     _spiderWeb.spider(event): The callback from a number of events that is
*       used to loop through each of the webs and provide the information back
*       to the callbacks for further handling.  Used internally.
*       
*       Parameters: 
*         - [required] event (Event object) - An event object.
*       
*       Returns: 
*         undefined
* 
*******************************************************************************/
(function () {
  'use strict';

  var w = window,
    d = document,
    b = d.body,
    version = '1.0',
    map = {
      //'<!--...-->': '',
      //'<!DOCTYPE>': '',
      //------------------------------ a ------------------------------
      'a': 'a',
      'abbr': 'ab',
      'acronym': 'ac',
      'address': 'ad',
      'altglyph': 'ag',
      'altglyphdef': 'agd',
      'altglyphitem': 'agi',
      'animate': 'an',
      'animatecolor': 'anc',
      'animatemotion': 'anm',
      'animatetransform': 'ant',
      'applet': 'ap',
      'area': 'r',
      'article': 'c',
      'aside': 'A',
      'audio': 'au',
      //------------------------------ b ------------------------------
      'b': 'b',
      'base': 'bs',
      'basefont': 'ba',
      'bdi': 'bd',
      'bdo': 'bo',
      'bgsound': 'bg',
      'big': 'bi',
      //'blink': '',
      'blockquote': 'bl',
      //'body': '',
      'br': 'br',
      'button': 'B',
      //------------------------------ c ------------------------------
      'canvas': 'ca',
      'caption': 'cp',
      'center': 'ce',
      'cite': 'C',
      'circle': 'ci',
      'clippath': 'ch',
      'code': 'co',
      'col': 'cl',
      'colgroup': 'cg',
      'color-profile': 'cf',
      'content': 'ct',
      'cursor': 'cu',
      //------------------------------ d ------------------------------
      'data': 'da',
      'datalist': 'dl',
      'dd': 'y',
      'decorator': 'dc',
      'defs': 'dE',
      'del': 'de',
      'desc': 'ds',
      'details': 'dt',
      'dfn': 'df',
      'dialog': 'di',
      'dir': 'dr',
      'div': 'd',
      'dl': 'D',
      'dt': 'z',
      //------------------------------ e ------------------------------
      'element': 'el',
      'ellipse': 'eL',
      'em': 'E',
      'embed': 'eb',
      //------------------------------ f ------------------------------
      'feblend': 'feb',
      'fecolormatrix': 'fcm',
      'fecomponenttransfer': 'fct',
      'fecomposite': 'fc',
      'feconvolvematrix': 'fcx',
      'fediffuselighting': 'fdl',
      'fedisplacementmap': 'fdm',
      'fedistantlight': 'fd',
      'feflood': 'ff',
      'fefunca': 'ffa',
      'fefuncb': 'ffb',
      'fefuncg': 'ffg',
      'fefuncr': 'ffr',
      'fegaussianblur': 'fgb',
      'feimage': 'fei',
      'femerge': 'fem',
      'femergenode': 'fen',
      'femorphology': 'fef',
      'feoffset': 'fe',
      'fepointlight': 'fpl',
      'fespecularlighting': 'fsl',
      'fespotlight': 'fSl',
      'fetile': 'fet',
      'feturbulence': 'ftb',
      'fieldset': 'J',
      'figcaption': 'fg',
      'figure': 'fi',
      'filter': 'fl',
      'font': 'fo',
      'font-face': 'ffc',
      'font-face-format': 'fff',
      'font-face-name': 'ffn',
      'font-face-src': 'ffs',
      'font-face-uri': 'ffu',
      'footer': 'f',
      'foreignobject': 'fro',
      'form': 'F',
      'frame': 'fr',
      'frameset': 'ft',
      //------------------------------ g ------------------------------
      'g': 'g',
      'glyph': 'gl',
      'glyphref': 'gr',
      //------------------------------ h ------------------------------
      'h1': 'ha',
      'h2': 'hb',
      'h3': 'hc',
      'h4': 'hd',
      'h5': 'he',
      'h6': 'hf',
      //'head': '',
      'header': 'h',
      'hgroup': 'hg',
      'hkern': 'hk',
      'hr': 'hr',
      //'html': '',
      //------------------------------ i ------------------------------
      'i': 'i',
      'iframe': 'if',
      'image': 'im',
      'img': 'I',
      'input': 'j',
      'ins': 'in',
      'isindex': 'is',
      //------------------------------ j ------------------------------
      //------------------------------ k ------------------------------
      'kbd': 'kb',
      'keygen': 'ke',
      //------------------------------ l ------------------------------
      'label': 'e',
      'legend': 'L',
      'li': 'l',
      'line': 'li',
      'lineargradient': 'lg',
      'link': 'lk',
      'listing': 'ls',
      //------------------------------ m ------------------------------
      'main': 'm',
      'map': 'M',
      'mark': 'mr',
      'marker': 'mk',
      'marquee': 'mq',
      'mask': 'ms',
      'menu': 'me',
      'menuitem': 'mi',
      //'meta': '',
      'metadata': 'md',
      'meter': 'mt',
      'missing-glyph': 'mg',
      'mpath': 'mp',
      //------------------------------ n ------------------------------
      'nav': 'n',
      'nobr': 'no',
      'noframes': 'nf',
      'noscript': 'ns',
      //------------------------------ o ------------------------------
      'object': 'ob',
      'ol': 'o',
      'optgroup': 'op',
      'option': 'O',
      'output': 'ou',
      //------------------------------ p ------------------------------
      'p': 'p',
      'param': 'pa',
      'path': 'ph',
      'pattern': 'pe',
      'picture': 'pi',
      'plaintext': 'pt',
      'polygon': 'po',
      'polyline': 'pl',
      'pre': 'pr',
      'progress': 'pg',
      //------------------------------ q ------------------------------
      'q': 'q',
      //------------------------------ r ------------------------------
      'radialgradient': 'rg',
      'rect': 're',
      'rp': 'rp',
      'rt': 'rt',
      'ruby': 'ru',
      //------------------------------ s ------------------------------
      's': 's',
      'samp': 'sa',
      'script': 'sc',
      'section': 'S',
      'select': 'N',
      'set': 'se',
      'shadow': 'sh',
      'small': 'sm',
      'source': 'so',
      'spacer': 'sp',
      'span': 'P',
      'stop': 'sT',
      'strike': 'st',
      'strong': 'sr',
      'style': 'St',
      'sub': 'sB',
      'summary': 'su',
      'sup': 'sP',
      'svg': 'G',
      'switch': 'sw',
      'symbol': 'sy',
      //------------------------------ t ------------------------------
      'table': 't',
      'tbody': 'v',
      'td': 'T',
      'template': 'te',
      'text': 'tx',
      'textarea': 'k',
      'textpath': 'tp',
      'tfoot': 'x',
      'th': 'H',
      'thead': 'w',
      'time': 'ti',
      'title': 'Ti',
      'tr': 'R',
      'tref': 'tr',
      'track': 'tc',
      'tspan': 'ts',
      'tt': 'tt',
      //------------------------------ u ------------------------------
      'u': 'u',
      'ul': 'U',
      'use': 'us',
      //------------------------------ v ------------------------------
      'var': 'va',
      'video': 'vi',
      'view': 'vw',
      'vkern': 'vk',
      //------------------------------ w ------------------------------
      'wbr': 'wb',
      //------------------------------ x ------------------------------
      'xmp': 'xm'
      //------------------------------ y ------------------------------
      //------------------------------ z ------------------------------
    },
    reverseMap = {}, // built later
    numberToLetterMap = {
      '1': 'a',
      '2': 'b',
      '3': 'c',
      '4': 'd',
      '5': 'e',
      '6': 'f',
      '7': 'g',
      '8': 'h',
      '9': 'i',
      '0': 'j'
    },
    reverseNumberToLetterMap = {
      'a': '1',
      'b': '2',
      'c': '3',
      'd': '4',
      'e': '5',
      'f': '6',
      'g': '7',
      'h': '8',
      'i': '9',
      'j': '0',
    },
    i, l,
    key,
    name,
    eventType,
    events = [
      // 'blur', 
      // 'change',
      'click',
      // 'focus',
      'keypress'//,
      // 'select',
      // 'submit'
    ];

  for (name in map) {
    if (map.hasOwnProperty(name)) {
      key = map[name];
      reverseMap[key] = name;
    }
  }

  var _spiderWeb = function (webConfigs) {
    var i, l;

    if (!webConfigs ||
      Object.prototype.toString.call(webConfigs) !== '[object Array]') {
      return false;
    }

    for (i = 0, l = webConfigs.length; i < l; i++) {
      _spiderWeb.addWeb(webConfigs[i]);
    }
  };
  _satellite._spiderWeb = _spiderWeb;

  _spiderWeb.webs = [];

  _spiderWeb.addWeb = function (config) {
    // required
    if (!config || typeof config !== 'object') {
      return false;
    }

    if (typeof config.callback === 'undefined') {
      // do nothing...we don't care...
    }

    // root
    if (!config.root) {
      config.root = d.body;
    }

    // s object
    if (!config.s) {
      config.s = null;
    }

    // keys
    if (!config.keys) {
      config.keys = [];
    }

    if (config) {
      _spiderWeb.webs.push(config);
      return true;
    } else {
      return false;
    }
  };

  _spiderWeb.getInformationForElement = function (node, web, e) {
    var linkElement = null,
      id = '',
      idAttribute = '',
      loc = w.location,
      information = {
        location: {
          href: loc.href,
          protocol: loc.protocol,
          p: (
            (loc.protocol === 'https:') ? 's' : 
            (loc.protocol === 'http:' ? 'h' : 'o')
          ),
          host: loc.host,
          hostname: loc.hostname.toLowerCase(),
          port: loc.port,
          pathname: loc.pathname,
          search: loc.search,
          hash: loc.hash,
        },
        id: '',
        id1: '',
        id2: '',
        id3: '',
        id4: '',
        id5: '',
        id6: '',
        id7: '',
        id8: '',
        id9: '',
        node: node,
        element: node,
        isExitLink: false,
        shouldNavigate: false,
        hash: {
          innerText: ''
        }
      },
      root = (web && web.root) ? web.root : undefined,
      j, m,
      format,
      evaluate = 'evaluate',
      hash = 'hash',
      //truncate = 'truncate',
      defaultKeyConfig = {
        method: 'custom',
        before: '',
        delimiter: '|',
        after: '',
        replace: {
          '|': ':'
        },
        template: [{
          type: evaluate,
          name: 'location.p',
          max: 1
        }, {
          type: evaluate,
          name: 'location.hostname',
          max: 60,
          maxExceeded: hash
        }, {
          type: evaluate,
          name: 'location.pathname',
          max: 50,
          maxExceeded: hash
        }, {
          type: evaluate,
          name: 'location.search',
          max: 20,
          maxExceeded: hash
        }, {
          type: evaluate,
          name: 'location.hash',
          max: 31,
          maxExceeded: hash
        }, {
          type: evaluate,
          name: 'id',
          max: 70,
          maxExceeded: hash
        }, {
          type: hash,
          name: 'destination.href',
          max: 8
        }, {
          type: hash,
          name: 'node.innerText',
          max: 8
        }]
      };

    //------------------------------------------------------------------------
    // element specific
    //------------------------------------------------------------------------
    // first generate all ids (primary and aleternate ids)
    // unique id
    id = _spiderWeb.getUniqueIdForElement(node, root);
    information.id = id;

    // alternate id 1
    idAttribute = node.getAttribute('id');
    information.id1 = idAttribute ? idAttribute : '';

    // alternate id 2
    // alternate id 3
    // alternate id 4
    // alternate id 5

    // selector
    information.selector = _spiderWeb.getSelectorForUniqueId(id);

    // linkElement
    linkElement = _spiderWeb.getLinkElement(node, root);
    if (linkElement) {
      information.linkElement = linkElement;

      // destination
      information.destination = {
        href: linkElement.href,
        protocol: linkElement.protocol,
        p: (
          (linkElement.protocol === 'https:') ? 's' : 
          (linkElement.protocol === 'http:' ? 'h' : 'o')
        ),
        host: linkElement.host,
        hostname: linkElement.hostname.toLowerCase(),
        port: linkElement.port,
        pathname: linkElement.pathname,
        search: linkElement.search,
        hash: linkElement.hash
      };

      // isExitLink
      if (web && web.s) {
        information.isExitLink = _spiderWeb.isExitLink(linkElement.href, 
          web.s.linkInternalFilters, web.s.linkExternalFilters);
      } else {
        information.isExitLink = _spiderWeb.isExitLink(linkElement.href);
      }

      // shouldNavigate
      information.shouldNavigate = _spiderWeb.shouldNavigate(linkElement);
    }

    //------------------------------------------------------------------------
    // web specific
    //------------------------------------------------------------------------
    if (web) {
      if (web.s) {
        information.s = web.s;
      }
    }

    //------------------------------------------------------------------------
    // event specific
    //------------------------------------------------------------------------
    if (e) {
      information.event = e;
    }

    //------------------------------------------------------------------------
    // generate keys after all information is done
    //------------------------------------------------------------------------
    // generate keys very last since now we have information
    information.key = _spiderWeb.generateKey(defaultKeyConfig, information);

    if (web && web.keys && web.keys.length > 0) {
      information.keys = [];
      for (j = 0, m = web.keys.length; j < m; j++) {
        format = web.keys[j];
        information.keys[j] = _spiderWeb.generateKey(format, information);
      }
    }

    return information;
  };

  _spiderWeb.evaluate = function (name, information) {
    var path, 
      i, l,
      value, 
      type;

    path = name.split('.');

    for (i = 0, l = path.length; i < l; i++) {
      if (i === 0) {
        value = information[path[i]];
      } else {
        value = value[path[i]];
      }

      if (typeof value === 'undefined' || value === null) {
        value = '';
        break;
      }
    }

    type = typeof value;
    if (type === 'string' || type === 'number' || type === 'boolean' ) {
      value = value + ''; // convert to string
    } else {
      value = '';
    }

    return value;
  };

  _spiderWeb.generateKey = function (format, information) {
    var i, l, templateItem, config, piece, replace, replaceWith,
      pieces = [], 
      key = '';

    if (typeof format === 'string') {
      return format.replace(/\{\{(.*?)\}\}/g, function (match, key) {
        return _spiderWeb.evaluate(key, information);
      });
    } else {
      config = format;

      if (!config.before) {
        config.before = '';
      }

      if (!config.delimiter) {
        config.delimiter = '';
      }

      if (!config.after) {
        config.after = '';
      }

      if (
        !config.method || 
        config.method === 'default' || 
        config.method === 'custom'
      ) {
        for (i = 0, l = config.template.length; i < l; i++) {
          templateItem = config.template[i];
          
          if (templateItem.type === 'evaluate' && templateItem.name) {
            piece = _spiderWeb.evaluate(templateItem.name, information);
          } else if (templateItem.type === 'hash' && templateItem.name) {
            piece = _satellite._murmurHash3(
              _spiderWeb.evaluate(templateItem.name, information));
          } else if (templateItem.type === 'string' && templateItem.string) {
            piece = templateItem.string;
          }

          // check length and handle
          if (templateItem.max && piece.length > +templateItem.max) {
            if (templateItem.maxExceeded === 'hash') {
              piece = _satellite._murmurHash3(piece);
            } else if (templateItem.maxExceeded === 'truncate') {
              piece = piece.substring(0, +templateItem.max);
            }
          }

          if (!templateItem.before) {
            templateItem.before = '';
          }

          if (!templateItem.after) {
            templateItem.after = '';
          }

          piece = templateItem.before + piece + templateItem.after;

          if (config.replace) {
            for (replace in config.replace) {
              replaceWith = config.replace[replace];
              while (piece.indexOf(replace) !== -1) {
                piece = piece.replace(replace, replaceWith);
              }
            }
          }

          pieces.push(piece);
        }

        key = config.before + pieces.join(config.delimiter) + config.after;
      } else if (format.method === 'priority') {
        // priority
      }

      return key;
    }
  };

  _spiderWeb.getUniqueIdForElement = function (element, root) {
    var parent = null,
      position = 0,
      child = null,
      tagName = '',
      id = '',
      isDescendant = false,
      i, l;

    root = root || d.body;

    // find out if element sits under root
    parent = element.parentNode;
    while (parent && parent !== d) {
      if (parent === root) {
        isDescendant = true;
        break;
      }
      parent = parent.parentNode;
    }

    if (!isDescendant) {
      return '';
    }

    // generate the id
    while (element !== root) {
      tagName = element.tagName.toLowerCase();
      parent = element.parentNode;
      position = 0;

      // figure out the position
      for (i = 0, l = parent.children.length; i < l; i++) {
        child = parent.children[i];

        if (tagName == child.tagName.toLowerCase()) {
          position++;
        }
        if (child === element) {
          break;
        }
      }

      // minify the id
      if (map[tagName]) {
        tagName = map[tagName];
      } else {
        // replace all numbers in the tag to letters (numbers are special)
        tagName = tagName.replace(/[0-9]/g, function (match) {
          return '^' + numberToLetterMap[match];
        }); // jshint ignore:line
        // add a string to flag it as a custom tag
        tagName = '{' + tagName + '}';
      }

      if (position) {
        id = tagName + position + id;
      } else {
        throw(new Error('An error occurred in generating uniqueId for element: ' + tagName));
      }

      element = parent;
    }

    return id;
  };

  _spiderWeb.getSelectorForUniqueId = function (id) {
    var idSplit = [],
      peice = '',
      tagName = '',
      position = 0,
      selectorArray = ['body'],
      selector,
      i, l;

    if (typeof id === 'string') {
      id = id.replace(/([0-9]+)/g, function (match, group1) {
        return group1 + ' ';
      });

      idSplit = id.split(' ');

      for (i = 0, l = idSplit.length; i < l; i++) {
        peice = idSplit[i];
        
        if (peice === '') {
          continue;
        }

        tagName = peice.replace(/[0-9]+/g, '');
        position = peice.replace(/[^0-9]+/g, '');

        if (reverseMap[tagName]) {
          tagName = reverseMap[tagName];
        } else {
          // replace letters back with numbers
          tagName = tagName.replace(/\^([a-j])/g, function (match, group1) {
            return reverseNumberToLetterMap[group1];
          }); // jshint ignore:line
          // remove the flag if it is a custom tag
          if (tagName.indexOf('{') !== -1) {
            tagName = tagName.replace('{', '');
          }
          if (tagName.indexOf('}') !== -1) {
            tagName = tagName.replace('}', '');
          }
        }

        selectorArray.push(tagName + ':nth-of-type(' + position + ')');
      }

      selector = selectorArray.join(' > ');

      return selector;
    }
  };

  _spiderWeb.getElementByUniqueId = function (id, root) {
    var idSplit = [],
      peice = '',
      tagName = '',
      position = 0,
      children = [],
      child = null,
      count = 0,
      element = root || d.body,
      i, l, j, jl;

    if (typeof id === 'string') {
      id = id.replace(/([0-9]+)/g, function (match, group1) {
        return group1 + ' ';
      });

      idSplit = id.split(' ');

      for (i = 0, l = idSplit.length; i < l; i++) {
        peice = idSplit[i];
        
        if (peice === '') {
          continue;
        }

        tagName = peice.replace(/[0-9]+/g, '');
        position = peice.replace(/[^0-9]+/g, '');

        if (reverseMap[tagName]) {
          tagName = reverseMap[tagName];
        } else {
          // replace letters back with numbers
          tagName = tagName.replace(/\^([a-j])/g, function (match, group1) {
            return reverseNumberToLetterMap[group1];
          }); // jshint ignore:line
          // remove the flag if it is a custom tag
          if (tagName.indexOf('{') !== -1) {
            tagName = tagName.replace('{', '');
          }
          if (tagName.indexOf('}') !== -1) {
            tagName = tagName.replace('}', '');
          }
        }

        children = element.children;
        count = 0;

        for (j = 0, jl = children.length; j < jl; j++) {
          child = children[j];
          if (tagName === child.tagName.toLowerCase()) {
            count++;
          }
          if ((count + '') === (position + '')) {
            element = child;
            break;
          }
        }

        if (element) {
          //console.log(element);
        } else {
          // fail silently if there is an error
          return null;
        }
      }

      return element;
    }
  };

  _spiderWeb.getLinkElement = function (element, root) {
    var parent = null,
      tagName = '',
      linkElement = null,
      isDescendant = false;

    root = root || d.body;

    // find out if element sits under root
    parent = element.parentNode;
    while (parent && parent !== d) {
      if (parent === root) {
        isDescendant = true;
        break;
      }
      parent = parent.parentNode;
    }

    if (!isDescendant) {
      return '';
    }

    // generate the id
    while (element !== root) {
      tagName = element.tagName.toLowerCase();
      parent = element.parentNode;

      if ((tagName === 'a' || tagName === 'area') && (element.href)) {
        linkElement = element;
        break;
      }

      element = parent;
    }

    return linkElement;
  };

  _spiderWeb.isExitLink = function (href, linkInternalFilters, linkExternalFilters) {
    var filterList = null,
      filterNum,
      useExternalFilters = 0,
      matchedFilter = 0,
      filter,
      isExit = false;

    // if we don't have any linkInternalFilters, set to hostname
    if (!linkInternalFilters) {
      linkInternalFilters = w.location.hostname;
    }

    // if we have a list of externalFilters
    if (linkExternalFilters) {
      filterList = linkExternalFilters.toLowerCase().split(',');
      useExternalFilters = 1;
    } else if (linkInternalFilters) {
      filterList = linkInternalFilters.toLowerCase().split(',');
    }

    // make sure we have a filter list
    if (filterList) {
      // go through all filters first
      for (filterNum = 0; filterNum < filterList.length; filterNum++) {
        filter = filterList[filterNum];
        if (href.indexOf(filter) >= 0) {
          matchedFilter = 1;
        }
      }

      // if we found a match
      if (matchedFilter) {
        // if we used the linkExternalFilters
        if (useExternalFilters) {
          isExit = true;
        }
      // if we didn't find a match
      } else {
        // if we used the linkInternalFilters
        if (!useExternalFilters) {
          isExit = true;
        }
      }
    }

    return isExit;
  };

  _spiderWeb.shouldNavigate = function (linkElement) {
    // only worry about link tracking right now for A and AREA tags (those that
    // have a href)
    // if we don't have an href, we aren't navigating
    if (linkElement && linkElement.href) {
      // if we are dealing with an about link, we aren't navigating
      if (linkElement.href.indexOf('about:') === 0) {
        return false;
      }

      // if we are dealing with an opera link, we aren't navigating
      if (linkElement.href.indexOf('opera:') === 0) {
        return false;
      }

      // if we are dealing with a javascript link, we aren't navigating
      if (linkElement.href.indexOf('javascr'+'ipt:') === 0) { // jshint ignore:line
        return false;
      }

      // if the target is the same window
      if (
        (!linkElement.target) ||
        (linkElement.target == '_self') || 
        (linkElement.target == '_top') || 
        (linkElement.target == '_parent') || 
        (
          (w.name) && 
          (linkElement.target == w.name)
        )
      ) {
        // if we think the link *may* cause a refresh
        if (linkElement.hash) {
          // if the link is the same as the current page, we guess it won't
          // cause a refresh
          if ((linkElement.href === w.location.href) || (
            linkElement.protocol === w.location.protocol &&
            linkElement.host === w.location.host &&
            linkElement.pathname === w.location.pathname &&
            linkElement.search === w.location.search
          )) {
            return false; // will not cause any reresh
          // otherwise, it will probably cause a refresh
          } else { 
            return true;
          }
        // if the link for sure will cause a refresh
        } else {
          return true;
        }
      // if the target is a different window (_blank)
      } else {
        return true;
      }

    } else {
      return false;
    }
  };

  _spiderWeb.spider = function (e) {
    // if (e && e['s_fe_' + s._in]) {
    //   return;
    // }

    var target = e.target || e.srcElement,
      node = target,
      web,
      i, l,
      information;

    // loop through each of the webs and figure out what they want to catch
    for (i = 0, l = _spiderWeb.webs.length; i < l; i++) {
      web = _spiderWeb.webs[i];

      information = _spiderWeb.getInformationForElement(node, web, e);

      if (web.callback && 
        typeof web.callback === 'function') {
        web.callback(information, e);
      }
    }
  };

  for (i = 0, l = events.length; i < l; i++) {
    eventType = events[i];

    if (document.addEventListener) {
      document.addEventListener(eventType, _spiderWeb.spider, true);
    } else if (document.attachEvent) {
      document.attachEvent('on' + eventType, _spiderWeb.spider);
    }
  }

  _spiderWeb.version = version;

}());


/*******************************************************************************
* _beforeUnload: A plugin for binding to the beforeunload event.  To know when 
*   the page session is over.
* 
*   Version: 1.1
*     1.1 - added both pagehide and beforeunload listeners if available.  This
*       makes sure that we end up calling the callback no matter which event
*       happens.  And we only call it once.
*     1.2 - Added functionality to prioritize when things fire
*
*   Dependencies:
*     none
* 
*   Methods:
*     __________________________________________________________________________
*     _beforeUnload(callback): Attach a listener to the beforeunload event
*       
*       Parameters: 
*         - [required] callback (function) - A function to call before document
*           unloads
*         - [optional] order (integer) - An integer to indicate the order in 
*           which these callbacks should be called.  This comes in handy when
*           there are times you can't attach a listener before other listeners
*           but need to handle it before the others.  The detault is 1 and 
*           it increments by 1 each time you call _beforeUnload.
*
*       Returns: 
*         - status (boolean) = true if successfully bound, false if 
*           unsuccessful
* 
*******************************************************************************/
(function () {
  'use strict';

  var
    w = window,
    version = '1.2';

  var
    _beforeUnload,
    handle,
    handled = false,
    handlers = [];

  // beforeUnload API
  _beforeUnload = function (callback, order) {

    // default to order of 1 and up
    order = order || _beforeUnload.currentOrder++;

    // push onto the array
    handlers.push({
      callback: callback,
      order: order
    });

    // then sort the array by order
    // Note: we do this here in case a handler callback tries to push another
    // handler on the stack.  It should be prioritized immediately not only
    // once.
    handlers.sort(function (a, b) {
      if (a.order < b.order) {
        return -1;
      } else {
        return 1;
      }
    });
  };

  // the currentOrder
  _beforeUnload.currentOrder = 1;
    
  // handle internal function that gets called when pagehide, beforeunload, or
  // onbeforeunload gets called
  handle = function (evt) {
    var
      i,
      handler;

    // although we attach many listeners, we should only call this 1 time
    if (!handled) {
      handled = true;

      for (i = 0; i < handlers.length; i++) {
        handler = handlers[i];

        // try to call
        try {
          handler.callback(evt);
        } catch (err) {}
      }

    }
  };

  // initialize all of the listeners

  // check if browser supports event APIs
  if (w.addEventListener) {
    
    // check if browser supports pagehide events and attach listener
    if ('onpagehide' in w) {
      w.addEventListener('pagehide', handle);
    }

    // attach on beforeunload as well
    // Note: even if pagehide get's called, we will only call the callback
    // one time
    w.addEventListener('beforeunload', handle);
    // fallback
    w.addEventListener('unload', handle);

  // if it doesn't, use the attachEvent API (IE) and attach to beforeunload
  // event
  } else if (w.attachEvent) {
    w.attachEvent('onbeforeunload', handle);
    // fallback
    w.attachEvent('onunload', handle);
  }

  _satellite._beforeUnload = _beforeUnload;

  _beforeUnload.version = version;

}());

/*******************************************************************************
* _getPercentPageViewed(pageId): Get initial and maximum percent viewed for the 
*   prior page, now with expanded support for mobile devices.  Return percent  
*   page viewed of the prior page viewÂ and initializes data collection for the 
*   current page view.Â 
*
* Version: 3.0
*   - 1.0 - Branched from Adobe Analytics Plugin getPercentpageViewed 
*     version 1.71.
*   - 1.1 - Made change to help with 'undefined' error when calling
*     getPercentPageViewed.
*   - 2.0 - Synced with verson 1.74 of getPercentPageViewed and worked on some
*     performance improvements and refactoring
*   - 3.0 - Launch compatible.
*
* Dependencies:
*   - _satellite._getDomain - Plugin for getting top level domain.
* 
* Parameters:
*   pageId (optional) = Current page identifier, typically s.pageName.  If pageId 
*     is "-" or not specified, s.pageName is used as the page identifier
*   cookieName (optional) = Cookie name for the percent page viewed
*
* Returns:
*   If there was not a previous page view in this visit, an empty string is 
*   returned.  If pid is "-", or unspecified, an integer containing the last 
*   page's maximum percent viewed is returned.  Otherwise, an array is 
*   returned with the following elements:
*     array[0] â€“ Page ID
*     array[1] â€“ Maximum percent viewed
*     array[2] â€“ Initial percent viewed
*     array[3] â€“ Maximum vertical pixels viewed
*     array[4] â€“ Viewport width in CSS pixels
*     array[5] â€“ Viewport height in CSS pixels
*     array[6] â€“ Display width in real pixels (reflecting orientation)
*     array[7] â€“ Display height in real pixels (reflecting orientation)
*     array[8] â€“ Final pixel density
*     array[9] â€“ Device orientation, set to one of the following text strings:
*       "L" â€“ Landscape (rotation did not occur)
*       "P" â€“ Portrait (rotation did not occur)
*******************************************************************************/
(function () {
  'use strict';

  // TODO: Currently there is a limitation to how many different clients or
  // cookies we can handle.  We can only do one right now.  The enhancement
  // would be to change this so that we could use multiple cookies.

  var version = '3.0';
  // var percentPageViewedInfoCurrent,
  //   percentPageViewedInfoPrevious,
  //   getPercentpageViewedCalled = false;

  var 
    s = _satellite,
    cookie = _satellite.cookie,
    w = window,
    d = document,
    percentPageViewedInfoCurrent = {},
    percentPageViewedInfoPrevious = {},
    initialPercentPageViewed,
    HUNDRED = 100,
    M = Math,
    calculate = function () {
      var body = d.body,
        documentElement = d.documentElement,
        windowScreen = w.screen || 0,
        scrollHeight = 'scrollHeight',
        offsetHeight = 'offsetHeight',
        clientHeight = 'clientHeight',
        scrollTop = 'scrollTop',
        clientWidth = 'clientWidth',
        swap,
        // calculations
        pageHeight,
        viewportWidth,
        viewportHeight,
        screenWidth,
        screenHeight,
        pixelDensity,
        bottomPosition,
        percentPageViewed,
        windowOrientation,
        orientation;

      // find the pageHeight (use body if available, then documentElement)
      pageHeight = M.max(
        (body && body[scrollHeight]) || (documentElement && documentElement[scrollHeight]), 
        (body && body[offsetHeight]) || (documentElement && documentElement[offsetHeight]), 
        (body && body[clientHeight]) || (documentElement && documentElement[clientHeight] || 1)
      );

      // find the viewportWidth
      viewportWidth = 
        // first use window
        w.innerWidth || 
        // then use documentElement
        (documentElement && documentElement[clientWidth]) || 
        // then use body
        (body && body[clientWidth]) || 
        // or 1 if all else fails
        1;

      // find the viewportHeight
      viewportHeight = 
        // first use window
        w.innerHeight || 
        // then use documentElement
        (documentElement && documentElement[clientHeight]) || 
        // then use body
        (body && body[clientHeight]) || 
        // or 1 if all else fails
        1;
      
      // find the screenWidth
      screenWidth = windowScreen ? windowScreen.width : 1;

      // find the screenHeight
      screenHeight = windowScreen ? windowScreen.height : 1;

      // find the pixelDensity
      pixelDensity = M.round(HUNDRED * (w.devicePixelRatio || 1)) / HUNDRED;

      // find the current bottom of viewed page (top position in viewport plus viewport height)
      bottomPosition = viewportHeight + 
        (
          // first use document
          d.pageYOffset || 
          // then use documentElement
          (documentElement && documentElement[scrollTop]) || 
          // then use body
          (body && body[scrollTop]) || 
          // or 0 if all else fails
          0
        );

      // calculate percentPageViewed
      percentPageViewed = (pageHeight > 0 && bottomPosition > 0) ? 
        M.round(HUNDRED * bottomPosition / pageHeight) : 1;

      // set the initialPercentPageViewed if it hasn't been set
      if (!initialPercentPageViewed) {
        initialPercentPageViewed = percentPageViewed;
      }

      // find the window orientation
      windowOrientation = w.orientation;

      // normalize the oriantation
      // viewport orientation in degrees modulo 180 (0 for portrait, 90 for landscape)
      orientation = !isNaN(windowOrientation) ? 
        M.abs(windowOrientation) % 180 : 
        (viewportHeight > viewportWidth ? 0 : 90);

      if (new RegExp('(iPod|iPad|iPhone)').exec(
        navigator.userAgent || ''
      ) && orientation) {
        swap = screenWidth;
        screenWidth = screenHeight;
        screenHeight = swap;
      }

      // determine orientation 
      orientation = orientation ? 'P' : 'L';

      return [
        // 0 = page identifier
        //id,
        // 1 = max percent of page viewed
        percentPageViewed, //validate(a[1], percentPageViewed, !previousPage),
        // 2 = initial percent of page viewed
        initialPercentPageViewed, //validate(a[2], percentPageViewed, previousPage),
        // 3 = max height viewed in pixels
        bottomPosition, //validate(a[3], bottomPosition, previousPage, 1),
        // 4 = 
        viewportWidth,
        // 5
        viewportHeight,
        // 6
        screenWidth,
        // 7
        screenHeight,
        // 8
        pixelDensity,
        // 9
        orientation
      ];
    },
    validate = function (value) {
      if (value > HUNDRED) {
        value = HUNDRED;
      } else if (value < 0) {
        value = 0;
      }

      return value;
    },
    build = function (o, n) {
      o = o || [0,0,0,0,0,0,0,0,0,0];

      return [
        n[0],
        validate(M.max(o[1] || 0, n[1])),
        o[2] || 0,
        M.max(o[3] || 0, n[3]),
        n[4],
        n[5],
        n[6],
        n[7],
        n[8],
        n[9]
      ];
    },
    getCurrent = function (cookieName) {
      return percentPageViewedInfoCurrent[cookieName];
    },
    getPrevious = function (cookieName) {
      return percentPageViewedInfoPrevious[cookieName];
    },
    readPercentPageViewedInfo = function (cookieName) {
      var 
        info = cookie.get(cookieName),
        result;

      try {
        result = JSON.parse(info);
      } catch (err) {
        result = [];
      }
      
      return result;
    },
    writePercentPageViewedInfo = function (cookieName) {
      var
        attributes = {};

      // get the top level domain
      attributes.domain = _satellite._getDomain();

      try {
        cookie.set(cookieName, JSON.stringify(percentPageViewedInfoCurrent[cookieName]), attributes);
      } catch (err) {
        cookie.set(cookieName, '[]', attributes);
      }
    },
    _getPercentPageViewed = function (pageId, cookieName) {
      var id = (pageId && pageId !== '-') ? pageId : w.location.href,
        events = [
          // 'load',
          'unload',
          'scroll',
          'resize',
          'zoom',
          'keyup',
          'mouseup',
          'touchend',
          'orientationchange',
          'pan'
        ],
        i, l,
        result,
        removeEvents = function () {
          var i, l;

          // loop through each event and remove listener
          for (i = 0, l = events.length; i < l; i++) {
            if (w.removeEventListener) {
              w.removeEventListener(events[i], processEvent, false);
            } else if (w.detachEvent) {
              w.detachEvent('on' + events[i], processEvent);
            }
          }
        },
        processEvent = function (evt) {
          var info = calculate();
          
          // add id to the front of the array
          info.unshift(id);

          // merge with previous
          percentPageViewedInfoCurrent[cookieName] = build(percentPageViewedInfoCurrent[cookieName], info);

          // If we have seen 100% of the page, then stop listening since we can't view any more than that
          if (percentPageViewedInfoCurrent[cookieName][1] === HUNDRED) {
            removeEvents();
            if (_satellite.getVar('enable_performanceCookie')){
            writePercentPageViewedInfo(cookieName);
            }
          }

          // only write to the cookie on unload
          if (evt.type.toLowerCase() === 'unload') {
            if (_satellite.getVar('enable_performanceCookie')){
            writePercentPageViewedInfo(cookieName)
            }
          }
        };

      // set cookie name
      cookieName = cookieName ? cookieName : 's_ppv';

      percentPageViewedInfoPrevious[cookieName] = readPercentPageViewedInfo(cookieName);

      // loop through each event and attach listener
      for (i = 0, l = events.length; i < l; i++) {
        if (w.addEventListener) {
          w.addEventListener(events[i], processEvent, false);
        } else if (w.attachEvent) {
          w.attachEvent('on' + events[i], processEvent);
        }
      }

      // return the result
      if (percentPageViewedInfoPrevious[cookieName][0] === '') {
        result = '';
      } else {
        if (!pageId || pageId === '-') {
          result = percentPageViewedInfoPrevious[cookieName][1];
        } else {
          result = percentPageViewedInfoPrevious[cookieName];
        }
      }

      return result;
    };

  _getPercentPageViewed.calculate = calculate;
  _getPercentPageViewed.getCurrent = getCurrent;
  _getPercentPageViewed.getPrevious = getPrevious;
  _getPercentPageViewed.version = version;

  _satellite._getPercentPageViewed = _getPercentPageViewed;

}());

/*******************************************************************************
* _poll: This plugin will allow you to wait to call a function to 
*   run any code until after certain dependencies have been resolved.  It 
*   will allow for us to easily wait for other services which we don't have
*   access to modify or attach any callbacks to in order to execute code.
* 
*   Version: 1.1
*     - 1.1 - Added callOnTimeout config flag.
*     - 2.0 - Refactored completely to use setInterval and setTimeout
*
*   Dependencies:
*     none
* 
*   Methods:
*     __________________________________________________________________________
*     _poll(func, dependencies, config): Call this to set up a 
*       pseudo listener that will be called when all dependencies are resolved.
*       
*       Parameters: 
*         - [required] func (function) - Function to call when dependencies are
*           resolved.
*         - [required] dependencies (array) - an array of dependencies to 
*           resolve before executing the func function.
*         - [optional] config (object) - an object for further configuring 
*           the functionality of the listener.  Here are the properties you 
*           may set on this configuration object:
*           - [optional] timeout (integer) (default = 3000) - the number of 
*             milliseconds to wait before giving up and removing from the 
*             interval
*           - [optional] interval (integer) (default = 1) - the number of 
*             milleseconds between checks
*           - [optional] callOnTimeout (boolean) (default = false) - whether to
*             call the success function when the timeout function is called
*           
*       Returns: 
*         - status (boolean) - true if successfully initialized, false otherwise
*******************************************************************************/
(function () {
  'use strict';

  var 
    version = '2.0',
    isResolved = function (dependencies) {
      var 
        m, p,
        resolved = true;

      for (m = 0, p = dependencies.length; m < p; m++) {
        if ('function' === typeof dependencies[m]) {
          // call function and if true, the dependency is resolved
          resolved = resolved && dependencies[m]();
        } else {
          resolved = resolved && ('undefined' !== typeof dependencies[m]);
        }
      }

      return resolved;
    },
    cleanUp = function (config) {
      clearInterval(config.intervalId);
      clearTimeout(config.timeoutId);
    };

  _satellite._poll = function (func, dependencies, config) {

    // Defaults
    config.timeout = config.timeout || 3000;
    // config.timeoutId;
    config.interval = config.interval || 100;
    // config.intervalId;
    config.callOnTimeout = !!config.callOnTimeout;

    if (isResolved(dependencies)) {
      func();
    } else {

      // set an interval for checking
      config.intervalId = setInterval(function () {
        // if all dependencies are resolved call the function
        if (isResolved(dependencies)) {
          cleanUp(config);
          func();
        }
      }, config.interval);

      // set a timeout for max time of checking
      config.timeoutId = setTimeout(function () {
        cleanUp(config);
        if (config.callOnTimeout) {
          func();
        }
      }, config.timeout);
    }
  };

  _satellite._poll.version = version;

}());

/*******************************************************************************
* _returnValueWhenNew(v, c, e): Returns the value if that value 
*   was different from the last time the value was set.
*   Also knows as 'getValOnce' in the Adobe Analytics world, so I am setting
*   an alias for the _getValOnce method name.  However, note that I am 
*   removing the last parameter (mintes or seconds) and allowing the user to
*   specify whether they want milliseconds, a date object, or 0 or 1.
*
* Version: 2.0
*   - 1.0 - initial version
*   - 2.0 - Launch compatible.
*
* Dependencies:
*   - none
* 
* Parameters:
*   v = value to check and return if has been updated
*   c = cookie name, or unique name of value to check against
*   e = optional expiration Date object, milliseconds from now, 1 to use 
*     default expiration, or 0 for default browser session expiration
*
* Returns:
*   v only when v is not equal to the value in cookie c and is not '', 
*   otherwise returns ''
*******************************************************************************/
(function () {
  'use strict';

  _satellite._returnValueWhenNew = _satellite._getValOnce = 
  function (v, c, e, t, d) {
    var
      a = new Date(),
      i = t == 'm' ? 60000 : 86400000,
      k,
      attributes = {},
      cookie = _satellite.cookie;

    v = v ? v : '';
    c = c ? c : 's_gvo';
    e = e ? e : 0;
    k = cookie.get(c);
    if (v) {
      a.setTime(a.getTime() + e * i);
      if (e !== 0) {
        attributes.expires = a;
      }
      if (d) {
        attributes.domain = d;
      }
      cookie.set(c, v, attributes);
    }
    return v == k ? '' : v;
  };

  _satellite._returnValueWhenNew.version = '2.0';
  _satellite._getValOnce.version = '2.0';

}());

/*******************************************************************************
* _getNewRepeat(d, cn): Returns whether user is new or repeat from the end of
*   of a 30 minute period of continuous activity until however long in days.
*   In other words, they are a "New" visitor for their first "Visit".  
*
* Version: 1.0
*   - 1.0 - initial version
*   - 2.0 - Launch compatible.
*
* Dependencies:
*   _setCookie = Satellite plugin for setting a cookie
*   _readCookie = Satellite plugin for reading a cookie
* 
* Parameters:
*   d = (optional) Number of days until the cookie will expire. Default is 30 
*     days
*   cn = (optional) Name of cookie. Default is "s_nr"
*   domain = (optional) The Domain on which to set the cookie
*
* Returns:
*   IF the visitor has visited the site within the last "d" days, then "Repeat" 
*   will be returned
*   ELSE "New" will be returned
*   If the visitor blocks first party cookies "New" will be returned
*******************************************************************************/
(function () {
  'use strict';

  _satellite._getNewRepeat = function (d, cn, domain) {
    var
      e = new Date(), 
      now = e.getTime(),
      cval, 
      splitValue,
      timeInDays,
      attributes = {},
      cookie = _satellite.cookie;

    // how many days to expire the cookie
    d = d ? d : 30;
    cn = cn ? cn : 's_nr';
    timeInDays = d * (24 * 60 * 60 * 1000);
    e.setTime(now + timeInDays);
    cval = cookie.get(cn) || '';

    // set cookie attributes
    attributes.expires = e;
    if (domain) {
      attributes.domain = domain;
    }

    // if we haven't ever set the cookie, then set it and return
    if (cval.length === 0) {
      if(_satellite.getVar('enable_performanceCookie'))
      cookie.set(cn, now + '-New', attributes);
      return 'New';
    }

    // if we have set the cookie, get the date that the cookie was set
    // and whether they were new or repeat at the time
    splitValue = cval.split('-');

    // if the difference between the time the cookie was set and the time
    // we are checking the cookie is less than 30 minutes...Or in other words,
    // if we only set this cookie 30 minutes ago, then set the cookie again...
    // to make sure that we are counting the time they are new from the end
    // of the "Visit" rather than from the start of the "Visit"
    if (
      now - splitValue[0] < (30 * 60 * 1000) && 
      splitValue[1] === 'New'
    ) {
      if(_satellite.getVar('enable_performanceCookie'))
      cookie.set(cn, now + '-New', attributes);
      return 'New';
    } else {
      if(_satellite.getVar('enable_performanceCookie'))
      cookie.set(cn, now + '-Repeat', attributes);
      return 'Repeat';
    }
  };

  _satellite._getNewRepeat.version = '2.0';

}());

/*******************************************************************************
* _getTimeParting(h, z): This plugin takes the clients time
*   and returns different portions of it based on the
*   parameters set.  This is 
*
* Version: 1.0
*
* Dependencies:
*   none
* 
* Parameters:
*   h = (required) Hemisphere - Specify what hemisphere you are converting the
*     time to. This is a value of 'n' or 's'.  This is used to determine how
*     to use the DST array passed.
*     If 'n' is passed the plugin uses the dates when DST is on.
*     If 's' is passed the plugin uses the dates when DST is off.
*   z = (optional) Time Zone - If you would like the data to be based upon a 
*     specific time period, then that will need to be specified as the hours
*     different from GMT here.  If no value is specified, it defaults to GMT
*     (i.e. '-5' for US Eastern Time)
*
* Returns:
*   array of [
*     0: Time at minute level,
*     1: Time at 30 minute level,
*     2: Day of week,
*     3: Weekend or Weekday
*   ]
*******************************************************************************/
(function () {
  'use strict';

  var daylightSavingsTimes = {
    2012:'3/11,11/4',
    2013:'3/10,11/3',
    2014:'3/9,11/2',
    2015:'3/8,11/1',
    2016:'3/13,11/6',
    2017:'3/12,11/5',
    2018:'3/11,11/4',
    2019:'3/10,11/3'
  };

  _satellite._getTimeParting = function (h, z) {
    var s = (this === window) ? _satellite : this,
      od;
    od = new Date('1/1/2000');
    if (od.getDay() !== 6 || od.getMonth() !== 0) {
      return 'Data Not Available';
    } else {
      var H, M, D, W, U, ds, de, tm, tt,
        da = ['Sunday', 'Monday', 'Tuesday',
          'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        d = new Date(),
        a = [];
      z = z ? z : 0;
      z = parseFloat(z);
      if (daylightSavingsTimes) {
        var dso = daylightSavingsTimes[d.getFullYear()].split(/,/);
        ds = new Date(dso[0] + '/' + d.getFullYear());
        de = new Date(dso[1] + '/' + d.getFullYear());
        if (h == 'n' && d > ds && d < de) {
          z = z + 1;
        } else if (h == 's' && (d > de || d < ds)) {
          z = z + 1;
        }
      }
      d = d.getTime() + (d.getTimezoneOffset() * 60000);
      d = new Date(d + (3600000 * z));
      H = d.getHours();
      M = d.getMinutes();
      M = (M < 10) ? '0' + M : M;
      D = d.getDay();
      U = 'AM';
      W = 'Weekday';
      if (H >= 12) {
        U = 'PM';
        H = H - 12;
      }
      if (H === 0) {
        H = 12;
      }
      if (D === 6 || D === 0) {
        W = 'Weekend';
      }
      D = da[D];
      tm = H + ':' + M + U;
      tt = H + ':' + ((M > 30) ? '30' : '00') + U;
      a = [tm, tt, D, W];
      return a;
    }
  };

  _satellite._getTimeParting.version = '1.0';

}());

/*******************************************************************************
* _timeSpentOnPage: A plugin for tracking how long someone was on the page.
* 
*   Version: 1.0
*
*   Dependencies:
*     none
* 
*   Methods:
*     __________________________________________________________________________
*     _timeSpentOnPage(): Call this 
*       
*       Parameters: 
*         - [required] name (string) - The event name to attach the listener
*           to.
*         - [required] func (function) - Function to call when event fires.
*         - [optional] callIfFired (boolean) (default = false) - A flad to 
*             indicate to call the func callback if this event has already been
*             fired.
*           
*       Returns: 
*         - status (boolean) - true if successfully initialized, false otherwise
*******************************************************************************/
(function (_satellite) {
  'use strict';

  var
    version = '1.0',
    w = window,
    d = document,

    start,
    stop,
    cumulative = 0,
    started,
    stopped,
    running;

  // config
  _satellite.config = {
    // TODO:
  };

  _satellite._timeSpentOnPage = function (config) {
    
    // configuration of the plugin
    _satellite.config = config;

    // init
    _satellite._timeSpentOnPage.init();

  };

  // start
  _satellite._timeSpentOnPage.start = start = function () {
    started = (new Date()).getTime();
    running = true;
  };

  // stop
  _satellite._timeSpentOnPage.stop = stop = function () {
    if (running) {
      stopped = (new Date()).getTime();
      cumulative += (stopped - started);
      running = false;
    }
  };

  // restart
  _satellite._timeSpentOnPage.restart = function () {
    cumulative = 0;
    start();
  };

  // init
  _satellite._timeSpentOnPage.init = function () {

    var
      hidden,
      visibilitychange;

    // sniff for the right visibility event and document flag

    // standard
    if ('hidden' in d) {
      hidden = 'hidden';
      visibilitychange = 'visibilitychange';

    // firefox
    } else if ('mozHidden' in d) {
      hidden = 'mozHidden';
      visibilitychange = 'mozvisibilitychange';

    // microsoft
    } else if ('msHidden' in d) {
      hidden = "msHidden";
      visibilitychange = "msvisibilitychange";

    // chrome, safari 
    } else if ('webkitHidden' in d) {
      hidden = "webkitHidden";
      visibilitychange = "webkitvisibilitychange";

    }

    // listen for changes in the visibility
    d.addEventListener(visibilitychange, function () {
      if (d[hidden]) {
        stop();
      } else {
        start();
      }
    }, true);

    // listen for blur event on the window 
    w.addEventListener('blur', function () {
      stop();
    });

    // listen for focus event on the window 
    w.addEventListener('focus', function () {
      start();
    });

    // TODO: Actions would go here

    // start if not hidden 
    if (!d[hidden]) {
      start();
    }

  };

  // getTimeSpent
  _satellite._timeSpentOnPage.getTimeSpent = function () {
    if (running) {
      return cumulative + (
        (new Date()).getTime() - started
      );
    } else {
      return cumulative;
    }
    
  };

  // version
  _satellite._timeSpentOnPage.version = version;

}(_satellite));

/*******************************************************************************
* loadScript(): Function to inject third party tags in a page
*
* Version: 1.0
*
* Dependencies:
*   None
* 
* Parameters:
*   script src onload
*
* Returns:
*   Injects aysnc script in webpage
*******************************************************************************/
(function () {
_satellite._loadScript = function(src, onload) {

  var
    d = document,
    s = d.createElement('script'),
    first,
    parent,
    called = false;

  s.src = src;
  s.async = true;

  // if there is an onload callback
  if (onload) {
    s.onload = s.onreadystatechange = function(e) {
      var
        readyState = this.readyState;
      if (
        // only call the callback once
        !called &&
        (
          // either readyState doesn't exist
          !readyState ||
          // or it is set to complete or loaded
          (
            readyState === 'complete' ||
            readyState === 'loaded'
          )
        )
      ) {
        called = true;
        onload(e);
      }
    };
  }

  // find the first script
  first = d.getElementsByTagName('script')[0];

  // if we found the first script tag and it has a parentNode, insert the script
  if (
    first &&
    first.parentNode
  ) {
    parent = first.parentNode;
    parent.insertBefore(s, first);

    // if we didn't find it, try inserting into the head
  } else {
    parent = d.head;

    // if we found the head
    if (parent) {
      parent.appendChild(s);

      // if we didn't find the head, try the body
    } else if (d.body) {
      parent = d.body;
      parent.appendChild(s);

      // otherwise indicate we don't know where we can put this
    } else {
      // was not able to fire pixel...
    }
  }
};

}());
/*******************************************************************************
* index(): Function to check indexOf anything
*
* Version: 1.0
*
* Dependencies:
*   None
*
* Returns:
*   Boolean
*******************************************************************************/
(function () {  
 _satellite._index = function(str, substr) {
    return str.indexOf(substr) !== -1;
  };
}());
/*******************************************************************************
* loadAsyncScript(): Function to inject async script in desired pages
*
* Version: 1.0
*
* Dependencies:
*   None
* 
* Parameters:
*   script src
*
* Returns:
*   Loads the async script when invoked
*******************************************************************************/
(function () {
_satellite._loadAsyncScript = function(scriptSrc) {
  var
    a = document.createElement('script'),
    b = document.getElementsByTagName('body')[0];
  a.type = 'text/javascript';
  a.async = true;
  a.src = scriptSrc;
  b.appendChild(a);
}
}());

/*******************************************************************************
* loadImageTag(): Function to inject image tag in desired pages
*
* Version: 1.0
*
* Dependencies:
*   None
* 
* Parameters:
*   image tag src
*
* Returns:
*   Loads the image tag when invoked
*******************************************************************************/
(function () {
_satellite._loadImageTag = function(src) {
  var newImageReq = document.createElement('img');

  newImageReq.src = src;
  newImageReq.alt = '';
  newImageReq.height = '1';
  newImageReq.width = '1';
  newImageReq.border = '0';
  newImageReq.style.display = 'none';

  document.body.appendChild(newImageReq);

}
}());

/*******************************************************************************
* loadFTiframe(): Function to inject iframe tag in desired pages
*
* Version: 1.0
*
* Dependencies:
*   None
* 
* Parameters:
*   iframe tag src
*
* Returns:
*   Loads the iframe tag when invoked
*******************************************************************************/
(function () {
_satellite._loadFTiframe = function(src) {

  var newIframe = document.createElement('iframe');
  newIframe.style.position = 'absolute';
  newIframe.style.display = 'none';
  newIframe.style.width = '1';
  newIframe.style.height = '1';
  newIframe.src = src;
  document.body.appendChild(newIframe);
}
}());
/*******************************************************************************
* _request(config): An XMLHttpRequest wrapper to make things easier.  It should
*   work very similarly to $.ajax, or to axios.
*
* Version: 1.0
*
* Dependencies:
*   Promise - either browser API or polyfill
* 
* Parameters:
*   - config - a config object with parameters needed to make a request
*     - method - "GET" or "POST" or any other http methods
*     - url - a well formed url to make the HTTP request.
*     - headers - an object of headers to send with the request
*     - data - the post body of the request
*     - timeout - 
*     - withCredentials - whether to pass cookies with the request or not
*
* Returns:
*   - response - an object with the following properties:
*     - headers - an array consisting of objects with these properties:
*       - key - the header key
*       - value - the header value
*     - status - an integer value
*     - statusText - the status message
*     - ok - true or false on whether it was a 2xx response or something else.
*     - json - a method you can call to return the value in json format
*     - text - the raw text response 
*     - data - a convenience property with a value of calling the .json() method
* 
* Usage:
* 
* _satellite._request({
*   method: 'get',
*   url: 'https://adobeioruntime.net/api/v1/web/14257_51772/profile/connect.json'
* }).then(function (response) {
*   console.log(response.data);
* });
*******************************************************************************/
(function (_satellite) {
  'use strict';

  _satellite._request = function (config) {
    var
      promise;

    // create the promise
    promise = new Promise(function (resolve, reject) {
      var
        xhr,
        name,
        value,
        parseResponseHeaders;

      // util method for parsing the response headers
      parseResponseHeaders = function (string) {
        var
          headers = [],
          split,
          row,
          parts,
          name,
          value,
          i, il;

        if (!string) {
          return headers;
        }

        // split the string into rows
        split = 
          string
          .trim()
          .split(/[\r\n]+/);

        // loop through each of the rows
        for (i = 0, il = split.length; i < il; i++) {
          row = split[i];

          // split into parts
          parts = row.split(': ');

          // get the name as the first part
          name = parts.shift();

          // combine the rest of them as the value
          value = parts.join(': ');

          // add it to the object
          headers.push({
            key: name,
            value: value,
          });
        }

        return headers;
      };

      // create the xhr
      xhr = new XMLHttpRequest();

      // open the request
      xhr.open(
        config.method.toUpperCase(),
        config.url,
        true
      );

      

      //--------------------------------------------------------------------------
      // callbacks and events
      //--------------------------------------------------------------------------
      
      // load
      xhr.onreadystatechange = function () {
        var
          response = {},
          err;

        if (
          // we have an xhr
          xhr && 
          // we have a ready state
          xhr.readyState &&
          // it is ready state of 4
          xhr.readyState === 4
        ) {

          //----------------------------------------------------------------------
          // response properties
          //----------------------------------------------------------------------

          // response.headers
          if (xhr.getAllResponseHeaders) {
            response.headers = parseResponseHeaders(xhr.getAllResponseHeaders());
          } else {
            response.headers = null;
          }

          // response.redirected
          // TODO: figure how how to fix this?
          response.redirected = false;

          // response.status
          // according to axios, IE sends 1223 instead of a 204
          response.status = xhr.status === 1223 ? 204 : xhr.status;

          // response.statusText
          response.statusText = xhr.status === 1223 ? 'No Content' : xhr.statusText,

          // response.ok
          response.ok = response.status >= 200 && response.status < 300;

          // response.type
          // TODO: figure out how to get this
          // response.type = '';

          // response.url
          // TODO: figure out how to get this
          // response.url = '';

          // response.body
          response.body = xhr.responseText;

          // response.bodyUsed
          // TODO: figure out how to get this to update
          response.bodyUsed = false;

          //----------------------------------------------------------------------
          // response methods
          //----------------------------------------------------------------------

          // response.json
          response.json = function () {
            return JSON.parse(response.body);
          };
          // response.text
          response.text = function () {
            return response.body;
          };
          // TODO: others

          //----------------------------------------------------------------------
          // other
          //----------------------------------------------------------------------

          // TODO: when to use the xhr.response property?

          // data
          // TODO: handle something different than JSON
          try {
            response.data = response.json();
          } catch (e) {
            // do nothing
          }

          // resolve the promise
          if (response.ok) {
            resolve(response);

          // otherwise, reject
          } else {
            err = new Error('Network request failed with status code ' + response.status);

            err.config = config;
            err.request = xhr;
            err.response = response;

            reject(err);
          }

          // cleanup
          xhr = null;
        }

      };

      // abort
      xhr.onabort = function () {
        var
          err;

        err = new Error('Network reqeust aborted');

        err.config = config;
        err.request = xhr;

        reject(err);

        // cleanup
        xhr = null;
      };

      // error
      xhr.onerror = function handleError() {
        var
          err;

        err = new Error('Network Error');

        err.config = config;
        err.request = xhr;

        reject(err);

        // cleanup
        xhr = null;
      };

      // timeout
      xhr.timeout = config.timeout;
      xhr.ontimeout = function handleTimeout() {
        var
          err;

        err = new Error('Network request timed out after' + config.timeout + ' milliseconds');

        err.config = config;
        err.request = xhr;

        reject(err);

        // cleanup
        xhr = null;
      };

      //--------------------------------------------------------------------------
      // headers
      //--------------------------------------------------------------------------

      // Add headers to the xhr
      if (xhr.setRequestHeader) {

        // loop through each of the headers
        for (name in config.headers) {
          if (!config.headers.hasOwnProperty(name)) {
            continue;
          }

          // get the value
          value = config.headers[name];

          // set the header on the xhr
          xhr.setRequestHeader(name, value);
        }

      }

      // withCredentials
      if (config.withCredentials) {
        xhr.withCredentials = true;
      }

      // TODO: responseType

      // TODO: download/upload progress

      // explicitly set data to null if we were not passed anything
      if (!config.hasOwnProperty('data')) {
        config.data = null;
      }

      //--------------------------------------------------------------------------
      // send!
      //--------------------------------------------------------------------------
      xhr.send(config.data);

    });

    return promise;
  };

  _satellite._request.version = '1.0';

}(_satellite));


/*******************************************************************************
* _getVisitStart(c): Determines whether this is the first page of the visit
*
* Version: 1.0
*
* Dependencies:
*   _setCookie = Satellite plugin for setting a cookie
*   _readCookie = Satellite plugin for reading a cookie
* 
* Parameters:
*   c = (string) cookie name for tracking, or unique name of value to check against
*
* Returns:
*   (integer) 1 on first page of visit, otherwise 0
*******************************************************************************/
(function (_satellite) {
  'use strict';

  _satellite._getVisitStart = function (c) {
    var s = (this === window) ? _satellite : this,
      v = 1,
      expires = new Date();
    // 30 minutes
    //t.setTime(t.getTime() + 1800000);
    expires.setTime(expires.getTime() + 1800000);
    //expires = expires.getTime() + 1800000;
    if (s.cookie.get(c)) {      
      v = 0;
    }

    if (!s.cookie.set(c, 1, {
      expires:expires,
      domain: _satellite._getDomain()
    })) {   
      //console.log('Breakpoint:: Executing here')   ;
      s.cookie.set(c, 1, 0);

    }    

    if (!s.cookie.get(c)) {      
      v = 0;
    }
    return v;
  };

  _satellite._getVisitStart.version = '1.0';

}(_satellite));

/*******************************************************************************
*     _clickPast(scp, hitType, clickThroughEvent, clickPastEvent, cookieName): 
*       Sets a "click-through" event
*       based on the value of a Javascript variable (e.g. s.campaign) and a 
*       "click-past" event on the following page view. Can use s.clickPast as
*       an alias to this plugin.
*       
*       Parameters: 
*         - [required] scp (string) - The click-through variable. If this 
*           variable exists with any truthy value, then the plug-in will set the 
*           click-through event.
          - [required] hitType (string) - HitType can be of type 'pageload' or
            state
*         - [required] clickThroughEvent (string) - The event to use for 
*           click-throughs.
*         - [required] clickPastEvent (string) - The event to use for 
*           click-pasts.
*         - [optional] cookieName (string) (default = 's_cpc') - The cookie name 
*            used to identify a click-past. 
*         - [optional] eventsDelimiter (string) (default = ',') - The delimiter
*           used for separating events in the s.events variable
*           
*       Returns: 
*         - status (integer) - 1 if click through was set, 0 if click
*           past was set, -1 if neither were set.
*******************************************************************************/

(function (_satellite) {
  'use strict';

  var version = '1.0';
  var runOnceCache = {};
  /* _satellite.clickPast = function (scp, clickThroughEvent,
     clickPastEvent, cookieName, eventsDelimiter) {*/

  _satellite.clickPast = function (scp,hitType, cookieName, eventsDelimiter) {
    var s = this,
      status = -1,
      expires = new Date();
    // 30 minutes
    //t.setTime(t.getTime() + 1800000);
    expires.setTime(expires.getTime() + 1800000);;
    //only run plug-in once per page load
    if (!runOnceCache[hitType]) {      
      // make sure it isn't ever run again
      runOnceCache[hitType] = true;

      // if we weren't given a cookieName, use 's_cpc'
      if (!cookieName) {
        cookieName = 's_cpc';
      }

      // if we weren't given a delimiter, use ','
      if (!eventsDelimiter) {
        eventsDelimiter = ',';
      }

      // events = s.events ? s.events + eventsDelimiter : '';

      // if the value is truthy, set the click-through
      if (scp) {
        //s.events = events + clickThroughEvent;
        s.cookie.set(cookieName, 1, {
          expires: expires,
          domain: _satellite._getDomain()
        });
        // s.c_w(cookieName, 1, 0);
        status = 1;
        // otherwise, check for click-past
      } else {
        // make sure we have first set the click-through before setting 
        // click-past
        if (s.cookie.get(cookieName) >= 1) {
          // s.events = events + clickPastEvent;
          s.cookie.set(cookieName, 0, {
            expires: expires,
            domain: _satellite._getDomain()
          });
          status = 0;
        }
      }
    }     
    
    return status;
  };

}(_satellite));

/* eslint-enable */

return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLd9a5aa59a6e2452ab9b9e4efe5566c91",
      "name": "initCookieMigration",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 2.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  
//------------------------------------------------------------------------------
// Migrate from combined cookies
//------------------------------------------------------------------------------
(function () {
  'use strict';

  var
    cookieRaw,
    cookie,
    cookies = {},
    attributes,

    i, il,
    key,
    value,
    valueSplit,
    hostnameSplit,
    effectiveDomain = _satellite._getDomain(),
    domain,

    trim;

  trim = function (string) {
    return string.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };

  //----------------------------------------------------------------------------
  // 1)  s_sess cookie
  //----------------------------------------------------------------------------

  // read top level cookie
  cookieRaw = _satellite.cookie.get('s_sess');

  // make sure we have a string
  cookieRaw = cookieRaw || '';

  // split into chunks
  cookieRaw = cookieRaw.split(';');

  // loop through and capture each
  for (i = 0, il = cookieRaw.length; i < il; i++) {
    // get cookie
    cookie = cookieRaw[i];

    // trim whitespace
    cookie = trim(cookie);

    // continue if cookie is blank
    if (!cookie) {
      continue;
    }

    // split the key and value
    cookie = cookie.split('=');

    // get the key
    key = decodeURIComponent(cookie[0]);

    // get the value with expiration
    value = {
      value: decodeURIComponent(cookie[1]),
      expires: false
    };

    // save
    cookies[key] = value;
  }

  //----------------------------------------------------------------------------
  // 2) Parse s_pers cookie
  //----------------------------------------------------------------------------
  
  // read top level cookie
  cookieRaw = _satellite.cookie.get('s_pers');

  // make sure we have a string
  cookieRaw = cookieRaw || '';

  // split into chunks
  cookieRaw = cookieRaw.split(';');

  // loop through and capture each
  for (i = 0, il = cookieRaw.length; i < il; i++) {
    // get cookie
    cookie = cookieRaw[i];

    // trim whitespace
    cookie = trim(cookie);

    // continue if cookie is blank
    if (!cookie) {
      continue;
    }

    // split the key and value
    cookie = cookie.split('=');

    // get the key
    key = decodeURIComponent(cookie[0]);

    // get the value with expiration
    valueSplit = cookie[1].split('|');
    value = {
      value: decodeURIComponent(valueSplit[0]),
      expires: parseInt(valueSplit[1])
    };

    // save
    cookies[key] = value;
  }

  //----------------------------------------------------------------------------
  // 3) Set the cookies on top level
  //----------------------------------------------------------------------------

  // loop through and set top level cookies
  for (key in cookies) {
    if (!cookies.hasOwnProperty(key)) {
      continue;
    }

    // attributes to pass to cookie writing function
    attributes = {};

    // get value
    value = cookies[key];

    // domain - make sure it is on top level domain
    attributes.domain = effectiveDomain;

    // path - not needed since default is '/'

    // expires - only if it is from s_pers
    if (value.expires) {
      attributes.expires = new Date(value.expires);
    }

    // set cookie
    _satellite.cookie.set(key, value.value, attributes);
  }

  //----------------------------------------------------------------------------
  // 3) Delete both s_sess and s_pers cookies
  //----------------------------------------------------------------------------

  // get hostname parts
  hostnameSplit = window.location.hostname.split('.');

  domain = '';

  // finally delete the cookie for each sub-domain
  for (i = hostnameSplit.length - 1; i >= 0; i--) {

    domain = '.' + hostnameSplit[i] + domain;

    // don't even try to set if we haven't gotten to top level domain yet
    if (domain.indexOf(effectiveDomain) === -1) {
      continue;
    }
    
    // remove s_sess
    _satellite.cookie.remove('s_sess', {
      domain: domain
    });

    // remove s_pers
    _satellite.cookie.remove('s_pers', {
      domain: domain
    });

  }

})();


return true;


















}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLab5e75c1a3df4ddc87d665981cbaf844",
      "name": "adobedotcom_trialdownload",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackPerpetualTrialDownloadFormSubmit"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC4d591ccf84724f8184d76ca735d32e46-file.js'
          }
        }
      ]
    },
    {
      "id": "RL653301c7cbdc413ba09e1c182a8300ff",
      "name": "initsummit2021",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
    wc = w.location,
    h = wc.hostname,
    p= wc.pathname;

if((h=='portal.adobe.com' || h=='business.adobe.com') && (p.indexOf('catalogsum2021')!==-1 || p.indexOf('calendarsum2021')!==-1 || p === '/summit/2021/my-schedule.html')){
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": "var w = window,\n  wc = w.location,\n  h = wc.hostname,\n  p = wc.pathname;\n\n  var trackCall = function (linkName) {\n    digitalData._set('digitalData.primaryEvent.eventInfo.eventName', linkName);\n\n\n    _satellite.track('event', {\n\n      digitalData: digitalData._snapshot()\n\n    });\n  }\n\n// jQuery IS loaded, do stuff here.\nif (typeof $ !== 'undefined') {\n\n\n\n  //calender and catalog page\n  if (p.indexOf('catalogsum2021') !== -1 || p.indexOf('calendarsum2021') !== -1) {\n    $('body').on('click', '.session-schedule', function () {\n      trackCall('adobeCatalogSum2021:session:addtoSchedule')\n    });\n\n\n    $('body').on('click', '.confirm', function () {\n      trackCall('adobeCatalogSum2021:session:removeFromSchedule')\n    });\n  }\n}\n\n\n  //my schedule page\n  if (p === '/summit/2021/my-schedule.html') {\n    document.addEventListener('click', function (e) {\n      var target = e.target;\n      if (target && target.innerText) {\n        if (target.innerText == 'Add to Schedule' || target.innerText == 'Add To Schedule') {\n          trackCall('adobeCatalogSum2021:my-schedule:addtoSchedule')\n        }\n        if (target.innerText == 'Yes, Remove Session') {\n          trackCall('adobeCatalogSum2021:my-schedule:removeFromSchedule')\n        }\n\n      }\n    }, false);\n  }\n",
            "language": "javascript"
          }
        }
      ]
    },
    {
      "id": "RLecbdcd5afab848679cd222d73169ffa9",
      "name": "aep_trackPageViews",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageview"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%aep_enable%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if (
  event.detail &&
  event.detail.digitalData
) {
  digitalData = event.detail.digitalData;
}

return true;
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCf213af8d6bd3446189e297876b328470-file.js'
          }
        }
      ]
    },
    {
      "id": "RL22c5eae8c378424fb4ac4e6849f03da3",
      "name": "initDigitalData",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 4.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  
var
  setDigitalData = _satellite.getVar('adobe_digitalData');
// apply them on the global digitalData object.  This is the only place
// that we set the digital data layer properties that are our responsibility.
//if(window.location.hostname !== 'adobeid-na1-stg1.services.adobe.com'){
    setDigitalData(window.digitalData);    
//}

return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLee71a2579c5d4862b2c98773879169c0",
      "name": "TwP - DOM parsing",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  h = w.location.hostname,
  p = w.location.pathname,
  hostnameContains,
  pathnameContains;

// contains function for minification
hostnameContains = function (string) {
  return h.indexOf(string) !== -1;
};

pathnameContains = function (string) {
  return p.indexOf(string) !== -1;
};

//------------------------------------------------------------------------------
// Only for Mini-plans
//------------------------------------------------------------------------------

if (hostnameContains('.adobe.com') &&
  pathnameContains('/mini-plans')
) {
  return true;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* global digitalData:true 
*/
var snapshot = digitalData._snapshot(),
  linkName;

function analyticsCall(linkName) {
  snapshot._set(
    'digitalData.primaryEvent.eventInfo.eventName',
    digitalData._get('digitalData.page.pageInfo.pageName') + ':' + digitalData._get('digitalData.plansPageAttributes.selectedTab') + ':' + linkName
  );
  _satellite.track('event', {
    digitalData: snapshot
  });

  digitalData._delete(
    'digitalData.primaryEvent.eventInfo.eventName'
  );
}

var seeAllPlans = document.querySelectorAll('[data-variations*="see-all-"] a');
for (var i = 0; i < seeAllPlans.length; i++) {
  seeAllPlans[i].addEventListener('click', function () {
    if (this.href) {
      if (this.href.indexOf('plans.html') !== -1) {
        linkName = 'SeeAllCreativeCloudPlans';
        analyticsCall(linkName);
      }
      if (this.href.indexOf('student_teacher_eligibility') !== -1) {
        linkName = 'InstitutionalAffiliation';
        analyticsCall(linkName);
      }
      if (this.href.indexOf('offer-terms/ccm_') !== -1) {
        linkName = 'PromotionalPricingTerms';
        analyticsCall(linkName);
      }
    }
  });
}

}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL7e19bbf4335d49b08094154122649167",
      "name": "adobe.target.triggerView_plansPage",
      "events": [
        {
          "modulePath": "core/src/lib/events/click.js",
          "settings": {
            "elementSelector": "div.navList spectrum-tablist[data-name=\"segments\"] div.spectrum-Tabs-item",
            "bubbleFireIfParent": true,
            "bubbleFireIfChildFired": true
          },
          "ruleOrder": 50.0
        },
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var href = window.location.href;

if(href.indexOf('creativecloud/plans.html')!==-1)
{
  return true;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  (function() {
 setTimeout(function() {
  var w = window,
    loc = w.location,
    href = loc.href,
    tabList = '',
    selectedTab = '',
    tabIndex = 0;

    selectedTab = document.querySelector('div.navList spectrum-tablist[data-name="segments"]>div.spectrum-Tabs>div.spectrum-Tabs-item.is-selected');
    if (selectedTab) {
      tabList = selectedTab.parentNode;
    } 

    var triggerTarget = {
      settings: {
        timeout: 2500,
        time: 0
      },
      waitForPlans: function (plansLoaded) {
        if ( w.adobe &&
            w.adobe.target &&
            w.adobe.target.triggerView &&
            selectedTab &&
            tabList) {
          plansLoaded();
        } else if (triggerTarget.settings.time >= triggerTarget.settings.timeout) {
          
        } else {
          triggerTarget.settings.time = triggerTarget.settings.time + 100;
          setTimeout(function () {
            triggerTarget.waitForPlans(plansLoaded)
          }, 100);
        }
      },
      init: function () {
        tabIndex = Array.prototype.indexOf.call(tabList.children, selectedTab);
        if (tabIndex == 0) {
          if (typeof(w.individualSeen) == 'undefined') {
            w.individualSeen = true;
            w.adobe.target.triggerView('IndividualTab');
          } else {
            w.adobe.target.triggerView('IndividualTab', {
              page: false
            });
          }
        } else if (tabIndex == 1) {
          if (typeof(w.teamSeen) == 'undefined') {
            w.teamSeen = true;
            w.adobe.target.triggerView('TeamTab');
          } else {
            w.adobe.target.triggerView('TeamTab', {
              page: false
            });
          }
        } else if (tabIndex == 2) {
          if (typeof(w.educationSeen) == 'undefined') {
            w.educationSeen = true;
            w.adobe.target.triggerView('EducationTab');
          } else {
            w.adobe.target.triggerView('EducationTab', {
              page: false
            });
          }
        } else if (tabIndex == 3) {
          if (typeof(w.institutionSeen) == 'undefined') {
            w.institutionSeen = true;
            w.adobe.target.triggerView('EducationInstitutionsTab');
          } else {
            w.adobe.target.triggerView('EducationInstitutionsTab', {
              page: false
            });
          }
        }
      }
    };

  if (href.indexOf('adobe.com') > -1 && href.indexOf('/creativecloud/plans.html') > -1) {
    triggerTarget.waitForPlans(function () {
      triggerTarget.init();
    });
  }
 }, 1);
})();
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL90cfb14c8e59435a829cc4a36a8a8c14",
      "name": "heartbeatTracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/pageBottom.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
  l = w.location,
  h = l.hostname,
  p = l.pathname,
  ytIframe = document.getElementsByTagName('iframe'),
  isYTavlble = false;
w.enableDexFlag = false;  
w.vidCount = 0;

if (h.indexOf('adobe.com') != -1) {
  for (var i = 0; i < ytIframe.length; i++) {

    if (ytIframe && ytIframe[i].getAttribute('src') && ytIframe[i].getAttribute('src').indexOf('www.youtube.com/') != -1) {

      isYTavlble = true;
      if (ytIframe[i].getAttribute('id') && ytIframe[i].getAttribute('id').indexOf('player-') != -1) {
        w.enableDexFlag = true;
        w.vidCount++;
      }
      i = ytIframe.length;
    }

  }
}
if (isYTavlble)
  return true;
else
  return false;
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC6c0ea90cc2104bec9edc9df7d7146103-file.js'
          }
        },
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCda978e4dc0e44b17bc403b31c11a9409-file.js'
          }
        }
      ]
    },
    {
      "id": "RL23e019d0ab63425bb5f492833159f5cf",
      "name": "initVideoForm",
      "events": [
        {
          "modulePath": "core/src/lib/events/customCode.js",
          "settings": {
            "source": function(trigger) {
  window.addEventListener('message', function (e) {
    if (e.data.type !== 'mpcStatus') {
        return;
    }
    if (e.data.state === 'start') {
        // Marketo Hidden Form code goes here
        trigger();
    }
});
}
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var h = window.location.host,
  p = window.location.pathname;

if ((h === 'business.stage.adobe.com' || h === 'business.adobe.com') && p.indexOf('/summit/2021/sessions')!==-1) {
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCcd2393a66b59411187695e471db9e3fb-file.js'
          }
        }
      ]
    },
    {
      "id": "RL09683c861d154dcea29b192454a99bf6",
      "name": "triggerOneTrust",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "initTrackConsent"
          },
          "ruleOrder": 4.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (!noThirdParty) {
  return true;
}

}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "equals"
            },
            "leftOperand": "%thirdParty_isAbort%",
            "rightOperand": "yes"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%thirdPartyTags_allowedDomains%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%isStudent%"
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC096e15dffcd740b9a945d0211aaa5188-file.js'
          }
        }
      ]
    },
    {
      "id": "RLae737ba4207e415fb34dece795b8f072",
      "name": "initAnalyticsBeacon",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 5.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  // 2-26-2019 Adding some code to take a snapshop before tag so we can set a what triggered the hit value in the snapshot.
var
  w = window,
  s = w.s_adobe,
  wm,
  wma,
  wmal,
  wmalc,
  digitalData = w.digitalData,
  logicTrigger = 'digitalData.adobe.experienceCloud.analytics.tag.logicTrigger' ,
  snapshot;

// create a promise that only gets resolved once the page load call has been tracked
s._pageloadTrackedPromise = new Promise(function (resolve) {
  var
    resolved = false;

  s._pageLoadTrackedResolve = function (applyPageLoadDataElements) {
    if (!resolved) {
      resolve(applyPageLoadDataElements);
      resolved = true;
    }
  };
});

if (!(wm = w.marketingtech) || !(wma = wm.adobe) || !(wmal =  wma.launch) || !(wmalc = wmal.controlPageLoad) || wmalc !== true) {
  // if the window.load event has already happened
  if (document.readyState === 'complete') {

    // defer a call to track pageload
    setTimeout(function () {
      snapshot = digitalData._snapshot();
      snapshot._set(logicTrigger,'initAnalyticsBeacon readyState complete');
      _satellite.track('pageload', { digitalData: snapshot });
    }, 1);
    // if the window hasn't loaded yet
  } else {
    // wait for window loaded event to fire the event to give our clients time
    // to set data on the data layer
    w.addEventListener('load', function () {
      snapshot = digitalData._snapshot();
      snapshot._set(logicTrigger,'initAnalyticsBeacon EventListener load');
      _satellite.track('pageload', { digitalData: snapshot });
    }, true);
  }
}
// set up some insurance to make sure that we at least 
// call the tracking call before the user exits the page
_satellite._beforeUnload(function () {
  snapshot = digitalData._snapshot();
  snapshot._set(logicTrigger,'initAnalyticsBeacon beforeUnload');
  _satellite.track('pageload', { digitalData: snapshot, statelogicflag:true });
}, -10);

// if by 10 seconds, the page load rule hasn't been called, call it

setTimeout(function () {
  snapshot = digitalData._snapshot();
  snapshot._set(logicTrigger,'initAnalyticsBeacon setTimeout');
  _satellite.track('pageload', { digitalData: snapshot});
}, 10 * 1000);


// init the page unload beacon
_satellite._beforeUnload(function () {
  _satellite.track('pageunload');
}, -5);

return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLa09d2f30871f42459a94e6be3e4f0c65",
      "name": "trackFaaS_form",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "faasTracking"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC7db5a14e18fd4b7a9b26ecdfd079c161-file.js'
          }
        }
      ]
    },
    {
      "id": "RLe5ae4582a3cd43cbadbe355ab6b01ddf",
      "name": "initAnalytics",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 3.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* eslint-disable no-undef */
/* eslint-disable no-undef */

var
  w = window,
  _satellite = w._satellite;

//------------------------------------------------------------------------------
// Libraries & Modules
//------------------------------------------------------------------------------

/* eslint-disable */

/*
Start ActivityMap Module

The following module enables ActivityMap tracking in Adobe Analytics. ActivityMap
allows you to view data overlays on your links and content to understand how
users engage with your web site. If you do not intend to use ActivityMap, you
can remove the following block of code from your AppMeasurement.js file.
Additional documentation on how to configure ActivityMap is available at:
https://marketing.adobe.com/resources/help/en_US/analytics/activitymap/getting-started-admins.html
*/
function AppMeasurement_Module_ActivityMap(h){function q(){var a=f.pageYOffset+(f.innerHeight||0);a&&a>+g&&(g=a)}function r(){if(e.scrollReachSelector){var a=h.d.querySelector&&h.d.querySelector(e.scrollReachSelector);a?(g=a.scrollTop||0,a.addEventListener("scroll",function(){var d;(d=a&&a.scrollTop+a.clientHeight||0)>g&&(g=d)})):0<w--&&setTimeout(r,1E3)}}function l(a,d){var c,b,n;if(a&&d&&(c=e.c[d]||(e.c[d]=d.split(","))))for(n=0;n<c.length&&(b=c[n++]);)if(-1<a.indexOf(b))return null;p=1;return a}
function s(a,d,c,b,e){var f,k;if(a.dataset&&(k=a.dataset[d]))f=k;else if(a.getAttribute)if(k=a.getAttribute("data-"+c))f=k;else if(k=a.getAttribute(c))f=k;if(!f&&h.useForcedLinkTracking&&e){var g;a=a.onclick?""+a.onclick:"";varValue="";if(b&&a&&(d=a.indexOf(b),0<=d)){for(d+=b.length;d<a.length;)if(c=a.charAt(d++),0<="'\"".indexOf(c)){g=c;break}for(k=!1;d<a.length&&g;){c=a.charAt(d);if(!k&&c===g)break;"\\"===c?k=!0:(varValue+=c,k=!1);d++}}(g=varValue)&&(h.w[b]=g)}return f||e&&h.w[b]}function t(a,d,
c){var b;return(b=e[d](a,c))&&(p?(p=0,b):l(m(b),e[d+"Exclusions"]))}function u(a,d,c){var b;if(a&&!(1===(b=a.nodeType)&&(b=a.nodeName)&&(b=b.toUpperCase())&&x[b])&&(1===a.nodeType&&(b=a.nodeValue)&&(d[d.length]=b),c.a||c.t||c.s||!a.getAttribute||((b=a.getAttribute("alt"))?c.a=b:(b=a.getAttribute("title"))?c.t=b:"IMG"==(""+a.nodeName).toUpperCase()&&(b=a.getAttribute("src")||a.src)&&(c.s=b)),(b=a.childNodes)&&b.length))for(a=0;a<b.length;a++)u(b[a],d,c)}function m(a){if(null==a||void 0==a)return a;
try{return a.replace(RegExp("^[\\s\\n\\f\\r\\t\t-\r \u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u205f\u3000\ufeff]+","mg"),"").replace(RegExp("[\\s\\n\\f\\r\\t\t-\r \u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u205f\u3000\ufeff]+$","mg"),"").replace(RegExp("[\\s\\n\\f\\r\\t\t-\r \u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u205f\u3000\ufeff]{1,}","mg")," ").substring(0,254)}catch(d){}}var e=this;e.s=h;var f=window;f.s_c_in||(f.s_c_il=[],f.s_c_in=0);e._il=f.s_c_il;e._in=f.s_c_in;e._il[e._in]=e;f.s_c_in++;
e._c="s_m";var g=0,v,w=60;e.c={};var p=0,x={SCRIPT:1,STYLE:1,LINK:1,CANVAS:1};e._g=function(){var a,d,c,b=h.contextData,e=h.linkObject;(a=h.pageName||h.pageURL)&&(d=t(e,"link",h.linkName))&&(c=t(e,"region"))&&(b["a.activitymap.page"]=a.substring(0,255),b["a.activitymap.link"]=128<d.length?d.substring(0,128):d,b["a.activitymap.region"]=127<c.length?c.substring(0,127):c,0<g&&(b["a.activitymap.xy"]=10*Math.floor(g/10)),b["a.activitymap.pageIDType"]=h.pageName?1:0)};e._d=function(){e.trackScrollReach&&
!v&&(e.scrollReachSelector?r():(q(),f.addEventListener&&f.addEventListener("scroll",q,!1)),v=!0)};e.link=function(a,d){var c;if(d)c=l(m(d),e.linkExclusions);else if((c=a)&&!(c=s(a,"sObjectId","s-object-id","s_objectID",1))){var b,f;(f=l(m(a.innerText||a.textContent),e.linkExclusions))||(u(a,b=[],c={a:void 0,t:void 0,s:void 0}),(f=l(m(b.join(""))))||(f=l(m(c.a?c.a:c.t?c.t:c.s?c.s:void 0)))||!(b=(b=a.tagName)&&b.toUpperCase?b.toUpperCase():"")||("INPUT"==b||"SUBMIT"==b&&a.value?f=l(m(a.value)):"IMAGE"==
b&&a.src&&(f=l(m(a.src)))));c=f}return c};e.region=function(a){for(var d,c=e.regionIDAttribute||"id";a&&(a=a.parentNode);){if(d=s(a,c,c,c))return d;if("BODY"==a.nodeName)return"BODY"}}}
/* End ActivityMap Module */
/*
============== DO NOT ALTER ANYTHING BELOW THIS LINE ! ===============

AppMeasurement for JavaScript version: 2.20.0
Copyright 1996-2016 Adobe, Inc. All Rights Reserved
More info available at http://www.adobe.com/marketing-cloud.html
*/
function AppMeasurement(r){var a=this;a.version="2.20.0";var h=window;h.s_c_in||(h.s_c_il=[],h.s_c_in=0);a._il=h.s_c_il;a._in=h.s_c_in;a._il[a._in]=a;h.s_c_in++;a._c="s_c";var q=h.AppMeasurement.hc;q||(q=null);var p=h,m,s;try{for(m=p.parent,s=p.location;m&&m.location&&s&&""+m.location!==""+s&&p.location&&""+m.location!==""+p.location&&m.location.host===s.host;)p=m,m=p.parent}catch(u){}a.C=function(a){try{console.log(a)}catch(b){}};a.Qa=function(a){return""+parseInt(a)==""+a};a.replace=function(a,
b,d){return!a||0>a.indexOf(b)?a:a.split(b).join(d)};a.escape=function(c){var b,d;if(!c)return c;c=encodeURIComponent(c);for(b=0;7>b;b++)d="+~!*()'".substring(b,b+1),0<=c.indexOf(d)&&(c=a.replace(c,d,"%"+d.charCodeAt(0).toString(16).toUpperCase()));return c};a.unescape=function(c){if(!c)return c;c=0<=c.indexOf("+")?a.replace(c,"+"," "):c;try{return decodeURIComponent(c)}catch(b){}return unescape(c)};a.Mb=function(){var c=h.location.hostname,b=a.fpCookieDomainPeriods,d;b||(b=a.cookieDomainPeriods);
if(c&&!a.Ja&&!/^[0-9.]+$/.test(c)&&(b=b?parseInt(b):2,b=2<b?b:2,d=c.lastIndexOf("."),0<=d)){for(;0<=d&&1<b;)d=c.lastIndexOf(".",d-1),b--;a.Ja=0<d?c.substring(d):c}return a.Ja};a.c_r=a.cookieRead=function(c){c=a.escape(c);var b=" "+a.d.cookie,d=b.indexOf(" "+c+"="),f=0>d?d:b.indexOf(";",d);c=0>d?"":a.unescape(b.substring(d+2+c.length,0>f?b.length:f));return"[[B]]"!=c?c:""};a.c_w=a.cookieWrite=function(c,b,d){var f=a.Mb(),e=a.cookieLifetime,g;b=""+b;e=e?(""+e).toUpperCase():"";d&&"SESSION"!=e&&"NONE"!=
e&&((g=""!=b?parseInt(e?e:0):-60)?(d=new Date,d.setTime(d.getTime()+1E3*g)):1===d&&(d=new Date,g=d.getYear(),d.setYear(g+2+(1900>g?1900:0))));return c&&"NONE"!=e?(a.d.cookie=a.escape(c)+"="+a.escape(""!=b?b:"[[B]]")+"; path=/;"+(d&&"SESSION"!=e?" expires="+d.toUTCString()+";":"")+(f?" domain="+f+";":"")+(a.writeSecureCookies?" secure;":""),a.cookieRead(c)==b):0};a.Jb=function(){var c=a.Util.getIeVersion();"number"===typeof c&&10>c&&(a.unsupportedBrowser=!0,a.wb(a,function(){}))};a.xa=function(){var a=
navigator.userAgent;return"Microsoft Internet Explorer"===navigator.appName||0<=a.indexOf("MSIE ")||0<=a.indexOf("Trident/")&&0<=a.indexOf("Windows NT 6")?!0:!1};a.wb=function(a,b){for(var d in a)Object.prototype.hasOwnProperty.call(a,d)&&"function"===typeof a[d]&&(a[d]=b)};a.K=[];a.ea=function(c,b,d){if(a.Ka)return 0;a.maxDelay||(a.maxDelay=250);var f=0,e=(new Date).getTime()+a.maxDelay,g=a.d.visibilityState,k=["webkitvisibilitychange","visibilitychange"];g||(g=a.d.webkitVisibilityState);if(g&&"prerender"==
g){if(!a.fa)for(a.fa=1,d=0;d<k.length;d++)a.d.addEventListener(k[d],function(){var c=a.d.visibilityState;c||(c=a.d.webkitVisibilityState);"visible"==c&&(a.fa=0,a.delayReady())});f=1;e=0}else d||a.u("_d")&&(f=1);f&&(a.K.push({m:c,a:b,t:e}),a.fa||setTimeout(a.delayReady,a.maxDelay));return f};a.delayReady=function(){var c=(new Date).getTime(),b=0,d;for(a.u("_d")?b=1:a.za();0<a.K.length;){d=a.K.shift();if(b&&!d.t&&d.t>c){a.K.unshift(d);setTimeout(a.delayReady,parseInt(a.maxDelay/2));break}a.Ka=1;a[d.m].apply(a,
d.a);a.Ka=0}};a.setAccount=a.sa=function(c){var b,d;if(!a.ea("setAccount",arguments))if(a.account=c,a.allAccounts)for(b=a.allAccounts.concat(c.split(",")),a.allAccounts=[],b.sort(),d=0;d<b.length;d++)0!=d&&b[d-1]==b[d]||a.allAccounts.push(b[d]);else a.allAccounts=c.split(",")};a.foreachVar=function(c,b){var d,f,e,g,k="";e=f="";if(a.lightProfileID)d=a.O,(k=a.lightTrackVars)&&(k=","+k+","+a.ka.join(",")+",");else{d=a.g;if(a.pe||a.linkType)k=a.linkTrackVars,f=a.linkTrackEvents,a.pe&&(e=a.pe.substring(0,
1).toUpperCase()+a.pe.substring(1),a[e]&&(k=a[e].cc,f=a[e].bc));k&&(k=","+k+","+a.F.join(",")+",");f&&k&&(k+=",events,")}b&&(b=","+b+",");for(f=0;f<d.length;f++)e=d[f],(g=a[e])&&(!k||0<=k.indexOf(","+e+","))&&(!b||0<=b.indexOf(","+e+","))&&c(e,g)};a.o=function(c,b,d,f,e){var g="",k,l,h,n,m=0;"contextData"==c&&(c="c");if(b){for(k in b)if(!(Object.prototype[k]||e&&k.substring(0,e.length)!=e)&&b[k]&&(!d||0<=d.indexOf(","+(f?f+".":"")+k+","))){h=!1;if(m)for(l=0;l<m.length;l++)if(k.substring(0,m[l].length)==
m[l]){h=!0;break}if(!h&&(""==g&&(g+="&"+c+"."),l=b[k],e&&(k=k.substring(e.length)),0<k.length))if(h=k.indexOf("."),0<h)l=k.substring(0,h),h=(e?e:"")+l+".",m||(m=[]),m.push(h),g+=a.o(l,b,d,f,h);else if("boolean"==typeof l&&(l=l?"true":"false"),l){if("retrieveLightData"==f&&0>e.indexOf(".contextData."))switch(h=k.substring(0,4),n=k.substring(4),k){case "transactionID":k="xact";break;case "channel":k="ch";break;case "campaign":k="v0";break;default:a.Qa(n)&&("prop"==h?k="c"+n:"eVar"==h?k="v"+n:"list"==
h?k="l"+n:"hier"==h&&(k="h"+n,l=l.substring(0,255)))}g+="&"+a.escape(k)+"="+a.escape(l)}}""!=g&&(g+="&."+c)}return g};a.usePostbacks=0;a.Pb=function(){var c="",b,d,f,e,g,k,l,h,n="",m="",p=e="",r=a.T();if(a.lightProfileID)b=a.O,(n=a.lightTrackVars)&&(n=","+n+","+a.ka.join(",")+",");else{b=a.g;if(a.pe||a.linkType)n=a.linkTrackVars,m=a.linkTrackEvents,a.pe&&(e=a.pe.substring(0,1).toUpperCase()+a.pe.substring(1),a[e]&&(n=a[e].cc,m=a[e].bc));n&&(n=","+n+","+a.F.join(",")+",");m&&(m=","+m+",",n&&(n+=",events,"));
a.events2&&(p+=(""!=p?",":"")+a.events2)}if(r&&r.getCustomerIDs){e=q;if(g=r.getCustomerIDs())for(d in g)Object.prototype[d]||(f=g[d],"object"==typeof f&&(e||(e={}),f.id&&(e[d+".id"]=f.id),f.authState&&(e[d+".as"]=f.authState)));e&&(c+=a.o("cid",e))}a.AudienceManagement&&a.AudienceManagement.isReady()&&(c+=a.o("d",a.AudienceManagement.getEventCallConfigParams()));for(d=0;d<b.length;d++){e=b[d];g=a[e];f=e.substring(0,4);k=e.substring(4);g||("events"==e&&p?(g=p,p=""):"marketingCloudOrgID"==e&&r&&a.V("ECID")&&
(g=r.marketingCloudOrgID));if(g&&(!n||0<=n.indexOf(","+e+","))){switch(e){case "customerPerspective":e="cp";break;case "marketingCloudOrgID":e="mcorgid";break;case "supplementalDataID":e="sdid";break;case "timestamp":e="ts";break;case "dynamicVariablePrefix":e="D";break;case "visitorID":e="vid";break;case "marketingCloudVisitorID":e="mid";break;case "analyticsVisitorID":e="aid";break;case "audienceManagerLocationHint":e="aamlh";break;case "audienceManagerBlob":e="aamb";break;case "authState":e="as";
break;case "pageURL":e="g";255<g.length&&(a.pageURLRest=g.substring(255),g=g.substring(0,255));break;case "pageURLRest":e="-g";break;case "referrer":e="r";break;case "vmk":case "visitorMigrationKey":e="vmt";break;case "visitorMigrationServer":e="vmf";a.ssl&&a.visitorMigrationServerSecure&&(g="");break;case "visitorMigrationServerSecure":e="vmf";!a.ssl&&a.visitorMigrationServer&&(g="");break;case "charSet":e="ce";break;case "visitorNamespace":e="ns";break;case "cookieDomainPeriods":e="cdp";break;case "cookieLifetime":e=
"cl";break;case "variableProvider":e="vvp";break;case "currencyCode":e="cc";break;case "channel":e="ch";break;case "transactionID":e="xact";break;case "campaign":e="v0";break;case "latitude":e="lat";break;case "longitude":e="lon";break;case "resolution":e="s";break;case "colorDepth":e="c";break;case "javascriptVersion":e="j";break;case "javaEnabled":e="v";break;case "cookiesEnabled":e="k";break;case "browserWidth":e="bw";break;case "browserHeight":e="bh";break;case "connectionType":e="ct";break;case "homepage":e=
"hp";break;case "events":p&&(g+=(""!=g?",":"")+p);if(m)for(k=g.split(","),g="",f=0;f<k.length;f++)l=k[f],h=l.indexOf("="),0<=h&&(l=l.substring(0,h)),h=l.indexOf(":"),0<=h&&(l=l.substring(0,h)),0<=m.indexOf(","+l+",")&&(g+=(g?",":"")+k[f]);break;case "events2":g="";break;case "contextData":c+=a.o("c",a[e],n,e);g="";break;case "lightProfileID":e="mtp";break;case "lightStoreForSeconds":e="mtss";a.lightProfileID||(g="");break;case "lightIncrementBy":e="mti";a.lightProfileID||(g="");break;case "retrieveLightProfiles":e=
"mtsr";break;case "deleteLightProfiles":e="mtsd";break;case "retrieveLightData":a.retrieveLightProfiles&&(c+=a.o("mts",a[e],n,e));g="";break;default:a.Qa(k)&&("prop"==f?e="c"+k:"eVar"==f?e="v"+k:"list"==f?e="l"+k:"hier"==f&&(e="h"+k,g=g.substring(0,255)))}g&&(c+="&"+e+"="+("pev"!=e.substring(0,3)?a.escape(g):g))}"pev3"==e&&a.e&&(c+=a.e)}a.ja&&(c+="&lrt="+a.ja,a.ja=null);return c};a.B=function(a){var b=a.tagName;if("undefined"!=""+a.kc||"undefined"!=""+a.Yb&&"HTML"!=(""+a.Yb).toUpperCase())return"";
b=b&&b.toUpperCase?b.toUpperCase():"";"SHAPE"==b&&(b="");b&&(("INPUT"==b||"BUTTON"==b)&&a.type&&a.type.toUpperCase?b=a.type.toUpperCase():!b&&a.href&&(b="A"));return b};a.Ma=function(a){var b=h.location,d=a.href?a.href:"",f,e,g;f=d.indexOf(":");e=d.indexOf("?");g=d.indexOf("/");d&&(0>f||0<=e&&f>e||0<=g&&f>g)&&(e=a.protocol&&1<a.protocol.length?a.protocol:b.protocol?b.protocol:"",f=b.pathname.lastIndexOf("/"),d=(e?e+"//":"")+(a.host?a.host:b.host?b.host:"")+("/"!=d.substring(0,1)?b.pathname.substring(0,
0>f?0:f)+"/":"")+d);return d};a.L=function(c){var b=a.B(c),d,f,e="",g=0;return b&&(d=c.protocol,f=c.onclick,!c.href||"A"!=b&&"AREA"!=b||f&&d&&!(0>d.toLowerCase().indexOf("javascript"))?f?(e=a.replace(a.replace(a.replace(a.replace(""+f,"\r",""),"\n",""),"\t","")," ",""),g=2):"INPUT"==b||"SUBMIT"==b?(c.value?e=c.value:c.innerText?e=c.innerText:c.textContent&&(e=c.textContent),g=3):"IMAGE"==b&&c.src&&(e=c.src):e=a.Ma(c),e)?{id:e.substring(0,100),type:g}:0};a.ic=function(c){for(var b=a.B(c),d=a.L(c);c&&
!d&&"BODY"!=b;)if(c=c.parentElement?c.parentElement:c.parentNode)b=a.B(c),d=a.L(c);d&&"BODY"!=b||(c=0);c&&(b=c.onclick?""+c.onclick:"",0<=b.indexOf(".tl(")||0<=b.indexOf(".trackLink("))&&(c=0);return c};a.Xb=function(){var c,b,d=a.linkObject,f=a.linkType,e=a.linkURL,g,k;a.la=1;d||(a.la=0,d=a.clickObject);if(d){c=a.B(d);for(b=a.L(d);d&&!b&&"BODY"!=c;)if(d=d.parentElement?d.parentElement:d.parentNode)c=a.B(d),b=a.L(d);b&&"BODY"!=c||(d=0);if(d&&!a.linkObject){var l=d.onclick?""+d.onclick:"";if(0<=l.indexOf(".tl(")||
0<=l.indexOf(".trackLink("))d=0}}else a.la=1;!e&&d&&(e=a.Ma(d));e&&!a.linkLeaveQueryString&&(g=e.indexOf("?"),0<=g&&(e=e.substring(0,g)));if(!f&&e){var m=0,n=0,p;if(a.trackDownloadLinks&&a.linkDownloadFileTypes)for(l=e.toLowerCase(),g=l.indexOf("?"),k=l.indexOf("#"),0<=g?0<=k&&k<g&&(g=k):g=k,0<=g&&(l=l.substring(0,g)),g=a.linkDownloadFileTypes.toLowerCase().split(","),k=0;k<g.length;k++)(p=g[k])&&l.substring(l.length-(p.length+1))=="."+p&&(f="d");if(a.trackExternalLinks&&!f&&(l=e.toLowerCase(),a.Pa(l)&&
(a.linkInternalFilters||(a.linkInternalFilters=h.location.hostname),g=0,a.linkExternalFilters?(g=a.linkExternalFilters.toLowerCase().split(","),m=1):a.linkInternalFilters&&(g=a.linkInternalFilters.toLowerCase().split(",")),g))){for(k=0;k<g.length;k++)p=g[k],0<=l.indexOf(p)&&(n=1);n?m&&(f="e"):m||(f="e")}}a.linkObject=d;a.linkURL=e;a.linkType=f;if(a.trackClickMap||a.trackInlineStats)a.e="",d&&(f=a.pageName,e=1,d=d.sourceIndex,f||(f=a.pageURL,e=0),h.s_objectID&&(b.id=h.s_objectID,d=b.type=1),f&&b&&
b.id&&c&&(a.e="&pid="+a.escape(f.substring(0,255))+(e?"&pidt="+e:"")+"&oid="+a.escape(b.id.substring(0,100))+(b.type?"&oidt="+b.type:"")+"&ot="+c+(d?"&oi="+d:"")))};a.Qb=function(){var c=a.la,b=a.linkType,d=a.linkURL,f=a.linkName;b&&(d||f)&&(b=b.toLowerCase(),"d"!=b&&"e"!=b&&(b="o"),a.pe="lnk_"+b,a.pev1=d?a.escape(d):"",a.pev2=f?a.escape(f):"",c=1);a.abort&&(c=0);if(a.trackClickMap||a.trackInlineStats||a.Tb()){var b={},d=0,e=a.qb(),g=e?e.split("&"):0,k,l,h,e=0;if(g)for(k=0;k<g.length;k++)l=g[k].split("="),
f=a.unescape(l[0]).split(","),l=a.unescape(l[1]),b[l]=f;f=a.account.split(",");k={};for(h in a.contextData)h&&!Object.prototype[h]&&"a.activitymap."==h.substring(0,14)&&(k[h]=a.contextData[h],a.contextData[h]="");a.e=a.o("c",k)+(a.e?a.e:"");if(c||a.e){c&&!a.e&&(e=1);for(l in b)if(!Object.prototype[l])for(h=0;h<f.length;h++)for(e&&(g=b[l].join(","),g==a.account&&(a.e+=("&"!=l.charAt(0)?"&":"")+l,b[l]=[],d=1)),k=0;k<b[l].length;k++)g=b[l][k],g==f[h]&&(e&&(a.e+="&u="+a.escape(g)+("&"!=l.charAt(0)?"&":
"")+l+"&u=0"),b[l].splice(k,1),d=1);c||(d=1);if(d){e="";k=2;!c&&a.e&&(e=a.escape(f.join(","))+"="+a.escape(a.e),k=1);for(l in b)!Object.prototype[l]&&0<k&&0<b[l].length&&(e+=(e?"&":"")+a.escape(b[l].join(","))+"="+a.escape(l),k--);a.yb(e)}}}return c};a.qb=function(){if(a.useLinkTrackSessionStorage){if(a.Da())return h.sessionStorage.getItem(a.P)}else return a.cookieRead(a.P)};a.Da=function(){return h.sessionStorage?!0:!1};a.yb=function(c){a.useLinkTrackSessionStorage?a.Da()&&h.sessionStorage.setItem(a.P,
c):a.cookieWrite(a.P,c)};a.Rb=function(){if(!a.ac){var c=new Date,b=p.location,d,f,e=f=d="",g="",k="",l="1.2",h=a.cookieWrite("s_cc","true",0)?"Y":"N",m="",q="";if(c.setUTCDate&&(l="1.3",(0).toPrecision&&(l="1.5",c=[],c.forEach))){l="1.6";f=0;d={};try{f=new Iterator(d),f.next&&(l="1.7",c.reduce&&(l="1.8",l.trim&&(l="1.8.1",Date.parse&&(l="1.8.2",Object.create&&(l="1.8.5")))))}catch(r){}}d=screen.width+"x"+screen.height;e=navigator.javaEnabled()?"Y":"N";f=screen.pixelDepth?screen.pixelDepth:screen.colorDepth;
g=a.w.innerWidth?a.w.innerWidth:a.d.documentElement.offsetWidth;k=a.w.innerHeight?a.w.innerHeight:a.d.documentElement.offsetHeight;try{a.b.addBehavior("#default#homePage"),m=a.b.jc(b)?"Y":"N"}catch(s){}try{a.b.addBehavior("#default#clientCaps"),q=a.b.connectionType}catch(t){}a.resolution=d;a.colorDepth=f;a.javascriptVersion=l;a.javaEnabled=e;a.cookiesEnabled=h;a.browserWidth=g;a.browserHeight=k;a.connectionType=q;a.homepage=m;a.ac=1}};a.Q={};a.loadModule=function(c,b){var d=a.Q[c];if(!d){d=h["AppMeasurement_Module_"+
c]?new h["AppMeasurement_Module_"+c](a):{};a.Q[c]=a[c]=d;d.jb=function(){return d.tb};d.zb=function(b){if(d.tb=b)a[c+"_onLoad"]=b,a.ea(c+"_onLoad",[a,d],1)||b(a,d)};try{Object.defineProperty?Object.defineProperty(d,"onLoad",{get:d.jb,set:d.zb}):d._olc=1}catch(f){d._olc=1}}b&&(a[c+"_onLoad"]=b,a.ea(c+"_onLoad",[a,d],1)||b(a,d))};a.u=function(c){var b,d;for(b in a.Q)if(!Object.prototype[b]&&(d=a.Q[b])&&(d._olc&&d.onLoad&&(d._olc=0,d.onLoad(a,d)),d[c]&&d[c]()))return 1;return 0};a.Tb=function(){return a.ActivityMap&&
a.ActivityMap._c?!0:!1};a.Ub=function(){var c=Math.floor(1E13*Math.random()),b=a.visitorSampling,d=a.visitorSamplingGroup,d="s_vsn_"+(a.visitorNamespace?a.visitorNamespace:a.account)+(d?"_"+d:""),f=a.cookieRead(d);if(b){b*=100;f&&(f=parseInt(f));if(!f){if(!a.cookieWrite(d,c))return 0;f=c}if(f%1E4>b)return 0}return 1};a.S=function(c,b){var d,f,e,g,k,h,m;m={};for(d=0;2>d;d++)for(f=0<d?a.Fa:a.g,e=0;e<f.length;e++)if(g=f[e],(k=c[g])||c["!"+g]){if(k&&!b&&("contextData"==g||"retrieveLightData"==g)&&a[g])for(h in a[g])k[h]||
(k[h]=a[g][h]);a[g]||(m["!"+g]=1);m[g]=a[g];a[g]=k}return m};a.gc=function(c){var b,d,f,e;for(b=0;2>b;b++)for(d=0<b?a.Fa:a.g,f=0;f<d.length;f++)e=d[f],c[e]=a[e],c[e]||"prop"!==e.substring(0,4)&&"eVar"!==e.substring(0,4)&&"hier"!==e.substring(0,4)&&"list"!==e.substring(0,4)&&"channel"!==e&&"events"!==e&&"eventList"!==e&&"products"!==e&&"productList"!==e&&"purchaseID"!==e&&"transactionID"!==e&&"state"!==e&&"zip"!==e&&"campaign"!==e&&"events2"!==e&&"latitude"!==e&&"longitude"!==e&&"ms_a"!==e&&"contextData"!==
e&&"supplementalDataID"!==e&&"tnt"!==e&&"timestamp"!==e&&"abort"!==e&&"useBeacon"!==e&&"linkObject"!==e&&"clickObject"!==e&&"linkType"!==e&&"linkName"!==e&&"linkURL"!==e&&"bodyClickTarget"!==e&&"bodyClickFunction"!==e||(c["!"+e]=1)};a.Lb=function(a){var b,d,f,e,g,k=0,h,m="",n="";if(a&&255<a.length&&(b=""+a,d=b.indexOf("?"),0<d&&(h=b.substring(d+1),b=b.substring(0,d),e=b.toLowerCase(),f=0,"http://"==e.substring(0,7)?f+=7:"https://"==e.substring(0,8)&&(f+=8),d=e.indexOf("/",f),0<d&&(e=e.substring(f,
d),g=b.substring(d),b=b.substring(0,d),0<=e.indexOf("google")?k=",q,ie,start,search_key,word,kw,cd,":0<=e.indexOf("yahoo.co")?k=",p,ei,":0<=e.indexOf("baidu.")&&(k=",wd,word,"),k&&h)))){if((a=h.split("&"))&&1<a.length){for(f=0;f<a.length;f++)e=a[f],d=e.indexOf("="),0<d&&0<=k.indexOf(","+e.substring(0,d)+",")?m+=(m?"&":"")+e:n+=(n?"&":"")+e;m&&n?h=m+"&"+n:n=""}d=253-(h.length-n.length)-b.length;a=b+(0<d?g.substring(0,d):"")+"?"+h}return a};a.cb=function(c){var b=a.d.visibilityState,d=["webkitvisibilitychange",
"visibilitychange"];b||(b=a.d.webkitVisibilityState);if(b&&"prerender"==b){if(c)for(b=0;b<d.length;b++)a.d.addEventListener(d[b],function(){var b=a.d.visibilityState;b||(b=a.d.webkitVisibilityState);"visible"==b&&c()});return!1}return!0};a.ba=!1;a.H=!1;a.Bb=function(){a.H=!0;a.p()};a.I=!1;a.Cb=function(c){a.marketingCloudVisitorID=c.MCMID;a.visitorOptedOut=c.MCOPTOUT;a.analyticsVisitorID=c.MCAID;a.audienceManagerLocationHint=c.MCAAMLH;a.audienceManagerBlob=c.MCAAMB;a.I=!1;a.p()};a.bb=function(c){a.maxDelay||
(a.maxDelay=250);return a.u("_d")?(c&&setTimeout(function(){c()},a.maxDelay),!1):!0};a.Z=!1;a.G=!1;a.za=function(){a.G=!0;a.p()};a.isReadyToTrack=function(){var c=!0;if(!a.nb()||!a.lb())return!1;a.pb()||(c=!1);a.sb()||(c=!1);return c};a.nb=function(){a.ba||a.H||(a.cb(a.Bb)?a.H=!0:a.ba=!0);return a.ba&&!a.H?!1:!0};a.lb=function(){var c=a.va();if(c)if(a.ra||a.aa)if(a.ra){if(!c.isApproved(c.Categories.ANALYTICS))return!1}else return!1;else return c.fetchPermissions(a.ub,!0),a.aa=!0,!1;return!0};a.V=
function(c){var b=a.va();return b&&!b.isApproved(b.Categories[c])?!1:!0};a.va=function(){return h.adobe&&h.adobe.optIn?h.adobe.optIn:null};a.Y=!0;a.pb=function(){var c=a.T();if(!c||!c.getVisitorValues)return!0;a.Y&&(a.Y=!1,a.I||(a.I=!0,c.getVisitorValues(a.Cb)));return!a.I};a.T=function(){var c=a.visitor;c&&!c.isAllowed()&&(c=null);return c};a.sb=function(){a.Z||a.G||(a.bb(a.za)?a.G=!0:a.Z=!0);return a.Z&&!a.G?!1:!0};a.aa=!1;a.ub=function(){a.aa=!1;a.ra=!0};a.j=q;a.q=0;a.callbackWhenReadyToTrack=
function(c,b,d){var f;f={};f.Gb=c;f.Fb=b;f.Db=d;a.j==q&&(a.j=[]);a.j.push(f);0==a.q&&(a.q=setInterval(a.p,100))};a.p=function(){var c;if(a.isReadyToTrack()&&(a.Ab(),a.j!=q))for(;0<a.j.length;)c=a.j.shift(),c.Fb.apply(c.Gb,c.Db)};a.Ab=function(){a.q&&(clearInterval(a.q),a.q=0)};a.ta=function(c){var b,d={};a.gc(d);if(c!=q)for(b in c)d[b]=c[b];a.callbackWhenReadyToTrack(a,a.Ea,[d]);a.Ca()};a.Nb=function(){var c=a.cookieRead("s_fid"),b="",d="",f;f=8;var e=4;if(!c||0>c.indexOf("-")){for(c=0;16>c;c++)f=
Math.floor(Math.random()*f),b+="0123456789ABCDEF".substring(f,f+1),f=Math.floor(Math.random()*e),d+="0123456789ABCDEF".substring(f,f+1),f=e=16;c=b+"-"+d}a.cookieWrite("s_fid",c,1)||(c=0);return c};a.Ea=function(c){var b=new Date,d="s"+Math.floor(b.getTime()/108E5)%10+Math.floor(1E13*Math.random()),f=b.getYear(),f="t="+a.escape(b.getDate()+"/"+b.getMonth()+"/"+(1900>f?f+1900:f)+" "+b.getHours()+":"+b.getMinutes()+":"+b.getSeconds()+" "+b.getDay()+" "+b.getTimezoneOffset()),e=a.T(),g;c&&(g=a.S(c,1));
a.Ub()&&!a.visitorOptedOut&&(a.wa()||(a.fid=a.Nb()),a.Xb(),a.usePlugins&&a.doPlugins&&a.doPlugins(a),a.account&&(a.abort||(a.trackOffline&&!a.timestamp&&(a.timestamp=Math.floor(b.getTime()/1E3)),c=h.location,a.pageURL||(a.pageURL=c.href?c.href:c),a.referrer||a.Za||(c=a.Util.getQueryParam("adobe_mc_ref",null,null,!0),a.referrer=c||void 0===c?void 0===c?"":c:p.document.referrer),a.Za=1,a.referrer=a.Lb(a.referrer),a.u("_g")),a.Qb()&&!a.abort&&(e&&a.V("TARGET")&&!a.supplementalDataID&&e.getSupplementalDataID&&
(a.supplementalDataID=e.getSupplementalDataID("AppMeasurement:"+a._in,a.expectSupplementalData?!1:!0)),a.V("AAM")||(a.contextData["cm.ssf"]=1),a.Rb(),a.vb(),f+=a.Pb(),a.rb(d,f),a.u("_t"),a.referrer="")));a.Ca();g&&a.S(g,1)};a.t=a.track=function(c,b){b&&a.S(b);a.Y=!0;a.isReadyToTrack()?null!=a.j&&0<a.j.length?(a.ta(c),a.p()):a.Ea(c):a.ta(c)};a.vb=function(){a.writeSecureCookies&&!a.ssl&&a.$a()};a.$a=function(){a.contextData.excCodes=a.contextData.excCodes?a.contextData.excCodes:[];a.contextData.excCodes.push(1)};
a.Ca=function(){a.abort=a.supplementalDataID=a.timestamp=a.pageURLRest=a.linkObject=a.clickObject=a.linkURL=a.linkName=a.linkType=h.s_objectID=a.pe=a.pev1=a.pev2=a.pev3=a.e=a.lightProfileID=a.useBeacon=a.referrer=0;a.contextData&&a.contextData.excCodes&&(a.contextData.excCodes=0)};a.Ba=[];a.registerPreTrackCallback=function(c){for(var b=[],d=1;d<arguments.length;d++)b.push(arguments[d]);"function"==typeof c?a.Ba.push([c,b]):a.debugTracking&&a.C("DEBUG: Non function type passed to registerPreTrackCallback")};
a.gb=function(c){a.ua(a.Ba,c)};a.Aa=[];a.registerPostTrackCallback=function(c){for(var b=[],d=1;d<arguments.length;d++)b.push(arguments[d]);"function"==typeof c?a.Aa.push([c,b]):a.debugTracking&&a.C("DEBUG: Non function type passed to registerPostTrackCallback")};a.fb=function(c){a.ua(a.Aa,c)};a.ua=function(c,b){if("object"==typeof c)for(var d=0;d<c.length;d++){var f=c[d][0],e=c[d][1].slice();e.unshift(b);if("function"==typeof f)try{f.apply(null,e)}catch(g){a.debugTracking&&a.C(g.message)}}};a.tl=
a.trackLink=function(c,b,d,f,e){a.linkObject=c;a.linkType=b;a.linkName=d;e&&(a.bodyClickTarget=c,a.bodyClickFunction=e);return a.track(f)};a.trackLight=function(c,b,d,f){a.lightProfileID=c;a.lightStoreForSeconds=b;a.lightIncrementBy=d;return a.track(f)};a.clearVars=function(){var c,b;for(c=0;c<a.g.length;c++)if(b=a.g[c],"prop"==b.substring(0,4)||"eVar"==b.substring(0,4)||"hier"==b.substring(0,4)||"list"==b.substring(0,4)||"channel"==b||"events"==b||"eventList"==b||"products"==b||"productList"==b||
"purchaseID"==b||"transactionID"==b||"state"==b||"zip"==b||"campaign"==b)a[b]=void 0};a.tagContainerMarker="";a.rb=function(c,b){var d=a.hb()+"/"+c+"?AQB=1&ndh=1&pf=1&"+(a.ya()?"callback=s_c_il["+a._in+"].doPostbacks&et=1&":"")+b+"&AQE=1";a.gb(d);a.eb(d);a.U()};a.hb=function(){var c=a.ib();return"http"+(a.ssl?"s":"")+"://"+c+"/b/ss/"+a.account+"/"+(a.mobile?"5.":"")+(a.ya()?"10":"1")+"/JS-"+a.version+(a.$b?"T":"")+(a.tagContainerMarker?"-"+a.tagContainerMarker:"")};a.ya=function(){return a.AudienceManagement&&
a.AudienceManagement.isReady()||0!=a.usePostbacks};a.ib=function(){var c=a.dc,b=a.trackingServer;b?a.trackingServerSecure&&a.ssl&&(b=a.trackingServerSecure):(c=c?(""+c).toLowerCase():"d1","d1"==c?c="112":"d2"==c&&(c="122"),b=a.kb()+"."+c+".2o7.net");return b};a.kb=function(){var c=a.visitorNamespace;c||(c=a.account.split(",")[0],c=c.replace(/[^0-9a-z]/gi,""));return c};a.Ya=/{(%?)(.*?)(%?)}/;a.fc=RegExp(a.Ya.source,"g");a.Kb=function(c){if("object"==typeof c.dests)for(var b=0;b<c.dests.length;++b){var d=
c.dests[b];if("string"==typeof d.c&&"aa."==d.id.substr(0,3))for(var f=d.c.match(a.fc),e=0;e<f.length;++e){var g=f[e],k=g.match(a.Ya),h="";"%"==k[1]&&"timezone_offset"==k[2]?h=(new Date).getTimezoneOffset():"%"==k[1]&&"timestampz"==k[2]&&(h=a.Ob());d.c=d.c.replace(g,a.escape(h))}}};a.Ob=function(){var c=new Date,b=new Date(6E4*Math.abs(c.getTimezoneOffset()));return a.k(4,c.getFullYear())+"-"+a.k(2,c.getMonth()+1)+"-"+a.k(2,c.getDate())+"T"+a.k(2,c.getHours())+":"+a.k(2,c.getMinutes())+":"+a.k(2,c.getSeconds())+
(0<c.getTimezoneOffset()?"-":"+")+a.k(2,b.getUTCHours())+":"+a.k(2,b.getUTCMinutes())};a.k=function(a,b){return(Array(a+1).join(0)+b).slice(-a)};a.pa={};a.doPostbacks=function(c){if("object"==typeof c)if(a.Kb(c),"object"==typeof a.AudienceManagement&&"function"==typeof a.AudienceManagement.isReady&&a.AudienceManagement.isReady()&&"function"==typeof a.AudienceManagement.passData)a.AudienceManagement.passData(c);else if("object"==typeof c&&"object"==typeof c.dests)for(var b=0;b<c.dests.length;++b){var d=
c.dests[b];"object"==typeof d&&"string"==typeof d.c&&"string"==typeof d.id&&"aa."==d.id.substr(0,3)&&(a.pa[d.id]=new Image,a.pa[d.id].alt="",a.pa[d.id].src=d.c)}};a.eb=function(c){a.i||a.Sb();a.i.push(c);a.ia=a.A();a.Xa()};a.Sb=function(){a.i=a.Vb();a.i||(a.i=[])};a.Vb=function(){var c,b;if(a.oa()){try{(b=h.localStorage.getItem(a.ma()))&&(c=h.JSON.parse(b))}catch(d){}return c}};a.oa=function(){var c=!0;a.trackOffline&&a.offlineFilename&&h.localStorage&&h.JSON||(c=!1);return c};a.Na=function(){var c=
0;a.i&&(c=a.i.length);a.l&&c++;return c};a.U=function(){if(a.l&&(a.v&&a.v.complete&&a.v.D&&a.v.R(),a.l))return;a.Oa=q;if(a.na)a.ia>a.N&&a.Va(a.i),a.qa(500);else{var c=a.Eb();if(0<c)a.qa(c);else if(c=a.La())a.l=1,a.Wb(c),a.Zb(c)}};a.qa=function(c){a.Oa||(c||(c=0),a.Oa=setTimeout(a.U,c))};a.Eb=function(){var c;if(!a.trackOffline||0>=a.offlineThrottleDelay)return 0;c=a.A()-a.Ta;return a.offlineThrottleDelay<c?0:a.offlineThrottleDelay-c};a.La=function(){if(0<a.i.length)return a.i.shift()};a.Wb=function(c){if(a.debugTracking){var b=
"AppMeasurement Debug: "+c;c=c.split("&");var d;for(d=0;d<c.length;d++)b+="\n\t"+a.unescape(c[d]);a.C(b)}};a.wa=function(){return a.marketingCloudVisitorID||a.analyticsVisitorID};a.X=!1;var t;try{t=JSON.parse('{"x":"y"}')}catch(v){t=null}t&&"y"==t.x?(a.X=!0,a.W=function(a){return JSON.parse(a)}):h.$&&h.$.parseJSON?(a.W=function(a){return h.$.parseJSON(a)},a.X=!0):a.W=function(){return null};a.Zb=function(c){var b,d,f;a.mb(c)&&(d=1,b={send:function(c){a.useBeacon=!1;navigator.sendBeacon(c)?b.R():b.ga()}});
!b&&a.wa()&&2047<c.length&&(a.ab()&&(d=2,b=new XMLHttpRequest),b&&(a.AudienceManagement&&a.AudienceManagement.isReady()||0!=a.usePostbacks)&&(a.X?b.Ga=!0:b=0));!b&&a.ec&&(c=c.substring(0,2047));!b&&a.d.createElement&&(0!=a.usePostbacks||a.AudienceManagement&&a.AudienceManagement.isReady())&&(b=a.d.createElement("SCRIPT"))&&"async"in b&&((f=(f=a.d.getElementsByTagName("HEAD"))&&f[0]?f[0]:a.d.body)?(b.type="text/javascript",b.setAttribute("async","async"),d=3):b=0);b||(b=new Image,b.alt="",b.abort||
"undefined"===typeof h.InstallTrigger||(b.abort=function(){b.src=q}));b.Ua=Date.now();b.Ia=function(){try{b.D&&(clearTimeout(b.D),b.D=0)}catch(a){}};b.onload=b.R=function(){b.Ua&&(a.ja=Date.now()-b.Ua);a.fb(c);b.Ia();a.Ib();a.ca();a.l=0;a.U();if(b.Ga){b.Ga=!1;try{a.doPostbacks(a.W(b.responseText))}catch(d){}}};b.onabort=b.onerror=b.ga=function(){b.Ia();(a.trackOffline||a.na)&&a.l&&a.i.unshift(a.Hb);a.l=0;a.ia>a.N&&a.Va(a.i);a.ca();a.qa(500)};b.onreadystatechange=function(){4==b.readyState&&(200==
b.status?b.R():b.ga())};a.Ta=a.A();if(1===d)b.send(c);else if(2===d)f=c.indexOf("?"),d=c.substring(0,f),f=c.substring(f+1),f=f.replace(/&callback=[a-zA-Z0-9_.\[\]]+/,""),b.open("POST",d,!0),b.withCredentials=!0,b.send(f);else if(b.src=c,3===d){if(a.Ra)try{f.removeChild(a.Ra)}catch(e){}f.firstChild?f.insertBefore(b,f.firstChild):f.appendChild(b);a.Ra=a.v}b.D=setTimeout(function(){b.D&&(b.complete?b.R():(a.trackOffline&&b.abort&&b.abort(),b.ga()))},5E3);a.Hb=c;a.v=h["s_i_"+a.replace(a.account,",","_")]=
b;if(a.useForcedLinkTracking&&a.J||a.bodyClickFunction)a.forcedLinkTrackingTimeout||(a.forcedLinkTrackingTimeout=250),a.da=setTimeout(a.ca,a.forcedLinkTrackingTimeout)};a.mb=function(c){var b=!1;navigator.sendBeacon&&(a.ob(c)?b=!0:a.useBeacon&&(b=!0));a.xb(c)&&(b=!1);return b};a.ob=function(a){return a&&0<a.indexOf("pe=lnk_e")?!0:!1};a.xb=function(a){return 64E3<=a.length};a.ab=function(){return"undefined"!==typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest?!0:!1};a.Ib=function(){if(a.oa()&&
!(a.Sa>a.N))try{h.localStorage.removeItem(a.ma()),a.Sa=a.A()}catch(c){}};a.Va=function(c){if(a.oa()){a.Xa();try{h.localStorage.setItem(a.ma(),h.JSON.stringify(c)),a.N=a.A()}catch(b){}}};a.Xa=function(){if(a.trackOffline){if(!a.offlineLimit||0>=a.offlineLimit)a.offlineLimit=10;for(;a.i.length>a.offlineLimit;)a.La()}};a.forceOffline=function(){a.na=!0};a.forceOnline=function(){a.na=!1};a.ma=function(){return a.offlineFilename+"-"+a.visitorNamespace+a.account};a.A=function(){return(new Date).getTime()};
a.Pa=function(a){a=a.toLowerCase();return 0!=a.indexOf("#")&&0!=a.indexOf("about:")&&0!=a.indexOf("opera:")&&0!=a.indexOf("javascript:")?!0:!1};a.setTagContainer=function(c){var b,d,f;a.$b=c;for(b=0;b<a._il.length;b++)if((d=a._il[b])&&"s_l"==d._c&&d.tagContainerName==c){a.S(d);if(d.lmq)for(b=0;b<d.lmq.length;b++)f=d.lmq[b],a.loadModule(f.n);if(d.ml)for(f in d.ml)if(a[f])for(b in c=a[f],f=d.ml[f],f)!Object.prototype[b]&&("function"!=typeof f[b]||0>(""+f[b]).indexOf("s_c_il"))&&(c[b]=f[b]);if(d.mmq)for(b=
0;b<d.mmq.length;b++)f=d.mmq[b],a[f.m]&&(c=a[f.m],c[f.f]&&"function"==typeof c[f.f]&&(f.a?c[f.f].apply(c,f.a):c[f.f].apply(c)));if(d.tq)for(b=0;b<d.tq.length;b++)a.track(d.tq[b]);d.s=a;break}};a.Util={urlEncode:a.escape,urlDecode:a.unescape,cookieRead:a.cookieRead,cookieWrite:a.cookieWrite,getQueryParam:function(c,b,d,f){var e,g="";b||(b=a.pageURL?a.pageURL:h.location);d=d?d:"&";if(!c||!b)return g;b=""+b;e=b.indexOf("?");if(0>e)return g;b=d+b.substring(e+1)+d;if(!f||!(0<=b.indexOf(d+c+d)||0<=b.indexOf(d+
c+"="+d))){e=b.indexOf("#");0<=e&&(b=b.substr(0,e)+d);e=b.indexOf(d+c+"=");if(0>e)return g;b=b.substring(e+d.length+c.length+1);e=b.indexOf(d);0<=e&&(b=b.substring(0,e));0<b.length&&(g=a.unescape(b));return g}},getIeVersion:function(){return document.documentMode?document.documentMode:a.xa()?7:null}};a.F="supplementalDataID timestamp dynamicVariablePrefix visitorID marketingCloudVisitorID analyticsVisitorID audienceManagerLocationHint authState fid vmk visitorMigrationKey visitorMigrationServer visitorMigrationServerSecure charSet visitorNamespace cookieDomainPeriods fpCookieDomainPeriods cookieLifetime pageName pageURL customerPerspective referrer contextData currencyCode lightProfileID lightStoreForSeconds lightIncrementBy retrieveLightProfiles deleteLightProfiles retrieveLightData".split(" ");
a.g=a.F.concat("purchaseID variableProvider channel server pageType transactionID campaign state zip events events2 products audienceManagerBlob tnt".split(" "));a.ka="timestamp charSet visitorNamespace cookieDomainPeriods cookieLifetime contextData lightProfileID lightStoreForSeconds lightIncrementBy".split(" ");a.O=a.ka.slice(0);a.Fa="account allAccounts debugTracking visitor visitorOptedOut trackOffline offlineLimit offlineThrottleDelay offlineFilename usePlugins doPlugins configURL visitorSampling visitorSamplingGroup linkObject clickObject linkURL linkName linkType trackDownloadLinks trackExternalLinks trackClickMap trackInlineStats linkLeaveQueryString linkTrackVars linkTrackEvents linkDownloadFileTypes linkExternalFilters linkInternalFilters useForcedLinkTracking forcedLinkTrackingTimeout writeSecureCookies useLinkTrackSessionStorage trackingServer trackingServerSecure ssl abort mobile dc lightTrackVars maxDelay expectSupplementalData useBeacon usePostbacks registerPreTrackCallback registerPostTrackCallback bodyClickTarget bodyClickFunction AudienceManagement".split(" ");
for(m=0;250>=m;m++)76>m&&(a.g.push("prop"+m),a.O.push("prop"+m)),a.g.push("eVar"+m),a.O.push("eVar"+m),6>m&&a.g.push("hier"+m),4>m&&a.g.push("list"+m);m="pe pev1 pev2 pev3 latitude longitude resolution colorDepth javascriptVersion javaEnabled cookiesEnabled browserWidth browserHeight connectionType homepage pageURLRest marketingCloudOrgID ms_a".split(" ");a.g=a.g.concat(m);a.F=a.F.concat(m);a.ssl=0<=h.location.protocol.toLowerCase().indexOf("https");a.charSet="UTF-8";a.contextData={};a.writeSecureCookies=
!1;a.offlineThrottleDelay=0;a.offlineFilename="AppMeasurement.offline";a.P="s_sq";a.Ta=0;a.ia=0;a.N=0;a.Sa=0;a.linkDownloadFileTypes="exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";a.w=h;a.d=h.document;a.ca=function(){a.da&&(h.clearTimeout(a.da),a.da=q);a.bodyClickTarget&&a.J&&a.bodyClickTarget.dispatchEvent(a.J);a.bodyClickFunction&&("function"==typeof a.bodyClickFunction?a.bodyClickFunction():a.bodyClickTarget&&a.bodyClickTarget.href&&(a.d.location=a.bodyClickTarget.href));a.bodyClickTarget=
a.J=a.bodyClickFunction=0};a.Wa=function(){a.b=a.d.body;a.b?(a.r=function(c){var b,d,f,e,g;if(!(a.d&&a.d.getElementById("cppXYctnr")||c&&c["s_fe_"+a._in])){if(a.Ha)if(a.useForcedLinkTracking)a.b.removeEventListener("click",a.r,!1);else{a.b.removeEventListener("click",a.r,!0);a.Ha=a.useForcedLinkTracking=0;return}else a.useForcedLinkTracking=0;a.clickObject=c.srcElement?c.srcElement:c.target;try{if(!a.clickObject||a.M&&a.M==a.clickObject||!(a.clickObject.tagName||a.clickObject.parentElement||a.clickObject.parentNode))a.clickObject=
0;else{var k=a.M=a.clickObject;a.ha&&(clearTimeout(a.ha),a.ha=0);a.ha=setTimeout(function(){a.M==k&&(a.M=0)},1E4);f=a.Na();a.track();if(f<a.Na()&&a.useForcedLinkTracking&&c.target){for(e=c.target;e&&e!=a.b&&"A"!=e.tagName.toUpperCase()&&"AREA"!=e.tagName.toUpperCase();)e=e.parentNode;if(e&&(g=e.href,a.Pa(g)||(g=0),d=e.target,c.target.dispatchEvent&&g&&(!d||"_self"==d||"_top"==d||"_parent"==d||h.name&&d==h.name))){try{b=a.d.createEvent("MouseEvents")}catch(l){b=new h.MouseEvent}if(b){try{b.initMouseEvent("click",
c.bubbles,c.cancelable,c.view,c.detail,c.screenX,c.screenY,c.clientX,c.clientY,c.ctrlKey,c.altKey,c.shiftKey,c.metaKey,c.button,c.relatedTarget)}catch(m){b=0}b&&(b["s_fe_"+a._in]=b.s_fe=1,c.stopPropagation(),c.stopImmediatePropagation&&c.stopImmediatePropagation(),c.preventDefault(),a.bodyClickTarget=c.target,a.J=b)}}}}}catch(n){a.clickObject=0}}},a.b&&a.b.attachEvent?a.b.attachEvent("onclick",a.r):a.b&&a.b.addEventListener&&(navigator&&(0<=navigator.userAgent.indexOf("WebKit")&&a.d.createEvent||
0<=navigator.userAgent.indexOf("Firefox/2")&&h.MouseEvent)&&(a.Ha=1,a.useForcedLinkTracking=1,a.b.addEventListener("click",a.r,!0)),a.b.addEventListener("click",a.r,!1))):setTimeout(a.Wa,30)};a.ec=a.xa();a.Jb();a.lc||(r?a.setAccount(r):a.C("Error, missing Report Suite ID in AppMeasurement initialization"),a.Wa(),a.loadModule("ActivityMap"))}
function s_gi(r){var a,h=window.s_c_il,q,p,m=r.split(","),s,u,t=0;if(h)for(q=0;!t&&q<h.length;){a=h[q];if("s_c"==a._c&&(a.account||a.oun))if(a.account&&a.account==r)t=1;else for(p=a.account?a.account:a.oun,p=a.allAccounts?a.allAccounts:p.split(","),s=0;s<m.length;s++)for(u=0;u<p.length;u++)m[s]==p[u]&&(t=1);q++}t?a.setAccount&&a.setAccount(r):a=new AppMeasurement(r);return a}AppMeasurement.getInstance=s_gi;window.s_objectID||(window.s_objectID=0);
function s_pgicq(){var r=window,a=r.s_giq,h,q,p;if(a)for(h=0;h<a.length;h++)q=a[h],p=s_gi(q.oun),p.setAccount(q.un),p.setTagContainer(q.tagContainerName);r.s_giq=0}s_pgicq();

function AppMeasurement_Module_AudienceManagement(d){var a=this;a.s=d;var b=window;b.s_c_in||(b.s_c_il=[],b.s_c_in=0);a._il=b.s_c_il;a._in=b.s_c_in;a._il[a._in]=a;b.s_c_in++;a._c="s_m";a.setup=function(c){b.DIL&&c&&(c.disableDefaultRequest=!0,c.disableCORS=!0,c.secureDataCollection=!1,a.instance=b.DIL.create(c),a.tools=b.DIL.tools)};a.isReady=function(){return a.instance?!0:!1};a.getEventCallConfigParams=function(){return a.instance&&a.instance.api&&a.instance.api.getEventCallConfigParams?a.instance.api.getEventCallConfigParams():
{}};a.passData=function(b){a.instance&&a.instance.api&&a.instance.api.passData&&a.instance.api.passData(b)}}
!function(){"use strict";var r,o,a;"function"!=typeof window.DIL&&(window.DIL=function(n){var c,e,I,r,u,h,t,o,s,i,a,d,y,l,f,g,p,m,b,v,D,O=[],C={};function S(e){return void 0===e||!0===e}n!==Object(n)&&(n={}),I=n.partner,r=n.containerNSID,u=n.mappings,h=n.uuidCookie,t=!0===n.enableErrorReporting,o=n.visitorService,s=n.declaredId,i=!0===n.delayAllUntilWindowLoad,a=S(n.secureDataCollection),d="boolean"==typeof n.isCoopSafe?n.isCoopSafe:null,y=S(n.enableHrefererParam),l=S(n.enableLogging),f=S(n.enableUrlDestinations),g=S(n.enableCookieDestinations),p=!0===n.disableDefaultRequest,m=n.afterResultForDefaultRequest,b=n.visitorConstructor,v=!0===n.disableCORS,D=!0===n.ignoreHardDependencyOnVisitorAPI,t&&DIL.errorModule.activate(),D&&O.push("Warning: this instance is configured to ignore the hard dependency on the VisitorAPI service. This means that no URL destinations will be fired if the instance has no connection to VisitorAPI. If the VisitorAPI service is not instantiated, ID syncs will not be fired either.");var w=!0===window._dil_unit_tests;if((c=arguments[1])&&O.push(c+""),!I||"string"!=typeof I){var _={name:"error",message:c="DIL partner is invalid or not specified in initConfig",filename:"dil.js"};return DIL.errorModule.handleError(_),new Error(c)}if(c="DIL containerNSID is invalid or not specified in initConfig, setting to default of 0",!r&&"number"!=typeof r||(r=parseInt(r,10),!isNaN(r)&&0<=r&&(c="")),c&&(r=0,O.push(c),c=""),(e=DIL.getDil(I,r))instanceof DIL&&e.api.getPartner()===I&&e.api.getContainerNSID()===r)return e;if(!(this instanceof DIL))return new DIL(n,"DIL was not instantiated with the 'new' operator, returning a valid instance with partner = "+I+" and containerNSID = "+r);DIL.registerDil(this,I,r);var R={doesConsoleLogExist:window.console===Object(window.console)&&"function"==typeof window.console.log,logMemo:{},log:function(e){O.push(e),l&&this.doesConsoleLogExist&&Function.prototype.bind.call(window.console.log,window.console).apply(window.console,arguments)},logOnce:function(e){this.logMemo[e]||(this.logMemo[e]=!0,R.log(e))}},E={IS_HTTPS:a||"https:"===document.location.protocol,SIX_MONTHS_IN_MINUTES:259200,IE_VERSION:function(){if(document.documentMode)return document.documentMode;for(var e=7;4<e;e--){var t=document.createElement("div");if(t.innerHTML="\x3c!--[if IE "+e+"]><span></span><![endif]--\x3e",t.getElementsByTagName("span").length)return t=null,e}return null}()};E.IS_IE_LESS_THAN_10="number"==typeof E.IE_VERSION&&E.IE_VERSION<10;var P={stuffed:{}},L={},A={firingQueue:[],fired:[],firing:!1,sent:[],errored:[],reservedKeys:{sids:!0,pdata:!0,logdata:!0,callback:!0,postCallbackFn:!0,useImageRequest:!0},firstRequestHasFired:!1,abortRequests:!1,num_of_cors_responses:0,num_of_cors_errors:0,corsErrorSources:[],num_of_img_responses:0,num_of_img_errors:0,platformParams:{d_nsid:r+"",d_rtbd:"json",d_jsonv:DIL.jsonVersion+"",d_dst:"1"},nonModStatsParams:{d_rtbd:!0,d_dst:!0,d_cts:!0,d_rs:!0},modStatsParams:null,adms:{TIME_TO_CATCH_ALL_REQUESTS_RELEASE:3e4,calledBack:!1,mid:null,noVisitorAPI:null,VisitorAPI:null,instance:null,releaseType:"no VisitorAPI",isOptedOut:!0,isOptedOutCallbackCalled:!1,admsProcessingStarted:!1,process:function(e){try{if(this.admsProcessingStarted)return;this.admsProcessingStarted=!0;var t,n,s,i=o;if("function"!=typeof e||"function"!=typeof e.getInstance)throw this.noVisitorAPI=!0,new Error("Visitor does not exist.");if(i!==Object(i)||!(t=i.namespace)||"string"!=typeof t)throw this.releaseType="no namespace",new Error("DIL.create() needs the initConfig property `visitorService`:{namespace:'<Experience Cloud Org ID>'}");if((n=e.getInstance(t,{idSyncContainerID:r}))!==Object(n)||"function"!=typeof n.isAllowed||"function"!=typeof n.getMarketingCloudVisitorID||"function"!=typeof n.getCustomerIDs||"function"!=typeof n.isOptedOut||"function"!=typeof n.publishDestinations)throw this.releaseType="invalid instance",s="Invalid Visitor instance.",n===Object(n)&&"function"!=typeof n.publishDestinations&&(s+=" In particular, visitorInstance.publishDestinations is not a function. This is needed to fire URL destinations in DIL v8.0+ and should be present in Visitor v3.3.0+ ."),new Error(s);if(this.VisitorAPI=e,!n.isAllowed())return this.releaseType="VisitorAPI is not allowed to write cookies",void this.releaseRequests();this.instance=n,this.waitForMidToReleaseRequests()}catch(e){if(!D)throw new Error("Error in processing Visitor API, which is a hard dependency for DIL v8.0+: "+e.message);this.releaseRequests()}},waitForMidToReleaseRequests:function(){var t=this;this.instance&&(this.instance.getMarketingCloudVisitorID(function(e){t.mid=e,t.releaseType="VisitorAPI",t.releaseRequests()},!0),(!N.exists||!N.isIabContext&&N.isApproved()||N.isIabContext&&B.hasGoSignal())&&setTimeout(function(){"VisitorAPI"!==t.releaseType&&(t.releaseType="timeout",t.releaseRequests())},this.getLoadTimeout()))},releaseRequests:function(){this.calledBack=!0,A.registerRequest()},getMarketingCloudVisitorID:function(){return this.instance?this.instance.getMarketingCloudVisitorID():null},getMIDQueryString:function(){var e=k.isPopulatedString,t=this.getMarketingCloudVisitorID();return e(this.mid)&&this.mid===t||(this.mid=t),e(this.mid)?"d_mid="+this.mid+"&":""},getCustomerIDs:function(){return this.instance?this.instance.getCustomerIDs():null},getCustomerIDsQueryString:function(e){if(e!==Object(e))return"";var t,n,s,i,r="",o=[],a=[];for(t in e)e.hasOwnProperty(t)&&(n=e[a[0]=t])===Object(n)&&(a[1]=n.id||"",a[2]=n.authState||0,o.push(a),a=[]);if(i=o.length)for(s=0;s<i;s++)r+="&d_cid_ic="+x.encodeAndBuildRequest(o[s],"%01");return r},getIsOptedOut:function(){this.instance?this.instance.isOptedOut([this,this.isOptedOutCallback],this.VisitorAPI.OptOut.GLOBAL,!0):(this.isOptedOut=!1,this.isOptedOutCallbackCalled=!0)},isOptedOutCallback:function(e){this.isOptedOut=e,this.isOptedOutCallbackCalled=!0,A.registerRequest(),N.isIabContext()&&B.checkQueryStringObject()},getLoadTimeout:function(){var e=this.instance;if(e){if("function"==typeof e.getLoadTimeout)return e.getLoadTimeout();if(void 0!==e.loadTimeout)return e.loadTimeout}return this.TIME_TO_CATCH_ALL_REQUESTS_RELEASE}},declaredId:{declaredId:{init:null,request:null},declaredIdCombos:{},setDeclaredId:function(e,t){var n=k.isPopulatedString,s=encodeURIComponent;if(e===Object(e)&&n(t)){var i=e.dpid,r=e.dpuuid,o=null;if(n(i)&&n(r))return o=s(i)+"$"+s(r),!0===this.declaredIdCombos[o]?"setDeclaredId: combo exists for type '"+t+"'":(this.declaredIdCombos[o]=!0,this.declaredId[t]={dpid:i,dpuuid:r},"setDeclaredId: succeeded for type '"+t+"'")}return"setDeclaredId: failed for type '"+t+"'"},getDeclaredIdQueryString:function(){var e=this.declaredId.request,t=this.declaredId.init,n=encodeURIComponent,s="";return null!==e?s="&d_dpid="+n(e.dpid)+"&d_dpuuid="+n(e.dpuuid):null!==t&&(s="&d_dpid="+n(t.dpid)+"&d_dpuuid="+n(t.dpuuid)),s}},registerRequest:function(e){var t,n=this.firingQueue;e===Object(e)&&(n.push(e),e.isDefaultRequest||(p=!0)),this.firing||!n.length||i&&!DIL.windowLoaded||(this.adms.isOptedOutCallbackCalled||this.adms.getIsOptedOut(),this.adms.calledBack&&!this.adms.isOptedOut&&this.adms.isOptedOutCallbackCalled&&(N.isApproved()||B.hasGoSignal())&&(this.adms.isOptedOutCallbackCalled=!1,(t=n.shift()).src=t.src.replace(/&d_nsid=/,"&"+this.adms.getMIDQueryString()+B.getQueryString()+"d_nsid="),k.isPopulatedString(t.corsPostData)&&(t.corsPostData=t.corsPostData.replace(/^d_nsid=/,this.adms.getMIDQueryString()+B.getQueryString()+"d_nsid=")),V.fireRequest(t),this.firstRequestHasFired||"script"!==t.tag&&"cors"!==t.tag||(this.firstRequestHasFired=!0)))},processVisitorAPI:function(){this.adms.process(b||window.Visitor)},getCoopQueryString:function(){var e="";return!0===d?e="&d_coop_safe=1":!1===d&&(e="&d_coop_unsafe=1"),e}};C.requestController=A;var q,j,T={sendingMessages:!1,messages:[],messagesPosted:[],destinations:[],destinationsPosted:[],jsonForComparison:[],jsonDuplicates:[],jsonWaiting:[],jsonProcessed:[],publishDestinationsVersion:null,requestToProcess:function(e,t){var n,s=this;function i(){s.jsonForComparison.push(e),s.jsonWaiting.push([e,t])}if(e&&!k.isEmptyObject(e))if(n=JSON.stringify(e.dests||[]),this.jsonForComparison.length){var r,o,a,d=!1;for(r=0,o=this.jsonForComparison.length;r<o;r++)if(a=this.jsonForComparison[r],n===JSON.stringify(a.dests||[])){d=!0;break}d?this.jsonDuplicates.push(e):i()}else i();if(this.jsonWaiting.length){var u=this.jsonWaiting.shift();this.process(u[0],u[1]),this.requestToProcess()}this.messages.length&&!this.sendingMessages&&this.sendMessages()},process:function(e){if(f){var t,n,s,i,r,o,a=encodeURIComponent,d=this.getPublishDestinationsVersion(),u=!1;if(-1!==d){if((t=e.dests)&&t instanceof Array&&(n=t.length)){for(s=0;s<n;s++)i=t[s],o=[a("dests"),a(i.id||""),a(i.y||""),a(i.c||"")].join("|"),this.addMessage(o),r={url:i.c,hideReferrer:void 0===i.hr||!!i.hr,message:o},this.addDestination(r),void 0!==i.hr&&(u=!0);1===d&&u&&R.logOnce("Warning: visitorInstance.publishDestinations version is old (Visitor v3.3.0 to v4.0.0). URL destinations will not have the option of being fired on page, only in the iframe.")}this.jsonProcessed.push(e)}}},addMessage:function(e){this.messages.push(e)},addDestination:function(e){this.destinations.push(e)},sendMessages:function(){this.sendingMessages||(this.sendingMessages=!0,f&&this.messages.length&&this.publishDestinations())},publishDestinations:function(){function e(e){R.log("visitor.publishDestinations() result: "+(e.error||e.message)),n.sendingMessages=!1,n.requestToProcess()}function t(){n.messages=[],n.destinations=[]}var n=this,s=A.adms.instance,i=[],r=[];return 1===this.publishDestinationsVersion?(x.extendArray(i,this.messages),x.extendArray(this.messagesPosted,this.messages),t(),s.publishDestinations(I,i,e),"Called visitor.publishDestinations() version 1"):1<this.publishDestinationsVersion?(x.extendArray(r,this.destinations),x.extendArray(this.destinationsPosted,this.destinations),t(),s.publishDestinations({subdomain:I,callback:e,urlDestinations:r}),"Called visitor.publishDestinations() version > 1"):void 0},getPublishDestinationsVersion:function(){if(null!==this.publishDestinationsVersion)return this.publishDestinationsVersion;var e=A.adms.instance,n=-1;return e.publishDestinations(null,null,function(e){if(e===Object(e)){var t=e.error;"subdomain is not a populated string."===t?n=1:"Invalid parameters passed."===t&&(n=2)}}),this.publishDestinationsVersion=n}},M={traits:function(e){return k.isValidPdata(e)&&(L.sids instanceof Array||(L.sids=[]),x.extendArray(L.sids,e)),this},pixels:function(e){return k.isValidPdata(e)&&(L.pdata instanceof Array||(L.pdata=[]),x.extendArray(L.pdata,e)),this},logs:function(e){return k.isValidLogdata(e)&&(L.logdata!==Object(L.logdata)&&(L.logdata={}),x.extendObject(L.logdata,e)),this},customQueryParams:function(e){return k.isEmptyObject(e)||x.extendObject(L,e,A.reservedKeys),this},signals:function(e,t){var n,s=e;if(!k.isEmptyObject(s)){if(t&&"string"==typeof t)for(n in s={},e)e.hasOwnProperty(n)&&(s[t+n]=e[n]);x.extendObject(L,s,A.reservedKeys)}return this},declaredId:function(e){return A.declaredId.setDeclaredId(e,"request"),this},result:function(e){return"function"==typeof e&&(L.callback=e),this},afterResult:function(e){return"function"==typeof e&&(L.postCallbackFn=e),this},useImageRequest:function(){return L.useImageRequest=!0,this},clearData:function(){return L={},this},submit:function(e){return L.isDefaultRequest=!!e,V.submitRequest(L),L={},this},getPartner:function(){return I},getContainerNSID:function(){return r},getEventLog:function(){return O},getState:function(){var e={},t={};return x.extendObject(e,A,{registerRequest:!0}),x.extendObject(t,T,{requestToProcess:!0,process:!0,sendMessages:!0}),{initConfig:n,pendingRequest:L,otherRequestInfo:e,destinationPublishingInfo:t,log:O}},idSync:function(){throw new Error("Please use the `idSyncByURL` method of the Experience Cloud ID Service (Visitor) instance")},aamIdSync:function(){throw new Error("Please use the `idSyncByDataSource` method of the Experience Cloud ID Service (Visitor) instance")},passData:function(e){return k.isEmptyObject(e)?"Error: json is empty or not an object":(V.defaultCallback(e),e)},getPlatformParams:function(){return A.platformParams},getEventCallConfigParams:function(){var e,t=A,n=t.modStatsParams,s=t.platformParams;if(!n){for(e in n={},s)s.hasOwnProperty(e)&&!t.nonModStatsParams[e]&&(n[e.replace(/^d_/,"")]=s[e]);!0===d?n.coop_safe=1:!1===d&&(n.coop_unsafe=1),t.modStatsParams=n}return n},setAsCoopSafe:function(){return d=!0,this},setAsCoopUnsafe:function(){return d=!1,this},getEventCallIabSignals:function(e){var t;return e!==Object(e)?"Error: config is not an object":"function"!=typeof e.callback?"Error: config.callback is not a function":(t=parseInt(e.timeout,10),isNaN(t)&&(t=null),void B.getQueryStringObject(e.callback,t))}},V={corsMetadata:(q="none","undefined"!=typeof XMLHttpRequest&&XMLHttpRequest===Object(XMLHttpRequest)&&"withCredentials"in new XMLHttpRequest&&(q="XMLHttpRequest"),{corsType:q}),getCORSInstance:function(){return"none"===this.corsMetadata.corsType?null:new window[this.corsMetadata.corsType]},submitRequest:function(e){return A.registerRequest(V.createQueuedRequest(e)),!0},createQueuedRequest:function(e){var t,n,s,i,r,o=e.callback,a="img",d=e.isDefaultRequest;if(delete e.isDefaultRequest,!k.isEmptyObject(u))for(s in u)if(u.hasOwnProperty(s)){if(null==(i=u[s])||""===i)continue;if(s in e&&!(i in e)&&!(i in A.reservedKeys)){if(null==(r=e[s])||""===r)continue;e[i]=r}}return k.isValidPdata(e.sids)||(e.sids=[]),k.isValidPdata(e.pdata)||(e.pdata=[]),k.isValidLogdata(e.logdata)||(e.logdata={}),e.logdataArray=x.convertObjectToKeyValuePairs(e.logdata,"=",!0),e.logdataArray.push("_ts="+(new Date).getTime()),"function"!=typeof o&&(o=this.defaultCallback),t=this.makeRequestSrcData(e),(n=this.getCORSInstance())&&!0!==e.useImageRequest&&(a="cors"),{tag:a,src:t.src,corsSrc:t.corsSrc,callbackFn:o,postCallbackFn:e.postCallbackFn,useImageRequest:!!e.useImageRequest,requestData:e,corsInstance:n,corsPostData:t.corsPostData,isDefaultRequest:d}},defaultCallback:function(e,t){var n,s,i,r,o,a,d,u,c;if(g&&(n=e.stuff)&&n instanceof Array&&(s=n.length))for(i=0;i<s;i++)(r=n[i])&&r===Object(r)&&(o=r.cn,a=r.cv,void 0!==(d=r.ttl)&&""!==d||(d=Math.floor(x.getMaxCookieExpiresInMinutes()/60/24)),u=r.dmn||"."+document.domain.replace(/^www\./,""),c=r.type,o&&(a||"number"==typeof a)&&("var"!==c&&(d=parseInt(d,10))&&!isNaN(d)&&x.setCookie(o,a,24*d*60,"/",u,!1),P.stuffed[o]=a));var l,f,p=e.uuid;k.isPopulatedString(p)&&(k.isEmptyObject(h)||("string"==typeof(l=h.path)&&l.length||(l="/"),f=parseInt(h.days,10),isNaN(f)&&(f=100),x.setCookie(h.name||"aam_did",p,24*f*60,l,h.domain||"."+document.domain.replace(/^www\./,""),!0===h.secure))),A.abortRequests||T.requestToProcess(e,t)},makeRequestSrcData:function(r){r.sids=k.removeEmptyArrayValues(r.sids||[]),r.pdata=k.removeEmptyArrayValues(r.pdata||[]);var o=A,e=o.platformParams,t=x.encodeAndBuildRequest(r.sids,","),n=x.encodeAndBuildRequest(r.pdata,","),s=(r.logdataArray||[]).join("&");delete r.logdataArray;var i,a,d=encodeURIComponent,u=E.IS_HTTPS?"https://":"http://",c=o.declaredId.getDeclaredIdQueryString(),l=o.adms.instance?o.adms.getCustomerIDsQueryString(o.adms.getCustomerIDs()):"",f=function(){var e,t,n,s,i=[];for(e in r)if(!(e in o.reservedKeys)&&r.hasOwnProperty(e))if(t=r[e],e=d(e),t instanceof Array)for(n=0,s=t.length;n<s;n++)i.push(e+"="+d(t[n]));else i.push(e+"="+d(t));return i.length?"&"+i.join("&"):""}(),p="d_dil_ver="+d(DIL.version),h="d_nsid="+e.d_nsid+o.getCoopQueryString()+c+l+(t.length?"&d_sid="+t:"")+(n.length?"&d_px="+n:"")+(s.length?"&d_ld="+d(s):""),g="&d_rtbd="+e.d_rtbd+"&d_jsonv="+e.d_jsonv+"&d_dst="+e.d_dst,m=y?"&h_referer="+d(location.href):"";return a=(i=u+I+".demdex.net/event")+"?"+p+"&"+h+g+f+m,{corsSrc:i+"?"+p+"&_ts="+(new Date).getTime(),src:a,corsPostData:h+g+f+m,isDeclaredIdCall:""!==c}},fireRequest:function(e){if("img"===e.tag)this.fireImage(e);else{var t=A.declaredId,n=t.declaredId.request||t.declaredId.init||{},s={dpid:n.dpid||"",dpuuid:n.dpuuid||""};this.fireCORS(e,s)}},fireImage:function(t){var e,n,s=A;s.abortRequests||(s.firing=!0,e=new Image(0,0),s.sent.push(t),e.onload=function(){s.firing=!1,s.fired.push(t),s.num_of_img_responses++,s.registerRequest()},n=function(e){c="imgAbortOrErrorHandler received the event of type "+e.type,R.log(c),s.abortRequests=!0,s.firing=!1,s.errored.push(t),s.num_of_img_errors++,s.registerRequest()},e.addEventListener("error",n),e.addEventListener("abort",n),e.src=t.src)},fireCORS:function(s,i){var r=this,o=A,e=this.corsMetadata.corsType,t=s.corsSrc,n=s.corsInstance,a=s.corsPostData,d=s.postCallbackFn,u="function"==typeof d;if(!o.abortRequests&&!v){o.firing=!0;try{n.open("post",t,!0),"XMLHttpRequest"===e&&(n.withCredentials=!0,n.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),n.onreadystatechange=function(){4===this.readyState&&200===this.status&&function(e){var t;try{if((t=JSON.parse(e))!==Object(t))return r.handleCORSError(s,i,"Response is not JSON")}catch(e){return r.handleCORSError(s,i,"Error parsing response as JSON")}try{var n=s.callbackFn;o.firing=!1,o.fired.push(s),o.num_of_cors_responses++,n(t,i),u&&d(t,i)}catch(e){e.message="DIL handleCORSResponse caught error with message "+e.message,c=e.message,R.log(c),e.filename=e.filename||"dil.js",e.partner=I,DIL.errorModule.handleError(e);try{n({error:e.name+"|"+e.message},i),u&&d({error:e.name+"|"+e.message},i)}catch(e){}}finally{o.registerRequest()}}(this.responseText)}),n.onerror=function(){r.handleCORSError(s,i,"onerror")},n.ontimeout=function(){r.handleCORSError(s,i,"ontimeout")},n.send(a)}catch(e){this.handleCORSError(s,i,"try-catch")}o.sent.push(s),o.declaredId.declaredId.request=null}},handleCORSError:function(e,t,n){A.num_of_cors_errors++,A.corsErrorSources.push(n)}},k={isValidPdata:function(e){return!!(e instanceof Array&&this.removeEmptyArrayValues(e).length)},isValidLogdata:function(e){return!this.isEmptyObject(e)},isEmptyObject:function(e){if(e!==Object(e))return!0;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0},removeEmptyArrayValues:function(e){var t,n=0,s=e.length,i=[];for(n=0;n<s;n++)null!=(t=e[n])&&""!==t&&i.push(t);return i},isPopulatedString:function(e){return"string"==typeof e&&e.length}},x={convertObjectToKeyValuePairs:function(e,t,n){var s,i,r=[];for(s in t=t||"=",e)e.hasOwnProperty(s)&&null!=(i=e[s])&&""!==i&&r.push(s+t+(n?encodeURIComponent(i):i));return r},encodeAndBuildRequest:function(e,t){return e.map(function(e){return encodeURIComponent(e)}).join(t)},getCookie:function(e){var t,n,s,i=e+"=",r=document.cookie.split(";");for(t=0,n=r.length;t<n;t++){for(s=r[t];" "===s.charAt(0);)s=s.substring(1,s.length);if(0===s.indexOf(i))return decodeURIComponent(s.substring(i.length,s.length))}return null},setCookie:function(e,t,n,s,i,r){var o=new Date;n=n&&1e3*n*60,document.cookie=e+"="+encodeURIComponent(t)+(n?";expires="+new Date(o.getTime()+n).toUTCString():"")+(s?";path="+s:"")+(i?";domain="+i:"")+(r?";secure":"")},extendArray:function(e,t){return e instanceof Array&&t instanceof Array&&(Array.prototype.push.apply(e,t),!0)},extendObject:function(e,t,n){var s;if(e!==Object(e)||t!==Object(t))return!1;for(s in t)if(t.hasOwnProperty(s)){if(!k.isEmptyObject(n)&&s in n)continue;e[s]=t[s]}return!0},getMaxCookieExpiresInMinutes:function(){return E.SIX_MONTHS_IN_MINUTES},replaceMethodsWithFunction:function(e,t){var n;if(e===Object(e)&&"function"==typeof t)for(n in e)e.hasOwnProperty(n)&&"function"==typeof e[n]&&(e[n]=t)}},N=(j=C.requestController,{exists:null,instance:null,aamIsApproved:null,init:function(){var e=this;this.checkIfExists()?(this.exists=!0,this.instance=window.adobe.optIn,this.instance.fetchPermissions(function(){e.callback()},!0)):this.exists=!1},checkIfExists:function(){return window.adobe===Object(window.adobe)&&window.adobe.optIn===Object(window.adobe.optIn)},callback:function(){this.aamIsApproved=this.instance.isApproved([this.instance.Categories.AAM]),j.adms.waitForMidToReleaseRequests(),j.adms.getIsOptedOut()},isApproved:function(){return!this.isIabContext()&&!j.adms.isOptedOut&&(!this.exists||this.aamIsApproved)},isIabContext:function(){return this.instance&&this.instance.isIabContext}});C.optIn=N;var F,Q,H,U,B=(Q=(F=C).requestController,H=F.optIn,U={isVendorConsented:null,doesGdprApply:null,consentString:null,queryStringObjectCallbacks:[],init:function(){this.fetchConsentData()},hasGoSignal:function(){return!(!(H.isIabContext()&&this.isVendorConsented&&this.doesGdprApply&&"string"==typeof this.consentString&&this.consentString.length)||Q.adms.isOptedOut)},fetchConsentData:function(n,e){var s=this,t={};"function"!=typeof n&&(n=function(){}),H.instance&&H.isIabContext()?(e&&(t.timeout=e),H.instance.execute({command:"iabPlugin.fetchConsentData",params:t,callback:function(e,t){t===Object(t)?(s.doesGdprApply=!!t.gdprApplies,s.consentString=t.consentString||""):(s.doesGdprApply=!1,s.consentString=""),s.isVendorConsented=H.instance.isApproved(H.instance.Categories.AAM),e?n({}):s.checkQueryStringObject(n),Q.adms.waitForMidToReleaseRequests()}})):n({})},getQueryString:function(){return H.isIabContext()?"gdpr="+(this.doesGdprApply?1:0)+"&gdpr_consent="+this.consentString+"&":""},getQueryStringObject:function(e,t){this.fetchConsentData(e,t)},checkQueryStringObject:function(e){U.hasGoSignal()&&"function"==typeof e&&e({gdpr:this.doesGdprApply?1:0,gdpr_consent:this.consentString})}});C.iab=B,"error"===I&&0===r&&window.addEventListener("load",function(){DIL.windowLoaded=!0});function G(){W||(W=!0,A.registerRequest(),X())}var W=!1,X=function(){setTimeout(function(){p||A.firstRequestHasFired||("function"==typeof m?M.afterResult(m).submit(!0):M.submit(!0))},DIL.constants.TIME_TO_DEFAULT_REQUEST)},K=document;"error"!==I&&(DIL.windowLoaded?G():"complete"!==K.readyState&&"loaded"!==K.readyState?window.addEventListener("load",function(){DIL.windowLoaded=!0,G()}):(DIL.windowLoaded=!0,G())),A.declaredId.setDeclaredId(s,"init"),N.init(),B.init(),A.processVisitorAPI();E.IS_IE_LESS_THAN_10&&x.replaceMethodsWithFunction(M,function(){return this}),this.api=M,this.getStuffedVariable=function(e){var t=P.stuffed[e];return t||"number"==typeof t||(t=x.getCookie(e))||"number"==typeof t||(t=""),t},this.validators=k,this.helpers=x,this.constants=E,this.log=O,this.pendingRequest=L,this.requestController=A,this.destinationPublishing=T,this.requestProcs=V,this.units=C,this.initConfig=n,this.logger=R,w&&(this.variables=P,this.callWindowLoadFunctions=G)},DIL.extendStaticPropertiesAndMethods=function(e){var t;if(e===Object(e))for(t in e)e.hasOwnProperty(t)&&(this[t]=e[t])},DIL.extendStaticPropertiesAndMethods({version:"9.4",jsonVersion:1,constants:{TIME_TO_DEFAULT_REQUEST:500},variables:{scriptNodeList:document.getElementsByTagName("script")},windowLoaded:!1,dils:{},isAddedPostWindowLoad:function(){var e=arguments[0];this.windowLoaded="function"==typeof e?!!e():"boolean"!=typeof e||e},create:function(e){try{return new DIL(e)}catch(e){throw new Error("Error in attempt to create DIL instance with DIL.create(): "+e.message)}},registerDil:function(e,t,n){var s=t+"$"+n;s in this.dils||(this.dils[s]=e)},getDil:function(e,t){var n;return"string"!=typeof e&&(e=""),(n=e+"$"+(t=t||0))in this.dils?this.dils[n]:new Error("The DIL instance with partner = "+e+" and containerNSID = "+t+" was not found")},dexGetQSVars:function(e,t,n){var s=this.getDil(t,n);return s instanceof this?s.getStuffedVariable(e):""}}),DIL.errorModule=(r=DIL.create({partner:"error",containerNSID:0,ignoreHardDependencyOnVisitorAPI:!0}),a=!(o={harvestererror:14138,destpuberror:14139,dpmerror:14140,generalerror:14137,error:14137,noerrortypedefined:15021,evalerror:15016,rangeerror:15017,referenceerror:15018,typeerror:15019,urierror:15020}),{activate:function(){a=!0},handleError:function(e){if(!a)return"DIL error module has not been activated";e!==Object(e)&&(e={});var t=e.name?(e.name+"").toLowerCase():"",n=t in o?o[t]:o.noerrortypedefined,s=[],i={name:t,filename:e.filename?e.filename+"":"",partner:e.partner?e.partner+"":"no_partner",site:e.site?e.site+"":document.location.href,message:e.message?e.message+"":""};return s.push(n),r.api.pixels(s).logs(i).useImageRequest().submit(),"DIL error report sent"},pixelMap:o}),DIL.tools={},DIL.modules={helpers:{}})}();

function AppMeasurement_Module_Integrate(l){var c=this;c.s=l;var e=window;e.s_c_in||(e.s_c_il=[],e.s_c_in=0);c._il=e.s_c_il;c._in=e.s_c_in;c._il[c._in]=c;e.s_c_in++;c._c="s_m";c.list=[];c.add=function(d,b){var a;b||(b="s_Integrate_"+d);e[b]||(e[b]={});a=c[d]=e[b];a.a=d;a.e=c;a._c=0;a._d=0;void 0==a.disable&&(a.disable=0);a.get=function(b,d){var f=document,h=f.getElementsByTagName("HEAD"),k;if(!a.disable&&(d||(v="s_"+c._in+"_Integrate_"+a.a+"_get_"+a._c),a._c++,a.VAR=v,a.CALLBACK="s_c_il["+c._in+"]."+
a.a+".callback",a.delay(),h=h&&0<h.length?h[0]:f.body))try{k=f.createElement("SCRIPT"),k.type="text/javascript",k.setAttribute("async","async"),k.src=c.c(a,b),0>b.indexOf("[CALLBACK]")&&(k.onload=k.onreadystatechange=function(){a.callback(e[v])}),h.firstChild?h.insertBefore(k,h.firstChild):h.appendChild(k)}catch(l){}};a.callback=function(b){var c;if(b)for(c in b)Object.prototype[c]||(a[c]=b[c]);a.ready()};a.beacon=function(b){var d="s_i_"+c._in+"_Integrate_"+a.a+"_"+a._c;a.disable||(a._c++,d=e[d]=
new Image,d.src=c.c(a,b))};a.script=function(b){a.get(b,1)};a.delay=function(){a._d++};a.ready=function(){a._d--;a.disable||l.delayReady()};c.list.push(d)};c._g=function(d){var b,a=(d?"use":"set")+"Vars";for(d=0;d<c.list.length;d++)if((b=c[c.list[d]])&&!b.disable&&b[a])try{b[a](l,b)}catch(e){}};c._t=function(){c._g(1)};c._d=function(){var d,b;for(d=0;d<c.list.length;d++)if((b=c[c.list[d]])&&!b.disable&&0<b._d)return 1;return 0};c.c=function(c,b){var a,e,g,f;"http"!=b.toLowerCase().substring(0,4)&&
(b="http://"+b);l.ssl&&(b=l.replace(b,"http:","https:"));c.RAND=Math.floor(1E13*Math.random());for(a=0;0<=a;)a=b.indexOf("[",a),0<=a&&(e=b.indexOf("]",a),e>a&&(g=b.substring(a+1,e),2<g.length&&"s."==g.substring(0,2)?(f=l[g.substring(2)])||(f=""):(f=""+c[g],f!=c[g]&&parseFloat(f)!=c[g]&&(g=0)),g&&(b=b.substring(0,a)+encodeURIComponent(f)+b.substring(e+1)),a=e));return b}}


// export
w.AppMeasurement = AppMeasurement;
w.AppMeasurement_Module_ActivityMap = AppMeasurement_Module_ActivityMap;
w.AppMeasurement_Module_AudienceManagement = AppMeasurement_Module_AudienceManagement;
w.AppMeasurement_Module_Integrate = AppMeasurement_Module_Integrate;



/* eslint-enable */

//------------------------------------------------------------------------------
// Export
//------------------------------------------------------------------------------

// Make the s object available globally as "s" since we now are try to follow
// best practices and go with what is default
// 
// Make the s object available globally as "s_adbadobenonacdc"
// 
// Make the s object available globally as "s_adobe"
// for backwards compatibility with previous deployments
//   - s_code
//   - ATM 1 & 2
//   - DTM

w.s = w.s_adbadobenonacdc = w.s_adobe = s_gi(
  _satellite.getVar('analytics_account_adbadobenonacdc')
);


//------------------------------------------------------------------------------
// Variables
//------------------------------------------------------------------------------
var

  //----------------------------------------------------------------------------
  // generic minification code size savings
  //----------------------------------------------------------------------------
  // w = window,
  d = document,
  // loc = w.location,
  // hostname = loc.hostname.toLowerCase(),
  // pathname = loc.pathname,
  // href = loc.href,
  s = w.s,

  //----------------------------------------------------------------------------
  // convenience variables
  //----------------------------------------------------------------------------
  // marketingCloudOrgId = '9E1005A551ED61CA0A490D45@AdobeOrg',
  // namespace = 'adobecorp', 
  trackingServer = 'stats.adobe.com',
  trackingServerSecure = 'sstats.adobe.com',

  windowUnloading;

//------------------------------------------------------------------------------
// AppMeasurement Configuration
//------------------------------------------------------------------------------

//--- s report suite config ----------------------------------------------------

s.visitor = w.Visitor.getInstance(
  _satellite.getVar('marketingCloudOrganizationID')
);
s.charSet = 'UTF-8';
s.trackingServer = trackingServer;
s.trackingServerSecure = trackingServerSecure;
s.fpCookieDomainPeriods = s.cookieDomainPeriods = _satellite._getDomainPeriods();
// s.debugTracking = _satellite.buildInfo.environment !== 'production';
s.debugTracking = localStorage.getItem('com.adobe.reactor.debug') === 'true';
//s.cookieLifetime = '';
//s.currencyCode = '';
//s.dynamicVariablePrefix = 'D='; 
//s.mobile = '';

//--- s link tracking config ---------------------------------------------------

// not going to set yet...
// s.maxDelay = 1000; 
// Legacy ClickMap - We have this turned off so it doesn't bloat cookie size
s.trackInlineStats = false;
s.trackDownloadLinks = true;
s.trackExternalLinks = true;
s.linkLeaveQueryString = false;
// s.linkTrackEvents = 'None';
// s.linkTrackVars = 'None';
s.linkDownloadFileTypes = _satellite.getVar('adobe_linkDownloadFileTypes');
s.linkExternalFilters = ''; //none
s.linkInternalFilters = _satellite.getVar('adobe_linkInternalFilters');

//--- s link tracking config ---------------------------------------------------

// Set a variable for just the page view that indicates that we should 
// generate a supplemental data id for this hit.
// TODO: Determine what to do about this
// variableOverrides.expectSupplementalData = true;

//--- s plugins ----------------------------------------------------------------

//------ timeSpentOnPage version 1.0 -------------------------------------------
_satellite._timeSpentOnPage.init();

//--- s modules ----------------------------------------------------------------

// set the maxDelay to 10 seconds for when we no longer want to delay any hits 
// from firing...
s.maxDelay = 10000;

//------ AppMeasurement_Module_Integrate ---------------------------------------
s.loadModule('Integrate');

//------ AppMeasurement_Module_AudienceManagement ------------------------------
if (
  _satellite.getVar('isStudent') && _satellite.getVar('audienceManager_enable')
) {
  var
    consentIsGivenCallback;
    
  
  // callback
  consentIsGivenCallback = function (cb) {
    var am_consent = false;
    var OneTrustConsent = function (cb) {
      var cookieConsent = _satellite.cookie.get('OptanonConsent');
      if (!am_consent && _satellite.getVar('isStudent') && (cookieConsent && cookieConsent.indexOf('C0004:1') !== -1)){
        cb();
        am_consent = true;
      }
    };
    OneTrustConsent(cb);
    w.addEventListener('adobePrivacy:PrivacyCustom', OneTrustConsent(cb));
    w.addEventListener('adobePrivacy:PrivacyConsent', OneTrustConsent(cb));

  };

  // either set it up immediately or call back when ready to setup when consent
  // has been given
  consentIsGivenCallback(function () {

    // load the module
    s.loadModule('AudienceManagement');

    // configure the AudienceManagement Module
    s.AudienceManagement.setup({
      partner: 'adobe',
      containerNSID: 0,
      uuidCookie: {
        name: 'aam_uuid',
        days: 30
      },
      visitorService: {
        namespace: _satellite.getVar('marketingCloudOrganizationID')
      },
      disableDestinationPublishingIframe:
        !!_satellite.getVar('audienceManager_disableDestinationPublishingIframe')
    });

  });

}

//------ AppMeasurement_Module_ActivityMap -------------------------------------
s.loadModule('ActivityMap');
s.ActivityMap.trackScrollReach = true;
s.ActivityMap.linkDefault = s.ActivityMap.link;
s.ActivityMap.link = function (element) {
  if (!element) {
    return '';
  }

  var
    id = [],
    info = _satellite._spiderWeb.getInformationForElement(element),
    linkText = s.ActivityMap.linkDefault(element),
    piis = [
      'email',
      'first_name',
      'last_name'
    ],
    i, il,
    pii;

  // remove any PII from the link text
  if (
    w.adobeIMS &&
    w.adobeIMS._profile &&
    linkText
  ) {

    for (i = 0, il = piis.length; i < il; i++) {

      // get the pii
      pii = w.adobeIMS._profile[piis[i]];

      // if we have pii
      if (pii) {

        // redact it
        linkText = linkText.replace(
          RegExp(pii, 'gim'),
          ''
        );

      }
    }

    // trim whitespace from ends
    linkText = linkText.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  }

  id.push(info.id);
  id.push(linkText);

  return id.join('-');
};

s.ActivityMap.regionDefault = s.ActivityMap.region;
s.ActivityMap.region = function (element) {
  if (!element) {
    return '';
  }

  var
    parent = element.parentNode,
    id = 'other',
    map = {
      'footer': 1,
      'header': 1,
      'main': 1
    },
    nodeName,
    infiniteLoopInsurance = 0;

  // loop until we get a parent above us that has a nodeName that
  // matches one in the map
  while (
    parent &&
    parent !== d &&
    parent !== d.body &&
    infiniteLoopInsurance < 5000
  ) {
    nodeName = parent.nodeName.toLowerCase();
    if (map[nodeName]) {
      id = nodeName;
    }
    parent = parent.parentNode;
    infiniteLoopInsurance++;
  }

  return id;
};

// if we haven't tracked a pageload hit yet and the page is unloading, set the
// tracking mechanism to use navigator.beacon and send the pageload hit.

_satellite._beforeUnload(function () {
  windowUnloading = true;
}, -100);
// TODO: Remove _satellite._beforeUnload plugin in favor of the window.unload 
// event.  Also need to update initAnalyticsBeacon, trackPageLoad, trackState, 
// trackEvent, trackUnload, and also remove the plugin
// window.addEventListener('unload', function() {
//   windowUnloading = true;
// });


//--- s doPlugins --------------------------------------------------------------
s.usePlugins = true;
s.doPlugins = function (s) {
  var visitStart = 0,
    firstPage = false,
    statusCode;

  if(!_satellite.getVar('enable_performanceCookie')){
    s.t = s.track = function () {};
    s.tl = s.trackLink = function () {};
    s.trackDownloadLinks = false;
    s.trackExternalLinks = false;
  }

  //Adobe analytics integration with Clicktale	
  if (_satellite.cookie.get('OptanonConsent') && _satellite.cookie.get('OptanonConsent').indexOf('C0002:1') !== -1 && w.location.href.indexOf('www.adobe.com/products') !== -1) {
    /*	
     *Name: Adobe Analytics CS Integration	
     *Version: 1.4 (Adobe Launch + csMatchingKey)	
     */
    (function () {
      function callback() {
        if (!disableCallback) {
          disableCallback = true;
          if (window.CS_CONF) {
            window.CS_CONF.integrations = window.CS_CONF.integrations || [];
            window.CS_CONF.integrations.push('Adobe Analytics');
          }
        }
      }
      var disableCallback = false;
      window._uxa = window._uxa || [];
      window._uxa.push(['afterPageView', callback]);
      var cn1 = '_cs_mk';
      var cn2 = '_cs_id';
      var cookies = '; ' + document.cookie;
      if (cookies) {
        var getCookie1 = cookies.split('; ' + cn1 + '=');
        var getCookie2 = cookies.split('; ' + cn2 + '=');
        if (getCookie1.length > 1 && getCookie2.length > 1) {
          return;
        }
        var init = function (cookieValue) {
          var cmk = Math.random() + '_' + Date.now();
          if (cookieValue) {
            cmk = cookieValue;
          }
          // s.eVarX = cmk;	
          s.contextData['digitalData.clickTaleInfo'] = cmk;
          var tld = (function () {
            var i = 0,
              domain = document.domain,
              p = domain.split('.'),
              s = '_gd' + (new Date()).getTime();
            while (i < (p.length - 1) && document.cookie.indexOf(s + '=' + s) == -1) {
              domain = p.slice(-1 - (++i)).join('.');
              document.cookie = s + '=' + s + ';domain=' + domain + ';';
            }
            document.cookie = s + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=' + domain + ';';
            return domain;
          })();
          var now = new Date();
          var time = now.getTime();
          time += 30 * 60 * 1000;
          now.setTime(time);
          document.cookie = cn1 + '=' + cmk + '; expires=' + now.toUTCString() + ';path=/;domain=' + tld;
          // eslint-disable-next-line no-undef	
          _uxa.push(['trackDynamicVariable', {
            key: 'csMatchingKey',
            value: cmk
          }]);
        };
        if (getCookie1.length == 1) {
          init();
        } else {
          var getCookieValue = '';
          if (getCookie1) {
            getCookieValue = getCookie1[1].split(';')[0];
          }
          init(getCookieValue);
        }
      }
    })();
  }
  //end of clicktale
  // if we called track earlier and it wasn't sent because it was waiting
  // for something, but, now the page is unloading, change the tracking 
  // mechanism to something that will not be cancelled upon navigation


  if ((s.linkName && s.linkName == 'Marketo Form Submission') || windowUnloading) {
    s.useBeacon = true;
  }

  if (s.contextData['digitalData.page.pageInfo.type'] === 'errorPage') {
    s.pageType = 'errorPage';
    s.contextData['digitalData.page.pageInfo.pageName'] = '';
  }

  //Download and exit links event
  //------------------------------------------------------------
  if (s.linkType && s.linkType !== 'o') {
    if (s.linkType === 'd') {
      w.digitalData._set(
        'digitalData.primaryEvent.eventInfo.eventAction',
        'downloadLink'
      );
    }
    if (s.linkType === 'e') {
      w.digitalData._set(
        'digitalData.primaryEvent.eventInfo.eventAction',
        'exitLink'
      );
    }
    s.contextData = w.digitalData._flatten(w.digitalData, 'digitalData', false);
    s.contextData['hit.type'] = 'event';
  }
  
  if(s.contextData['hit.type'] == 'pageload' || s.contextData['hit.type'] == 'state'){
    
    // Get the visit start page
    visitStart = _satellite._getVisitStart('s_vs');
    if (visitStart && visitStart == 1) {
      firstPage = 'firstpage';
    } 

    // clickpast makes sure that event19 gets fired before event20
    //statusCode = _satellite.clickPast(firstPage, 'event19', 'event20');
    statusCode = _satellite.clickPast(firstPage,s.contextData['hit.type']);    
    if(statusCode && statusCode == 1)
    {          
      s.contextData['digitalData.page.pageInfo.isClickTo'] = 'true';    
    }
    else if(statusCode == 0){       
      s.contextData['digitalData.page.pageInfo.isClickPast'] = 'true';    

    }    
  }

  //fix for appxtxId
  var appCtxId = 'No Value_No Value',
    ddAppCtxId;
  if(s.contextData['digitalData.app.appInfo.appCtxId']){
    if(s.contextData['digitalData.page.pageInfo.siteSection'] !== 'InApp:NGL' || 
    s.contextData['digitalData.page.pageInfo.siteSection'] !== 'account.adobe.com'){
      appCtxId = '';
    }
    ddAppCtxId = s.contextData['digitalData.app.appInfo.appCtxId'];
    /*if (_satellite._getQueryParam('appctxid') || _satellite._getQueryParam('appCtxId') || _satellite._getQueryParam('appctxId')) {
      ddAppCtxId = _satellite._getQueryParam('appctxid') || _satellite._getQueryParam('appCtxId') || _satellite._getQueryParam('appctxId');
    }*/
  } else if (_satellite._getQueryParam('appctxid') || _satellite._getQueryParam('appCtxId') || _satellite._getQueryParam('appctxId')) {
    ddAppCtxId = _satellite._getQueryParam('appctxid') || _satellite._getQueryParam('appCtxId') || _satellite._getQueryParam('appctxId');
  } 
  if (ddAppCtxId) {
    var appCtxIdSplit = ddAppCtxId.indexOf('_') !== -1 ? ddAppCtxId.split('_') : '';
    if (appCtxIdSplit.length === 6 && appCtxIdSplit[5] === '0') {
      appCtxIdSplit[5] = 'zero';
    }
    // Replacing Session ID with NA value
    if (appCtxIdSplit[4]) {
      appCtxIdSplit[4] = 'NA';
    }
    appCtxId = appCtxIdSplit.length ? appCtxIdSplit.join('_') : ddAppCtxId;
  }
  if (s.contextData['digitalData.page.pageInfo.siteSection'] === 'account.adobe.com' && appCtxId === 'No Value_No Value') {
    appCtxId = '';
  }
  s.contextData['digitalData.app.appInfo.appCtxId'] = appCtxId ; 


  //delete params
  var host = w.location.hostname;
  if (
    host.indexOf('dc.stage.') !== -1 ||
    host.indexOf('dc.dev.') !== -1 ||
    host === 'documentcloud.adobe.com'
  ) {
    var removeParamLogic = _satellite.getVar('remove_url_parameters');
    var removeUpdate = function (qparam) {
      s.contextData['digitalData.initialPage.pageInfo.location.href'] = removeParamLogic(s.contextData['digitalData.initialPage.pageInfo.location.href'], qparam);
      s.contextData['digitalData.initialPage.pageInfo.location.search'] = removeParamLogic(s.contextData['digitalData.initialPage.pageInfo.location.search'], qparam);
      s.contextData['digitalData.initialPage.topFrameInfo.location.href'] = removeParamLogic(s.contextData['digitalData.initialPage.topFrameInfo.location.href'], qparam);
      s.contextData['digitalData.initialPage.topFrameInfo.location.search'] = removeParamLogic(s.contextData['digitalData.initialPage.topFrameInfo.location.search'], qparam);
      s.contextData['digitalData.page.pageInfo.location.href'] = removeParamLogic(s.contextData['digitalData.page.pageInfo.location.href'], qparam);
      s.contextData['digitalData.page.pageInfo.location.search'] = removeParamLogic(s.contextData['digitalData.page.pageInfo.location.search'], qparam);
      s.contextData['digitalData.page.topFrameInfo.location.href'] = removeParamLogic(s.contextData['digitalData.page.topFrameInfo.location.href'], qparam);
      s.contextData['digitalData.page.topFrameInfo.location.search'] = removeParamLogic(s.contextData['digitalData.page.topFrameInfo.location.search'], qparam);
      s.pageURL = s.contextData['digitalData.page.pageInfo.location.href'];
      if (s.ActivityMap && s.ActivityMap.page) s.ActivityMap.page = s.pageURL;
    };
    if (_satellite._getQueryParam('uri')) removeUpdate('uri');
    if (_satellite._getQueryParam('assetUri')) removeUpdate('assetUri');
  }
  //----------------------------------------------------------------------------
  // Variables
  //----------------------------------------------------------------------------


  // return so we don't process any more data
  if (s.abort) {
    return;
  }


  //----------------------------------------------------------------------------
  // contextData
  //----------------------------------------------------------------------------

  // supported in processing rules - variables that can be set through 
  // processing rules
  //----------------------------------------------------------------------------

  // dimensions
  // ==========

  // traffic

  // s.propX
  // s.hierX
  // s.channel
  // s.server
  // s.pageName
  // s.pageURL

  // conversion

  // s.evarX
  // s.campaign
  // s.currencyCode
  // s.listX
  // s.purchaseID
  // s.transactionID
  // s.state
  // s.zip

  // events
  // ======

  // eventX
  // prodView
  // purchase
  // scOpen
  // scView
  // scCheckout
  // scAdd
  // scRemove

  // other
  // =====

  // customer perspective - https://marketing.adobe.com/resources/help/en_US/reference/vrs-mobile-visit-processing.html

  //----------------------------------------------------------------------------
  // other variables
  //----------------------------------------------------------------------------

  // NOT supported in processing rules - variables that cannot be set through 
  // processing rules
  //----------------------------------------------------------------------------

  // dimensions
  // ==========

  // traffic

  //------- s.referrer fix for iFrame------------
  if (w.self !== w.top) {
    s.referrer = document.referrer;
  }
  // s.linkName
  // s.linkType
  // etc.

  // technology

  // s.browserHeight
  // s.browserWidth
  // etc.

  // conversion

  // s.products

  // events
  // ======

  // TODO:

  // other
  // =====

  // activity map variables - although these are automatically processed by 
  // processing rules


};

return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLab0967e2286d43a9b6e35055466a8935",
      "name": "initOneTrust",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 4.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC8b2fc74a3d60422a950baec834ba8202-file.js'
          }
        }
      ]
    },
    {
      "id": "RLf78d226aff294107b3b6f4b2d02eb9de",
      "name": "thirdParty_demandBaseTag",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "thirdParty_demandBaseTag"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCcce3de37791940f49b1aed22f90da7ad-file.js'
          }
        }
      ]
    },
    {
      "id": "RLcc9bbab682db4acc86ca762dc1f1e12b",
      "name": "thirdParty_PPBU-MathTagInsightPixel",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload_PPBUMathTagCasalmedia"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCbfebbe88941b4255b47ffc7a201df313-file.js'
          }
        }
      ]
    },
    {
      "id": "RLa876c602b6a84e57b9ab913404651399",
      "name": "thirdParty_allPagesTags",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC392ee1eba87c4c0fb096ec09f1327ecf-file.js'
          }
        }
      ]
    },
    {
      "id": "RL09f10bdc8270435a836edcfc11aacf8d",
      "name": "thirdParty_MunchkinTagV2",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "initTrackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (!noThirdParty) {
  return true;
}

}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* Domain condition for Munchkin Tag specifically*/
var w = window,
  l = w.location,
  p = l.pathname,
  h = l.hostname,
  hostIndex = _satellite.getVar('thirdPartyTags_allowedDomains') || -1,
  index = function(str, substr) {
    return str.indexOf(substr) !== -1;
  };

if(hostIndex === 45){
  return false;
} else if(index(h, 'marketo.') || index(h, 'magento.') || index(p, '/creativecloud/business/teams') || (p.search(/\/creativecloud\/business\/teams\/(what-you-can-make|deploy-and-manage|use-cases|plans)(\/(make-better-brand-kit|marketing|social|marketing-communications))?.html/) != -1) ||
    (h ==='www.adobe.com' && (index(p, '/acrobat') || index(p, '/sign') || index(p, '/documentcloud')))|| index(h, 'partners.adobe') || index(h, 'eml.adobe') || index(p, 'experience-makers-live') || index(h, 'blog.adobe') || index(h, 'cmo.adobe') || index(h, 'dc-stage.magedevteam.com') ||
    index(h, 'summit.adobe') || index(h, 'reg.adobe') || index(h, 'portal.adobe') || index(p, '/summit') || index(p, '/events/') || index(p, 'commerce/magento') || index(p, 'marketing/marketo') || index(h, 'smartrelease.jp')) {

  return true;
} else {
  return false;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "equals"
            },
            "leftOperand": "%thirdParty_isAbort%",
            "rightOperand": "yes"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%isStudent%"
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCccfad245cba34a7daf70ac22999946a0-file.js'
          }
        }
      ]
    },
    {
      "id": "RLcf16ea4b10574debac7e4ec35e3ab144",
      "name": "thirdParty_segmentAMOPixel-DCR",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload_segmentAMOPixel"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC0e82227725b5460b8c89044ef60cad83-file.js'
          }
        }
      ]
    },
    {
      "id": "RLde4f2556de6c4f5e961385efbf8ae460",
      "name": "attributionCookies",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
  cookieConsent = _satellite.cookie.get('OptanonConsent'),
  adobePrivacyPrivacy = 'adobePrivacy:Privacy';

var cookie_update = function(){
  (function(i){var s=i.cookie,e=i._getQueryParam,t=i._getDomain();var d=e("s_iid"),o=e("s_cid"),r=e("s_rtid"),_=e("s_osc"),a={domain:t,expires:30};if(d){s.set("s_iid",d,a)}if(o){s.set("s_cid",o,a)}if(r){s.set("s_rtid",r,a)}if(_){s.set("s_osc",_,a)}var c=e("trackingid"),n=e("sdid"),f=e("promoid"),m=s.get("TID"),g=[],p={domain:t,expires:120};if(c||n||f){m=m||"--";g=m.split("-");g[0]=c||g[0];g[1]=n||g[1];g[2]=f||g[2];s.set("TID",g.join("-"),p)}})(_satellite);
}

//checking for cookie exist
if ((cookieConsent && cookieConsent.indexOf('C0002:1') !== -1)) {
  cookie_update()
}

//Adding event listners to wait and update cookies
else {
  w.addEventListener(adobePrivacyPrivacy + 'Consent', function () {
    cookie_update()
  });

  w.addEventListener(adobePrivacyPrivacy + 'Custom', function () {
    cookie_update()
  });

}
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL7b9d9cca3ab94bf5be271898b20d8f6c",
      "name": "initDemandbase",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 1.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isFalse"
            },
            "leftOperand": "%demandbase_disable%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  
/* eslint-disable */

/*! demandbaseAPI 2017-02-15 16:14:32 */
!function(a){"use strict";var b;b=function(a,c){var d=this;if(!a)throw new Error('Required "config" object not provided.');if(!a.key)throw new Error('"key" is required.');d.key=a.key,c||(this.IP=new b.IP(a),this.Domain=new b.Domain(a),this.Autocomplete=new b.Autocomplete(a))};var c;if(!c&&a.document&&a.document.getElementsByTagName&&a.window?c=function(b,c){var d,e,f="Request_"+Math.floor(1e7*Math.random()),g=function(){a.window[f]=void 0;try{delete a.window[f]}catch(b){}};d=document.getElementsByTagName("HEAD"),e=document.createElement("SCRIPT"),e.type="text/javascript",e.src=b+"&callback="+f,d=d&&d[0]?d[0]:document.body,d&&(a.window[f]=function(a){c(a),g()},d.appendChild(e))}:a.jQuery&&a.jQuery.ajax?c=function(b,c){a.jQuery.ajax({url:b,dataType:"json"}).done(function(a){c(a)}).fail(function(){c()})}:a.XMLHttpRequest&&(c=function(b,c){var d=new a.XMLHttpRequest;d.open("GET",b,!0),d.onload=function(){var a=null;if(200===d.status&&d.responseText)try{a=JSON.parse(d.responseText),c(a)}catch(b){c()}else c()},d.onerror=d.failure=function(){c()},d.send()}),!c)throw new Error("Unable to find a network API for sending requests");b.prototype.request=c,b.IP=function(a){b.call(this,a,!0)},b.IP.prototype=Object.create(b.prototype),b.IP.prototype.constructor=b.IP,b.IP.prototype.endpoint="//api.demandbase.com/api/v2/ip.json",b.IP.prototype.url=function(a){var b=this,c=b.endpoint;return(0===c.indexOf("http")?"":"https:")+c+"?key="+b.key+(a?"&query="+a:"")+"&rnd="+Math.floor(10001*Math.random())},b.IP.prototype.get=function(a){var b=this;b.request(b.url(),function(b){a(b)})},b.IP.prototype.query=function(a,b){var c=this;c.request(c.url(a),function(a){b(a)})},b.Domain=function(a){b.call(this,a,!0)},b.Domain.prototype=Object.create(b.prototype),b.Domain.prototype.constructor=b.Domain,b.Domain.prototype.endpoint="//api.demandbase.com/api/v1/domain.json",b.Domain.prototype.url=function(a){var b=this,c=b.endpoint;return(0===c.indexOf("http")?"":"https:")+c+"?key="+b.key+(a?"&query="+a:"")+"&rnd="+Math.floor(10001*Math.random())},b.Domain.prototype.query=function(a,b){var c=this;c.request(c.url(a),function(a){b(a)})},b.Autocomplete=function(a){var c=this,d=a.Autocomplete;b.call(c,a,!0),d&&(d.country&&(c.country=d.country),d.city&&(c.city=d.city),d.state&&(c.state=d.state),d.zip&&(c.zip=d.zip),d.email&&(c.email=d.email),d.domain&&(c.domain=d.domain),d.records&&(c.records=d.records))},b.Autocomplete.prototype=Object.create(b.prototype),b.Autocomplete.prototype.constructor=b.Autocomplete,b.Autocomplete.prototype.endpoint="//api.demandbase.com/autocomplete",b.Autocomplete.prototype.url=function(a){var b=this,c=b.endpoint;return(0===c.indexOf("http")?"":"https:")+c+"?key="+b.key+(a?"&term="+a:"")+(b.country?"&country="+b.country:"")+(b.city?"&city="+b.city:"")+(b.state?"&state="+b.state:"")+(b.zip?"&zip="+b.zip:"")+(b.email?"&email="+b.email:"")+(b.domain?"&domain="+b.domain:"")+(b.records?"&records="+b.records:"")+"&rnd="+Math.floor(10001*Math.random())},b.Autocomplete.prototype.query=function(a,b){var c=this;c.request(c.url(a),function(a){b(a)})},"object"==typeof module&&"object"==typeof module.exports?module.exports=b:"function"==typeof define&&define.amd?define("demandbaseAPI",[],function(){return b}):a.DemandbaseAPI=b,"undefined"==typeof window||window.DemandbaseAPI||(window.DemandbaseAPI=b)}("undefined"!=typeof window?window:this);

/* eslint-enable */

return true;










}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLd66e1d407e91467e865033cd1ae323ee",
      "name": "thirdParty_CCJP-gTagCampaign",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackGroupConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if (_satellite.path == '/jp/creativecloud/photography.html') {
  return true;
} else { return false; }
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC40a7a82514094e388e5e50f2f82cd761-file.js'
          }
        }
      ]
    },
    {
      "id": "RLde39b70173034dbe801508f03e2951df",
      "name": "thirdParty_PPBU-QuoraTubemogulPixel",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageLoad_QuoraTubemogulPixel"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC13d13be0d92640eab9eb845edea08e2b-file.js'
          }
        }
      ]
    },
    {
      "id": "RL5239b8c8481945d09f7090783940d602",
      "name": "thirdParty_clickTale-Test",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "clicktale_test"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC68773539818f406faba11b6de702989d-file.js'
          }
        }
      ]
    },
    {
      "id": "RL2764e35b542e45199f329be6eada2b5e",
      "name": "trackEvent",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "event"
          },
          "ruleOrder": 5.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  l = w.location,
  h = l.hostname,
  p = l.pathname,
  digitalData = w.digitalData,

  // get the s object
  s = w.s_adobe,

  snapshot,
  setDigitalData,
  track,
  // copy,
  didTrack = false,

  pageNameLogic = _satellite.getVar('adobe_pageNameLogic'),
  eventLength = 0;
// copy = function (source, target, path) {
//   target._set(path, source._get(path));
// };

//------------------------------------------------------------------------------
// Get a snapshot and set the data
//------------------------------------------------------------------------------
// if we were passed data as the second parameter from the _satellite.track
// call, then use that
if (
  event.detail &&
  event.detail.digitalData
) {
  snapshot = event.detail.digitalData;

  // otherwise generate our snapshot it from the data layer
} else {
  snapshot = digitalData._snapshot();
}

// if this call was made before launch loaded, then make sure to update
// the snapshot with the global variables
if (
  event.detail &&
  event.detail._beforeSatelliteLoaded
) {

  // apply global digital data if it was called before _satellite was loaded
  setDigitalData = _satellite.getVar('adobe_digitalData');

  // apply the data elements on the snapshot
  setDigitalData(snapshot);
}




//------------------------------------------------------------------------------
// Track it in the order that we need to
//------------------------------------------------------------------------------

// track function
track = function () {
  var
    linkName,
    variableOverrides = {},
    expires;

  // if we haven't tracked yet
  if (!didTrack) {

    // set the flag so we only track one time for this call
    didTrack = true;

    //--------------------------------------------------------------------------
    // delete the data layer properties
    //--------------------------------------------------------------------------
    if (_satellite.getVar('topFrameInfo_abort')) {
      snapshot._delete('page.topFrameInfo');
      snapshot._delete('page.pageInfo.queryParameters');
      snapshot._delete('page.pageInfo.location.href');
      snapshot._delete('page.pageInfo.location.search');
      snapshot._delete('page.pageInfo.location.hash');
      snapshot._delete('initialPage');
    }

    //-------------------------------------------------------------------------
    //delete homepage pods information
    //-------------------------------------------------------------------------
    snapshot._delete('pods');
    snapshot._delete('primaryPod');

    // To pick latest updated event from event array
    if (snapshot._get('digitalData.event') !== undefined) {
      eventLength = snapshot._get('digitalData.event').length - 1;
    }

    var filterLogic = _satellite.getVar('digitalData.search.filters'),
        sophiaLogic = _satellite.getVar('SophiaLogic');

    snapshot._set(
      'sophiaResponse.listValue',
      // can come from either snapshot or digitalData, it doesn't matter
      sophiaLogic(snapshot)
    );
    //-------------------------------------------------------------------------
    // Adobe exchange Filter update & Project Alfred(Community) & MAX 2020
    //-------------------------------------------------------------------------
    if (snapshot._get('digitalData.primaryEvent.eventInfo.eventName') !== 'page unload' &&
      ((snapshot._get('digitalData.page.pageInfo.siteSection') && snapshot._get('digitalData.page.pageInfo.siteSection').indexOf('Community:') !== -1) ||
        snapshot._get('digitalData.page.pageInfo.siteSection') === 'adobeexchange' ||
        (snapshot._get('page.pageInfo.pageName') && snapshot._get('page.pageInfo.pageName').indexOf('max:2020') !== -1 &&
          snapshot._get('digitalData.primaryEvent.eventInfo.eventName') == 'filterAdd') ||
        w.location.href.indexOf('insights') !== -1)) {
      //updating the filters for Processing Rule
      snapshot._set('digitalData.search.filters', filterLogic(snapshot));

      if (snapshot._get('digitalData.community')) {
        //updating the property for eVar203
        snapshot._set('digitalData.community.communityInfo.details', _satellite.getVar('digitalData.community.communityInfo.details'));

      }
    }
    //For Community, multiple elements on delete/move/merge
    if (snapshot._get('digitalData.primaryEvent.eventInfo.eventName') !== 'page unload' &&
      ((snapshot._get('digitalData.community.attributes.selectedConversations') && snapshot._get('digitalData.community.attributes.selectedConversations').length >= 1))) {
      snapshot._set('digitalData.community.attributes.transitedConversations', _satellite.getVar('digitalData.community.attributes.selectedConversations'));
    }

    //-------------------------------------------------------------------------
    // For now Helpx article-3 & other Helpx pages Linktracking
    //-------------------------------------------------------------------------
    if (
      snapshot._get('digitalData.primaryEvent.eventInfo.eventName') !== 'page unload' &&
      snapshot._get('digitalData.page.pageInfo.siteSection') && snapshot._get('digitalData.page.pageInfo.siteSection') == 'Support & Learning'
    ) {
      snapshot._set('digitalData.linkTracking.params', _satellite.getVar('digitalData.linkTracking.params'));
      snapshot._set('digitalData.search.filters', filterLogic(snapshot));
    }

    //-------------------------------------------------------------------------
    // For now Helpx SERP, can be global
    //-------------------------------------------------------------------------
    if (
      snapshot._get('digitalData.primaryEvent.eventInfo.eventAction') === 'productCardInteraction' ||
      snapshot._get('digitalData.primaryEvent.eventInfo.eventAction') === 'resultLinkInteraction'
    ) {
      snapshot._set('digitalData.search.searchInfo.ctrProp', _satellite.getVar('digitalData.search.searchInfo.ctrProp'));
    }

    //sitesection update
    snapshot._set('digitalData.page.pageInfo.siteSection', _satellite.getVar('digitalData.page.pageInfo.siteSection'));
	
	//hashvalues search term
	snapshot._set('digitalData.page.pageInfo.location.hashValues',_satellite.getVar('digitalData.page.pageInfo.location.hashValues'));
    //-------------------------------------------------------------------------
    // Adobe mini-plans linkname correction
    //-------------------------------------------------------------------------
    if (
      snapshot._get('digitalData.plansPageAttributes.type') &&
      snapshot._get('digitalData.plansPageAttributes.type').indexOf('mini-Plans:web') !== -1 &&
      snapshot._get('digitalData.primaryEvent.eventInfo.eventAction') &&
      snapshot._get('digitalData.primaryEvent.eventInfo.eventAction') === 'buyClick' &&
      snapshot._get('digitalData.primaryEvent.eventInfo.eventName')
    ) {
      snapshot._set(
        'digitalData.primaryEvent.eventInfo.eventName',
        snapshot._get('digitalData.primaryEvent.eventInfo.eventName').replace('Buy', 'Try')
      );
      snapshot._set(
        'digitalData.primaryEvent.eventInfo.eventAction',
        snapshot._get('digitalData.primaryEvent.eventInfo.eventAction').replace('buy', 'try')
      );
    }

    if (snapshot._get('digitalData.plansPageAttributes.type') && snapshot._get('digitalData.plansPageAttributes.type').indexOf('mini-Plans') !== -1) {
      snapshot._set('digitalData.plansPageAttributes.bannerImpression', _satellite.getVar('digitalData.plansPageAttributes.bannerImpression'));
    }

    //plans page
    if (snapshot._get('page.pageInfo.pageName') && snapshot._get('page.pageInfo.pageName').indexOf('adobe.com:creativecloud') !== -1 && (snapshot._get('page.pageInfo.pageName').indexOf('plans') !== -1 || snapshot._get('page.pageInfo.pageName').indexOf('Plans') !== -1)) {
      snapshot._delete('digitalData.product');
      snapshot._delete('digitalData.plansPageAttributes.cardProductData');
    }

    // Delete digitaldata.primaryEvent.eventInfo.eventAction if the previous hit was a 'Download Hit' or 'Exit Link'
    if (snapshot._get('primaryEvent') && snapshot._get('primaryEvent.eventInfo') && snapshot._get('primaryEvent.eventInfo.eventAction') &&
      (snapshot._get('primaryEvent.eventInfo.eventAction') == 'downloadLink' || snapshot._get('primaryEvent.eventInfo.eventAction') == 'exitLink')) {
      snapshot._delete('digitalData.primaryEvent.eventInfo.eventAction');
    }

    // Make Click value match the impression value for the SRP page.
    if (snapshot._get('digitalData.search.searchInfo.linkUrl'))
      snapshot._set('digitalData.search.searchInfo.linkUrlescaped', encodeURIComponent(snapshot._get('digitalData.search.searchInfo.linkUrl').replace('https://', '')));

    //--------------------------------------------------------------------------
    // serialize the data layer into context data
    //--------------------------------------------------------------------------

    // set the data from the data layer
    variableOverrides.contextData =
      snapshot._flatten(snapshot, 'digitalData', false);

    // mark the hit as a event hit
    variableOverrides.contextData['hit.type'] = 'event';

    // special case for GDPR consent and server-side forwarding to AAM for id syncs
    // Please see this for additional information: 
    // https://marketing.adobe.com/resources/help/en_US/reference/ssf-gdpr.html
    variableOverrides.contextData['cm.ssf'] = 0;
    /*variableOverrides.contextData['cm.ssf'] = (
      _satellite.getVar('isConsentGiven') ? 0 : 1
    );*/

    // TODO: set special contextData for a.action (whatever it should be)

    //--------------------------------------------------------------------------
    // determine the linkName based on contextData
    //--------------------------------------------------------------------------

    // if we have a primaryEvent, use the information in there
    if (
      variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventName'] ||
      variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventAction'] ||
      variableOverrides.contextData['digitalData.primaryEvent.eventInfo.id']
    ) {
      linkName =
        // 1) use eventName
        variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventName'] ||
        // 2) if that doesn't exist, use eventAction
        variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventAction'] ||
        // 3) if that doesn't exist, use id
        variableOverrides.contextData['digitalData.primaryEvent.eventInfo.id'];
      // else if we have an array of events, use the first one
    } else if (
      variableOverrides.contextData['digitalData.event.' + eventLength + '.eventInfo.eventName'] ||
      variableOverrides.contextData['digitalData.event.' + eventLength + '.eventInfo.eventAction'] ||
      variableOverrides.contextData['digitalData.event.' + eventLength + '.eventInfo.id']
    ) {
      linkName =
        // 1) use eventName
        variableOverrides.contextData['digitalData.event.' + eventLength + '.eventInfo.eventName'] ||
        // 2) if that doesn't exist, use eventAction
        variableOverrides.contextData['digitalData.event.' + eventLength + '.eventInfo.eventAction'] ||
        // 3) if that doesn't exist, use id
        variableOverrides.contextData['digitalData.event.' + eventLength + '.eventInfo.id'];
    } else if (
      variableOverrides.contextData['digitalData.event.eventName']
    ) {
      //  Condition added to fix xd.adobe.com issue
      linkName = variableOverrides.contextData['digitalData.event.eventName'];
    } else if (
      variableOverrides.contextData['digitalData.page.pageInfo.pageName']
    ) {

      //  if event property doesn't exist, use pageName
      linkName = variableOverrides.contextData['digitalData.page.pageInfo.pageName'];
    }

    // Product Download
    if (
      variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventAction'] &&
      variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventAction'] === 'productDownload' &&
      variableOverrides.contextData['digitalData.primaryProduct.productInfo.productID']
    ) {
      var productDownload = variableOverrides.contextData['digitalData.primaryProduct.productInfo.productID'];
      linkName = variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventAction'];
      variableOverrides.contextData['digitalData.primaryProduct.productInfo.productName'] = 'CCM App Download: ' + (variableOverrides.contextData['digitalData.adobe.creativecloud.isThorInstalled'] ? 'AAMInstalled:' : 'InstallAAM:') + (productDownload ? (productDownload.replace(/(-CC|-DC)/gi, '')).toLowerCase() : '');
    }

    //abort tracking for short form
    if (linkName.indexOf('AEM Short Form') !== -1 && !digitalData._get('adobe.experienceCloud.analytics.tag.logicTrigger')) {
      return true;
    }

    //abort tracking for clap:clicks and 
    if(linkName.indexOf('clap:click') !== -1 || linkName.indexOf('viewershipBoard:click') !== -1){
      return true;
    }

    // abort tracking call for pageload and pageview for dexter issues
    if (
      linkName === 'pageview' ||
      linkName === 'pageload' ||
      linkName === 'pageloadevent' ||
      linkName === 'undefined_buttonClick' ||
      linkName === 'click' || (
        linkName == 'exitLink' &&
        !snapshot._get('digitalData.assetInfo.assetShown.socialshare')
      )
    ) {
      return true;
    }

    if (
      linkName == 'exitLink' &&
      snapshot._get('digitalData.assetInfo.assetShown.socialshare')
    ) {
      linkName = 'SocialShare:' + snapshot._get('digitalData.assetInfo.assetShown.socialshare');
    }

    if (snapshot._get('digitalData.plansPageAttributes.type') === 'Plans - Reimagine' && linkName) {
      variableOverrides.contextData['digitalData.page.pageInfo.pageName'] = pageNameLogic(digitalData._get('page.pageInfo.location'));
      variableOverrides.contextData['digitalData.page.pageInfo.language'] = digitalData._get('language');
      if (linkName.indexOf('See plan & pricing details') !== -1) {
        linkName = 'See plan & pricing:Click';
      }
      if (linkName.indexOf('BuyNowButton') !== -1) {
        linkName = 'BuyNowButton:Click';
        if (digitalData._get('modalName')) {
          variableOverrides.contextData['digitalData.page.pageInfo.pageName'] = digitalData._get('modalName');
        }
      }
      if (linkName.indexOf('Modal:Close:Click') !== -1) {
        linkName = 'Modal:Close:Click';
        digitalData._delete('modalName');
        digitalData._set(
          'page.pageInfo.pageName',
          'adobe.com:creativecloud:plans'
        );
        // set updated previous page name to the current page name 
        expires = new Date();
        expires.setTime(expires.getTime() + 1800000);
        _satellite.cookie.set(
          'gpv',
          // can come from either snapshot or digitalData, it doesn't matter
          digitalData._get('page.pageInfo.pageName'), {
            expires: expires,
            domain: _satellite._getDomain()
          }
        );
      }
      if (linkName.indexOf('Add:Stock:Click') !== -1) {
        linkName = 'Add:Stock:Click';
        snapshot._delete('digitalData.cart.item');
      }
      if (linkName.indexOf('Remove:Stock:Click') !== -1) {
        linkName = 'Remove:Stock:Click';
        snapshot._delete('digitalData.cart.item');
      }
      if (linkName.indexOf('See all business plans') !== -1) {
        linkName = 'See all business plans:Click';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('Add:Click') !== -1) {
        linkName = 'Add:Product:Click';
        digitalData._set(
          'primaryProduct.quantity',
          '1'
        );
        snapshot._delete('digitalData.cart.item');
      }
      if (linkName.indexOf('Remove:Click') !== -1) {
        linkName = 'Remove:Product:Click';
        digitalData._set(
          'primaryProduct.quantity',
          digitalData._get('productInfo.quantity')
        );
        snapshot._delete('digitalData.cart.item');
      }
      if (linkName === 'Remove' || linkName === 'Add' || linkName.indexOf(':IndividualTabModal:Plans:Click') !== -1) {
        linkName = 'Plan:Changed';
      }
      if (linkName.indexOf('Modal:Outside:Click') !== -1) {
        linkName = 'Modal:Outside:Click';
        digitalData._delete('modalName');
        digitalData._set(
          'page.pageInfo.pageName',
          'adobe.com:creativecloud:plans'
        );
        // set updated previous page name to the current page name 
        expires = new Date();
        expires.setTime(expires.getTime() + 1800000);
        _satellite.cookie.set(
          'gpv',
          // can come from either snapshot or digitalData, it doesn't matter
          digitalData._get('page.pageInfo.pageName'), {
            expires: expires,
            domain: _satellite._getDomain()
          }
        );
      }
      if (linkName.indexOf('selectyourplans:Click') !== -1) {
        linkName = 'selectyourplans:Click';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('Quantity:Click') !== -1) {
        linkName = 'Product:Quantity:Change';
        digitalData._set(
          'productInfo.quantity',
          digitalData._get('primaryProduct.productInfo.quantity')
        );
        snapshot._delete('digitalData.cart.item');
      }

      if (linkName.indexOf('see terms') !== -1) {
        linkName = 'see terms:Click';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('Learn more') !== -1) {
        linkName = 'Learn more:Click';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf(':IndividualTabModal:Plans:Click') !== -1) {
        linkName = 'Learn more:Click';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('selectyourplans:Click') !== -1) {
        linkName = 'Selectyourplans:Click';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('TeamTab:Click') !== -1) {
        variableOverrides.contextData['digitalData.plansPageAttributes.selectedTab'] = 'TeamTab';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('EducationTab:Click') !== -1) {
        variableOverrides.contextData['digitalData.plansPageAttributes.selectedTab'] = 'EducationTab';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('EducationInstitutionsTab:Click') !== -1) {
        variableOverrides.contextData['digitalData.plansPageAttributes.selectedTab'] = 'EducationInstitutionsTab';
        snapshot._delete('digitalData.primaryProduct');
      }
      if (linkName.indexOf('IndividualTab:Click') !== -1) {
        variableOverrides.contextData['digitalData.plansPageAttributes.selectedTab'] = 'IndividualTab';
        snapshot._delete('digitalData.primaryProduct');
      }

    }

    var
      productLogic = _satellite.getVar('s.productLogic');

    s.products = productLogic(snapshot);

    //for Admin console
    if (snapshot._get('page.pageInfo.siteSection') && snapshot._get('page.pageInfo.siteSection').indexOf('adminconsole.adobe.com') !== -1) {

      //Fixing eventName and linkName for completeOrder      
      if (snapshot._get('primaryEvent.eventInfo.eventName') === 'adminConsole:completeOrder:click') {
        if (snapshot._get('page.pageInfo.pageName').indexOf('adminconsole.adobe.com:renewReviewOrder') !== -1) {
          variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventName'] = 'adminConsole:updateRenewalOrder:submit';
          linkName = 'adminConsole:updateRenewalOrder:submit';
        } else {
          variableOverrides.contextData['digitalData.primaryEvent.eventInfo.eventName'] = 'adminConsole:addProducts:complete';
          linkName = 'adminConsole:addProducts:complete';
        }
      }

      var acProduct = _satellite.getVar('adobe_adminConsole_products');
      s.products = acProduct(snapshot);


      // userSelectedReasons data to be updated fro page End. Below condition to be deleted once configured from page
      if (snapshot._get('adminConsole') && snapshot._get('adminConsole.purchase') && snapshot._get('adminConsole.purchase.userSelectedReason')) {
        variableOverrides.contextData['digitalData.adminConsole.purchase.allUserSelectedReason.reasonID'] = _satellite.getVar('adobe_adminConsole_userSelectedReasons')(snapshot);
      }
      //Temporaray Fix to update the custom link name. To be deleted once fixed from page.       
      if (linkName === 'adminConsole:addProductsModal2Id:open')
        linkName = 'adminConsole:addProductsModal:open';
      else if (linkName === 'adminConsole:renewProductsModal2Id:open')
        linkName = 'adminConsole:renewProductsModalId:open';
    }

     snapshot._set('digitalData.AEPeventName',linkName);
  
    
    // AM product variable with offerID
    if (digitalData.page.pageInfo.siteSection === 'account.adobe.com') {
      var offerIdLogic;
      offerIdLogic = _satellite.getVar('adobe_AM_offerid');
      s.products = offerIdLogic(snapshot);
    }

    //delete product values for pageunload and target hits
    if (linkName && linkName === 'page unload') {
      s.products = '';
      s.events = '';
    }

    //--------------------------------------------------------------------------
    // send the tracking call
    //--------------------------------------------------------------------------
    s.tl(true, 'o', linkName, variableOverrides);
    
    _satellite.track('aepEvent', {
      digitalData: snapshot
    })

    //delete variables
    s.products = '';
    s.events = '';
    digitalData._delete('digitalData.adobe.experienceCloud.analytics.tag.logicTrigger');

    digitalData._delete('digitalData.primaryEvent');
    digitalData._delete('digitalData.chat');

    if (snapshot._get('page.pageInfo.siteSection') && snapshot._get('page.pageInfo.siteSection').indexOf('adminconsole.adobe.com') !== -1) {
      digitalData._delete('digitalData.primaryProduct');
    }
    digitalData._delete('digitalData.primaryEvent');
  }

};

//abort tracking for Search tracking on Summit 
if(snapshot._get('digitalData.primaryEvent.eventInfo.eventName') && snapshot._get('digitalData.primaryEvent.eventInfo.eventName').indexOf('|Search|') !== -1 &&  
  snapshot._get('page.pageInfo.pageName') && snapshot._get('page.pageInfo.pageName').indexOf(':summit:') !== -1){
  return true;
}

if (snapshot._get('page.pageInfo.location.hostname') && snapshot._get('page.pageInfo.location.hostname') === 'play.vidyard.com') {
  track();
}

// make sure that we have a promise created if we haven't done that already
s._lastHitPromise = s._lastHitPromise || Promise.resolve();

// update the s._lastHitPromise to be me
s._lastHitPromise =

  // only track after dependencies
  Promise.all([
    // wait for the page load
    s._pageloadTrackedPromise,
    // wait until the data layer snapshot is resolved
    snapshot._resolved(),
    // wait until the last hit was sent
    s._lastHitPromise
  ])

  .then(track);

// timeout for 15 seconds and then force track
setTimeout(track, 15 * 1000);

// before unload force track
_satellite._beforeUnload(track, -3);

// return true to say that this should be tracked and not hold anything up

return true;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL2a7086d61c2e4f83985e7156b630b5ab",
      "name": "thirdParty_yahooDCconversionTagUSJP",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "yahoo_conversionTag"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC4e34029b87f045b29bd556a236cc0a60-file.js'
          }
        }
      ]
    },
    {
      "id": "RLa21a1fcabd3b48a9b41d6fff1c2073f6",
      "name": "thirdParty_YahooPixel-DCR",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload-YahooPixel"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCb77b8db7ee284048a8a849c9afb3f6a2-file.js'
          }
        }
      ]
    },
    {
      "id": "RL2cb966e6cf5b41cf90e3dcb2191386b9",
      "name": "thirdParty_eLearningIndustryPixel",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload_eLearningCaptivate"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC226a273f08894b5b86cfa96f815c3e6e-file.js'
          }
        }
      ]
    },
    {
      "id": "RLd5ccf411fbd141589c035df83445cb42",
      "name": "topHat",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  return [
  // 'adobe.com',
  'www.stage.adobe.com',
  'www.adobe.com',
  'acrobat.adobe.com',
  'stock.adobe.com',
  'commerce.adobe.com',
  'shop.adobe.com',
  'helpx.adobe.com',
  'spark.adobe.com',
  'adminconsole.adobe.com',
  'futureisyours.adobe.com',
  'lightroom.adobe.com',
  'create.adobe.com',
  'creative.adobe.com',
  'creativecloud.adobe.com',
  'makeitcenter.adobe.com',
  'success.adobe.com',
  'landing.adobe.com',
  'echosign.adobe.com',
  // 'acrobat.com',
  'echosign.acrobat.com',
  'acrobatprotrial.acrobat.com',
  'acrobatprosubs.acrobat.com',
  'createpdf.acrobat.com',
  'exportpdf.acrobat.com',
  'pdfpack.acrobat.com',
  // 'photoshop.com',
  'www.photoshop.com',
  'www.adobe-students.com',
  'adobestockmasterpiece.com',
  'www.adobestockmasterpiece.com',
].indexOf(window.location.hostname) !== -1;
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC3459a37bb5364bcdb417b5671a49c7d6-file.js'
          }
        }
      ]
    },
    {
      "id": "RLc5fe074f72104551a6445d70893b23a6",
      "name": "initVideoPlayer",
      "events": [
        {
          "modulePath": "core/src/lib/events/pageBottom.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTrue"
            },
            "leftOperand": "%enable_performanceCookie%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
  loc = w.location,
  path = loc.pathname,
  host = loc.hostname;

if (((host.indexOf('.adobe.com') != -1 && path.indexOf('/summit/adobe-summit.html') != -1))
) {  
  return true;
}

}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC95d9e331707842e7b9682b42e58b099a-file.js'
          }
        }
      ]
    },
    {
      "id": "RL8e1fc6a9fa8b4d9e8af6673b4f8c5fde",
      "name": "thirdParty_pageLoadCMO",
      "events": [
        {
          "modulePath": "core/src/lib/events/customCode.js",
          "settings": {
            "source": function(trigger) {
  /* global trigger:true */ 
var
  w = window,
  // d = document,
  determineConsent,
  wait,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (noThirdParty) {
  return;
}

wait = function () {
  setTimeout(trigger, 100);
};

//------------------------------------------------------------------------------
// determine whether consent has been granted or if we should wait for it
//------------------------------------------------------------------------------
determineConsent = function () {

  // if consent is given
  if (_satellite.getVar('isConsentGiven')) {
    wait();

  // otherwise, wait until the PrivacyConsent event fires and consent is given
  } else {
    w.addEventListener('adobePrivacy:PrivacyConsent', wait);
  }

};

// if the ready state has already been fired
// NOTE: this is because launch can fire after window.load has already fired...
// it is unlikely, but we have to cover this case
if (document.readyState === 'complete') {
  determineConsent();

// if it hasn't fired yet
} else {
  w.addEventListener('load', determineConsent);
}

}
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
   //window.thirdParty_pageLoad_AdobeCom = false;

if (_satellite.getVar('thirdPartyTags_allowedDomains') && _satellite.getVar('thirdPartyTags_allowedDomains') == 5 ) {
    return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC47ca408fca5140a48a33836fd6522362-file.js'
          }
        }
      ]
    },
    {
      "id": "RLaa9e2956e35544d4a3fa219ba118477a",
      "name": "thirdParty_pageLoadHelpxCommunityAdobePixels",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var hostIndex = _satellite.getVar('thirdPartyTags_allowedDomains') || -1;

if (hostIndex == 3 || hostIndex == 4) {
  return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCea5ba2fa151a4a8eb85ed6d735ef0a32-file.js'
          }
        }
      ]
    },
    {
      "id": "RLebf5b567350c4ebbaa6e235445d11e6d",
      "name": "trackSubNav -AEC",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
  d = document;

// Global Nav Custom link tracking
(function () {

  var
    eventType = 'click',
    getAnchor,
    getAttribute,
    trackLink,
    handler;

  getAnchor = function (start) {
    var
      node,
      i;

    node = start;

    // make sure that we have a node
    if (!node) {
      return null;
    }

    // look up to 3 levels deep
    for (i = 0; i < 3; i++) {

      // if this node is an anchor return it
      if (node.nodeName.toLowerCase() === 'a') {
        return node;

        // if not, then try it's parent
      } else {

        // make sure that we have a parent
        if (node.parentNode) {
          node = node.parentNode;

          // if no parent, return null
        } else {
          return null;
        }

      }
    }

    return null;
  };

  getAttribute = function (node, name) {
    if (
      node &&
      name &&
      node.getAttribute
    ) {
      return node.getAttribute(name);
    }

    return '';
  };

  trackLink = function (linkName) {

    digitalData._set(
      'digitalData.primaryEvent.eventInfo.eventName',
      linkName
    );

    _satellite.track('event');
    
    digitalData._delete(
    'digitalData.primaryEvent.eventInfo.eventName'
  );
    
  };

  handle = function (evt) {
    var
      node,
      linkName,
      trackname,
      subString = 'Subnav',
      parentString = '';

    try {

      // get the element
      node = getAnchor(evt.target || evt.srcElement);

      // if we found a link
      if (node && node.className == "Subnav-menu-label" || node.className == 'Subnav-submenu-link' || node.className == "Subnav-logo" || node.className == "Subnav-menu-button") {
        //debugger;
        parent = node.parentNode;
        if (node.className == "Subnav-logo") {
          linkName = "Insights"
        } else if (getAttribute(node, 'title')) {
          linkName = getAttribute(node, 'title');
          if (parent && linkName !== 'Archive' && linkName !== 'Insights') {
            var sub = node.parents(".has-submenu");
            if (sub) {
              parentString = sub.children[0].attributes["title"].value;
              if (parentString === linkName && (linkName != "Compare")) parentString = '';
              else if (node.className == "Subnav-menu-label" && linkName == "Compare") parentString = '';

              else parentString = parentString + "-";
            }
          }

        }
        trackname = (subString + "-" + parentString + linkName).toLowerCase();
        trackLink(trackname);

      } // node

    } catch (err) {
      // console.error(err);
    }
  };

  if (d.addEventListener) {
    d.addEventListener(eventType, handle, true);
  } else if (d.attachEvent) {
    d.attachEvent('on' + eventType, handle);
  }

})();


}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if(_satellite.getVar('adobe_aec_pages')){
  return true;
}
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLc48b497299c14dbeb3121d716ec0df0a",
      "name": "thirdParty_pageLoadMicroSites",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
   //window.thirdParty_pageLoad_AdobeCom = false;

if (_satellite.getVar('thirdPartyTags_allowedDomains') && _satellite.getVar('thirdPartyTags_allowedDomains') > 25 ) {
    return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCd554bc5ddeb84ec3821b2f728a48a639-file.js'
          }
        }
      ]
    },
    {
      "id": "RL1368c53956084d149f8f9f3bef2be20f",
      "name": "initAdCloud",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var hostnameIndex = _satellite.getVar('thirdPartyTags_allowedDomains') || -1;
if (hostnameIndex == 35 || hostnameIndex == 42 || hostnameIndex == 43) {
  return false;
} else { return true; }
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC2ac07849f462476ca650555609c0303c-file.js'
          }
        }
      ]
    },
    {
      "id": "RL41d0007fa3044a83bf2f5b7562a254df",
      "name": "initOneSignal",
      "events": [
        {
          "modulePath": "core/src/lib/events/customCode.js",
          "settings": {
            "source": function(trigger) {
  /* global trigger:true */ 
var
  w = window,
  // d = document,
  determineConsent,
  wait,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (noThirdParty) {
  return;
}

wait = function () {
  setTimeout(trigger, 8000);
};

//------------------------------------------------------------------------------
// determine whether consent has been granted or if we should wait for it
//------------------------------------------------------------------------------
determineConsent = function () {

  // if consent is given
  if (_satellite.getVar('isConsentGiven')) {
    wait();

  // otherwise, wait until the PrivacyConsent event fires and consent is given
  } else {
    w.addEventListener('adobePrivacy:PrivacyConsent', wait);
  }

};

// if the ready state has already been fired
// NOTE: this is because launch can fire after window.load has already fired...
// it is unlikely, but we have to cover this case
if (document.readyState === 'complete') {
  determineConsent();

// if it hasn't fired yet
} else {
  w.addEventListener('load', determineConsent);
}
}
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var allowed = false;

var region = digitalData._get('digitalData.page.pageInfo.language');

if(region){
  
  if(region.toLowerCase().indexOf('us')!==-1)
  {
    allowed = true; 
    
  }
  
}  

return allowed;
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var hostname = window.location.hostname;

return (
(
  hostname === 'publish-cmo-stage-sky.ethos13-prod-va7.ethos.adobe.net' ||
  hostname === 'publish-cmo-dev-sky.ethos13-prod-va7.ethos.adobe.net' ||
  hostname === 'cmo.adobe.com'
)
)
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCfb451da0ab174599a3cb955a14cac43f-file.js'
          }
        }
      ]
    },
    {
      "id": "RL9834d4c635954e0db33955962ae4f74e",
      "name": "initBranch",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var href = window.location.href;

if(href.indexOf('adobe.com/acrobat/mobile/scanner-app') !==-1){
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC40fca4a6fc3941d1bb79cbb560c74b72-file.js'
          }
        }
      ]
    },
    {
      "id": "RL4835e0a4d75d4ba6b026388ce41b2b38",
      "name": "thirdParty_pageLoadAcrobatDotCom",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if ( _satellite.getVar('thirdPartyTags_allowedDomains') && _satellite.getVar('thirdPartyTags_allowedDomains') == 2 ) {
    return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC52a46d7f1f3741ca8670a92ec026d706-file.js'
          }
        }
      ]
    },
    {
      "id": "RL9b0b1224ee304125ac6db8be2b55b6fb",
      "name": "thirdParty_FB-PPBU",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackGroupConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var _sat = _satellite,
  p = _sat.path,
  index = _sat._index;

if ((p.search(/\/(products)\/(designtoprint|EmbeddedPrintEngine|pdfprintengine|postscript|textiledesigner).html/) > -1) || index(p, 'creativecloud.details.103122.adobe-design-to-print')) {
  return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCf9220c5d06dc4321ab66cce0d173868c-source.js',
            "language": "javascript",
            "isExternal": true
          }
        }
      ]
    },
    {
      "id": "RL2ce5108667f84f4cb6c79caef8273631",
      "name": "thirdParty_windowLevel_property",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 1.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC89c6d3bd15f043db95a5a0a4b5cc9da0-file.js'
          }
        }
      ]
    },
    {
      "id": "RL6b90a37bebb740aa862a6544ab3a83e0",
      "name": "initAppLauncherTracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
    d = document;

// Global Nav Custom link tracking
(function () {

    var
        eventType = 'click',
        getAnchor,
        getAttribute,
        trackLink,
        handler;

    getAnchor = function (start) {
        var
            node,
            i;

        node = start;

        // make sure that we have a node
        if (!node) {
            return null;
        }

        // look up to 3 levels deep
        for (i = 0; i < 3; i++) {

            // if this node is an anchor return it
            if (node.getAttribute("data-analytics-event")) {
                return node;

                // if not, then try it's parent
            } else {

                // make sure that we have a parent
                if (node.parentNode) {
                    node = node.parentNode;

                    // if no parent, return null
                } else {
                    return null;
                }

            }
        }

        return null;
    };

    getAttribute = function (node, name) {
        if (
            node &&
            name &&
            node.getAttribute
        ) {
            return node.getAttribute(name);
        }

        return '';
    };

    trackLink = function (node) {
        var
            linkTrackVars = 'channel,prop3,prop4,prop12,prop27,prop52,prop42,eVar12,eVar14,eVar16,eVar18,eVar22,eVar28,eVar80,eVar69,eVar111,eVar84',
            s = w.s_adbadobenonacdc,
            linkText = node.getAttribute("data-analytics-event"),
            data_apps,
            linkeVar80,
            clickUrl,
            click_app,
            snapshot = digitalData._snapshot();
 
        linkeVar80 = linkText;
        if (linkText === "AppLauncher.appIconToggle") {
            if (node.getAttribute("data-analytics-is-expanded") == "false")
                linkText = "AppLauncher.appIconToggle.Open"
            else
                linkText = "AppLauncher.appIconToggle.Close"

            linkeVar80 = linkText;
            window.data_apps = node.getAttribute("data-analytics-apps");
            snapshot._set(
                'digitalData.appLauncher.appsShown',
                window.data_apps
            );
        }
        if (linkText === "AppLauncher.more" || linkText === "AppLauncher.viewAll") {
            // data_apps = "Creative Cloud Apps|Document Cloud Apps|Experience Cloud Apps";
            if (linkText === "AppLauncher.viewAll") {
                if (node.getAttribute("aria-label").indexOf("Creative") !== -1) {
                    click_app = "Creative Cloud Apps"
                }
                if (node.getAttribute("aria-label").indexOf("Document") !== -1) {
                    click_app = "Document Cloud Apps"
                }
                if (node.getAttribute("aria-label").indexOf("Experience") !== -1) {
                    click_app = "Experience Cloud Apps"
                }
                if (click_app)
                    linkText = linkText + "." + click_app;
                if (click_app && clickUrl)
                    linkeVar80 = linkText + "|" + click_app + "|" + clickUrl;
            }
          else{
             linkeVar80 = linkText;
          }
            
        }

        if (node.getAttribute("data-analytics-app")) {
            clickUrl = node.getAttribute("data-analytics-url");
            click_app = node.getAttribute("data-analytics-app").replace(":", "|");
            linkeVar80 = linkText + "|" + click_app + "|" + clickUrl;
            snapshot._set(
                'digitalData.appLauncher.clickdata',
                "OneApp:" + click_app
            );
            snapshot._set(
                'digitalData.appLauncher.appsShown',
                window.data_apps
            );
        }
        snapshot._set(
            'digitalData.appLauncher.clickvariable',
            linkeVar80
        );

        snapshot._set(
            'digitalData.primaryEvent.eventInfo.eventName',
            linkText
        );
        snapshot._set(
          'digitalData.adobe.experienceCloud.analytics.tag.logicTrigger',
          'initAppLaunchertracking'
        );

        _satellite.track('event', {
            // Send as a parameter a snapshot of the data layer at this point in time.
            // Note: if this is not set, we will handle take a snapshot within
            // the _satellite.track handler.
            digitalData: snapshot
        });


        digitalData._delete(
            'digitalData.appLauncher'
        );
        

    };

    handle = function (evt) {
        var
            node;

        try {

            // get the element
            node = getAnchor(evt.target || evt.srcElement);

            // if we found a link
            if (node && node.getAttribute("data-analytics-event")) {
                trackLink(node);

            } // node

        } catch (err) {
            // console.error(err);
        }
    };

    if (d.addEventListener) {
        d.addEventListener(eventType, handle, true);
    } else if (d.attachEvent) {
        d.attachEvent('on' + eventType, handle);
    }

})();

}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLde1d940a6f78401b9def7adf12489677",
      "name": "thirdParty_pageLoadAMO_DC_Sign",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "thirdPartyPageLoad_AMO_DCSign"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCf819bfa3c8b447c8ba02ca34898d9583-file.js'
          }
        }
      ]
    },
    {
      "id": "RLacf993f191134063815b48a97cd3dfb9",
      "name": "initGlobalNavFooterTracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* global digitalData:true  */
var
  d = document;

// Global Nav Custom link tracking
(function () {

  var
    eventType = 'click',
    getAnchor,
    getAttribute,
    trackLink,
    handler;

  getAnchor = function (start) {
    var
      node,
      i;

    node = start;

    // make sure that we have a node
    if (!node) {
      return null;
    }

    // look up to 3 levels deep
    for (i = 0; i < 3; i++) {

      // if this node is an anchor return it
      if (node.nodeName.toLowerCase() === 'a') {
        return node;

        // if not, then try it's parent
      } else {

        // make sure that we have a parent
        if (node.parentNode) {
          node = node.parentNode;

          // if no parent, return null
        } else {
          return null;
        }

      }
    }

    return null;
  };

  getAttribute = function (node, name) {
    if (
      node &&
      name &&
      node.getAttribute
    ) {
      return node.getAttribute(name);
    }

    return '';
  };

  trackLink = function (linkName) {
    var snapshot = digitalData._snapshot();
    snapshot._set(
      'digitalData.globalNav.linkName',
      linkName
    );

    snapshot._set(
      'digitalData.primaryEvent.eventInfo.eventName',
      linkName
    );


    _satellite.track('event', {
      // Send as a parameter a snapshot of the data layer at this point in time.
      // Note: if this is not set, we will handle take a snapshot within
      // the _satellite.track handler.
      digitalData: snapshot
    });

  };

  handler = function (evt) {
    var
      node,
      parent,
      linkName,
      id,
      clas,
      headerString = 'Header.',
      footerString = 'Footer.',
      globalNavString = 'Globalnav';

    try {

      // get the element 
      node = getAnchor(evt.target || evt.srcElement);

      // if we found a link
      if (node) {

        //--------------------------------------------------------
        // automatic linkName tracking
        //--------------------------------------------------------
        if (getAttribute(node, 'data-adobe-analytics-linkName')) {

          // get the link name
          linkName = getAttribute(node, 'data-adobe-analytics-linkName');

          // link
          trackLink(linkName);

          //--------------------------------------------------------
          // custom tracking
          //--------------------------------------------------------
        } else {

          // get parent
          parent = node.parentNode;

          // Globalnav
          // =========

          id = getAttribute(parent, 'id');

          // Globalnav id tracking
          if (
            parent &&
            id &&
            id.indexOf(globalNavString) !== -1
          ) {

            // get the link name
            linkName = id;

            // class
            clas = getAttribute(parent, 'class');

            // if the parent has a class, check it for whether it is a sub-menu
            if (clas) {

              // add a space at the end so that we can compare classnames
              // exactly
              clas += ' ';

              // Header or Footer
              if (clas.indexOf('Footernav') !== -1) {
                linkName = footerString + linkName;
              } else {
                linkName = headerString + linkName;
              }

              // has submenu
              if (clas.indexOf('has-submenu ') !== -1) {

                if (clas.indexOf('is-open ') !== -1) {
                  trackLink(linkName + '.Close');
                } else {
                  trackLink(linkName + '.Open');
                }

              } else {
                trackLink(linkName);
              }

            } else {
              trackLink(linkName);
            }

          } else {

            // class
            clas = getAttribute(node, 'class');

            if (clas) {

              // add a space at the end so that we can compare classnames
              // exactly
              clas += ' ';

              // Global nav logo
              if (clas.indexOf('Gnav-logo ') !== -1) {
                trackLink(headerString + globalNavString + '.Logo');

                // Search Open and Close
              } else if (clas.indexOf('Gnav-action-search ') !== -1) {

                if (clas.indexOf('is-open ') !== -1) {
                  trackLink(headerString + globalNavString + '.Search.Close');
                } else {
                  trackLink(headerString + globalNavString + '.Search.Open');
                }

                // Sign In
              } else if (clas.indexOf('Gnav-action-login ') !== -1) {
                trackLink(headerString + globalNavString + '.SignIn');

                // Profile thumbnail
              } else if (clas.indexOf('Profile-thumbnail ') !== -1) {
                trackLink(headerString + globalNavString + '.ProfileThumbnail');

                // Profile header
              } else if (clas.indexOf('Profile-header ') !== -1) {
                trackLink(headerString + globalNavString + '.ProfileHeader');

                // Sign Out
              } else if (clas.indexOf('Profile-menu-link ') !== -1) {
                trackLink(headerString + globalNavString + '.SignOut');
              }

            } // class

          } // parent && parent.id

        } // data-adobe-analytics-linkName

      } // node

    } catch (err) {
      // console.error(err);
    }
  };

  if (d.addEventListener) {
    d.addEventListener(eventType, handler, true);
  } else if (d.attachEvent) {
    d.attachEvent('on' + eventType, handler);
  }

})();
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RLe309d06e98e948f29dcf9c4954a2e8fe",
      "name": "thirdParty_marketo/magento- Marketing tags",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var hostnameIndex = _satellite.getVar('thirdPartyTags_allowedDomains') || -1;
if(hostnameIndex == 35 || hostnameIndex == 42 || hostnameIndex == 43){
return true;
}else {return false;}

}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCaad478fbe7034ab5ac327b1354dafb33-file.js'
          }
        }
      ]
    },
    {
      "id": "RL60e501a802bc41a3927840c6139eaf84",
      "name": "thirdParty_doubleClickMaxPages",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "initTrackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  search = w.location.search,
  noThirdParty = search.indexOf('noThirdParty=true') !== -1;

if (!noThirdParty) {
  return true;
}

}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /* Domain condition for fonts.adobe.com*/
var h = _satellite.host;

if (h == 'www.adobe.com' || h == 'reg.adobe.com') {
  return true;
} else {
  return false;
}
}
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "equals"
            },
            "leftOperand": "%thirdParty_isAbort%",
            "rightOperand": "yes"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isTruthy"
            },
            "leftOperand": "%isStudent%"
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC118ac597d9c3486187a29fc704139598-file.js'
          }
        }
      ]
    },
    {
      "id": "RL685c63760ca444c091ba71a1f2944210",
      "name": "initDnB",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 5.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/valueComparison.js",
          "settings": {
            "comparison": {
              "operator": "isFalse"
            },
            "leftOperand": "%demandbase_disable%"
          }
        },
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var _sat = _satellite,
	index = _sat._index;
if (_sat.cookie.get('DnB') !== '2' &&
  (_sat.getVar('thirdParty_isAbort') === 'yes' &&
    !(index(_sat.host,'creativecloud.adobe.com')))
) {
  return true;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCd685f8c6c09c43808ebe3d73ec90e0e1-file.js'
          }
        }
      ]
    },
    {
      "id": "RLa0d4bca36ac14d2a88f641d81757cd73",
      "name": "thirdParty_party_emlTags",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackGroupConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var w = window,
  l = w.location,
  h = l.hostname,
  p = l.pathname;

if (p.indexOf('experience-makers-live') > -1){
  return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCfd42c81a28b74da2a1f46ed7e0a9b3dd-file.js'
          }
        }
      ]
    },
    {
      "id": "RL477a73ef69424a9a8433332e8495b731",
      "name": "thirdParty_pageLoadAdobeDotCom",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "trackConsent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
   //window.thirdParty_pageLoad_AdobeCom = false;

if (_satellite.getVar('thirdPartyTags_allowedDomains') && _satellite.getVar('thirdPartyTags_allowedDomains') == 1 ) {
    return true;
} else {
  return false;
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC75c80e292613438982f0f535da2d662b-file.js'
          }
        }
      ]
    },
    {
      "id": "RLf10a72107e654d7fbb58e32cc16bc420",
      "name": "initMarketoForms",
      "events": [
        {
          "modulePath": "core/src/lib/events/windowLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  /*var hostname = window.location.hostname,
  pathname = window.location.pathname;

if ((hostname !== 'magento.com' && hostname.indexOf('na-ab') == -1 && hostname.indexOf('engage.adobe') == -1 && hostname !== 'play.vidyard.com' && pathname.indexOf('/experience-makers-live/2020') == -1)) {

  return true;

}*/

var hostname = window.location.hostname,
    pathname = window.location.pathname;

if((hostname.indexOf('engage.adobe') ==-1 && hostname !=='play.vidyard.com' && pathname.indexOf("/summit/2021/sessions")==-1 ) ){
  
return true;
  
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC036830be72f242959c7b9ca66cef0c85-file.js'
          }
        }
      ]
    },
    {
      "id": "RL2a1c9b3746a54d2b9b0749647dd17649",
      "name": "thirdParty_linkedIn_conversion_tag",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "pageload_linkedInConversion"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC4846730ef0aa440aa6c8889d6600a13c-file.js'
          }
        }
      ]
    },
    {
      "id": "RL941e793542b34c2197f6cd3106de929e",
      "name": "thirdParty_gtag&AMOConversion",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "thirdParty_gtagEvent"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RC53d6b998bf674e94820342b15f52d798-file.js'
          }
        }
      ]
    },
    {
      "id": "RLa22f6722b4ab4b92a95dd2e3e4fc5938",
      "name": "initVisitorService",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 4.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  var
  w = window,
  s = w.s_adobe,
  v = s.visitor,
  digitalData = w.digitalData,
  midTimeout;

// set the customer id for "mcid"
midTimeout = setTimeout(function () {
  v.setCustomerIDs({
    'mcid': v.getMarketingCloudVisitorID()
  });
}, 3000);

// set the customer id for "adobeid" and "adobe813"
digitalData._on('primaryUser.primaryProfile.profileInfo.profileID', function (adobeid) {

  // clear timeout for setting mcid
  clearTimeout(midTimeout);

  // to remove @adobe from adobe id
  var adobeidCustom = (adobeid && adobeid.indexOf('@') !== -1) ? adobeid.split('@')[0] : adobeid;

  // set all customer ids
  v.setCustomerIDs({
    'adobeid': {
      id: adobeid,
      authState: w.Visitor.AuthState.AUTHENTICATED
    },
    'adobe813': {
      id: adobeid,
      authState: w.Visitor.AuthState.AUTHENTICATED
    },
    'adobeidMCI': {
      id: adobeidCustom,
      authState: w.Visitor.AuthState.AUTHENTICATED
    },
    'mcid': v.getMarketingCloudVisitorID()
  });

});

return false;
}
          }
        }
      ],
      "actions": [

      ]
    },
    {
      "id": "RL2d701364692f4d919bcd9f382c7ae457",
      "name": "thirdParty_adserverJP",
      "events": [
        {
          "modulePath": "core/src/lib/events/directCall.js",
          "settings": {
            "identifier": "thirdParty_adsrvrJP"
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [

      ],
      "actions": [
        {
          "modulePath": "simple-custom-code-action/src/lib/actions/customCode.js",
          "settings": {
            "file": 'https://assets.adobedtm.com/d4d114c60e50/f3fbfbe0e7ca/26013ad5259b/RCa3d279e4e50849abad47235d66a97f6b-file.js'
          }
        }
      ]
    },
    {
      "id": "RL2de5fe86ed014f59a96e5cd0ac2fffb2",
      "name": "vidyardTracking",
      "events": [
        {
          "modulePath": "core/src/lib/events/libraryLoaded.js",
          "settings": {
          },
          "ruleOrder": 50.0
        }
      ],
      "conditions": [
        {
          "modulePath": "core/src/lib/conditions/customCode.js",
          "settings": {
            "source": function(event, target) {
  if(window.location.href.indexOf('/experience-makers-live') !==-1){
  
  return true;
  
}
}
          }
        }
      ],
      "actions": [
        {
          "modulePath": "core/src/lib/actions/customCode.js",
          "settings": {
            "source": "//window.onVidyardAPI = function (vidyardEmbed) {\n\nvar aa = document.createElement(\"script\");\n    aa.type = \"text/javascript\";\n    aa.src = \"//engage.marketo.com/rs/460-TDH-945/images/video.js\"\ndocument.getElementsByTagName(\"head\")[0].appendChild(aa);\n  \n//}",
            "language": "javascript"
          }
        }
      ]
    }
  ]
}
})();

var _satellite = (function () {
	'use strict';

	if (!window.atob) { console.warn('Adobe Launch is unsupported in IE 9 and below.'); return; }

	var reactorDocument = document;

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	var reactorObjectAssign = objectAssign;

	var reactorWindow = window;

	/***************************************************************************************
	 * (c) 2021 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var createDynamicHostResolver = function (turbineEmbedCode, cdnAllowList, debugController) {
	  // even an empty list is flagging to us that we're trying to enforce dynamic
	  var isDynamicEnforced = Array.isArray(cdnAllowList);
	  var shouldAugment = Boolean(isDynamicEnforced && turbineEmbedCode);

	  // TODO: web only? I think embedded TVs wouldn't have
	  //  __satellite.container.dynamicEnforced turned on
	  var turbineUrl = document.createElement('a');
	  turbineUrl.href = turbineEmbedCode;
	  if (
	    (!/^https?:\/\/.*/.test(turbineEmbedCode) || !turbineUrl.host) &&
	    isDynamicEnforced
	  ) {
	    var missingEmbedCodeError = new Error(
	      'Unable to find the Library Embed Code for Dynamic Host Resolution.'
	    );
	    missingEmbedCodeError.code = 'dynamic_host_resolver_constructor_error';
	    throw missingEmbedCodeError;
	  }

	  if (isDynamicEnforced && cdnAllowList.indexOf(turbineUrl.hostname) === -1) {
	    var dynamicDeniedError = new Error(
	      'This library is not authorized for this domain. ' +
	        'Please contact your CSM for more information.'
	    );
	    dynamicDeniedError.code = 'dynamic_host_not_allowed';
	    throw dynamicDeniedError;
	  }

	  /**
	   * Returns the host of the Turbine embed code, or an empty string if Dynamic Host
	   * is not enabled.
	   * @returns {string}
	   */
	  var memoizedHostResult;
	  var getTurbineHost = function () {
	    if (memoizedHostResult != null) {
	      return memoizedHostResult;
	    }

	    if (shouldAugment) {
	      // be sure we always force https to Adobe managed domains.
	      // IE 10/11 returns the :443 protocol when modern browsers don't, so this replacement
	      // is bringing every browser in line with the same return value
	      var sanitizedHost = turbineUrl.host;
	      if (/:80$/.test(sanitizedHost)) {
	        sanitizedHost = sanitizedHost.replace(':80', '');
	      } else if (/:80\/$/.test(sanitizedHost)) {
	        sanitizedHost = sanitizedHost.replace(':80/', '');
	      } else if (/:443$/.test(sanitizedHost)) {
	        sanitizedHost = sanitizedHost.replace(':443', '');
	      } else if (/:443\/$/.test(sanitizedHost)) {
	        sanitizedHost = sanitizedHost.replace(':443/', '');
	      }

	      memoizedHostResult = 'https://' + sanitizedHost;
	    } else {
	      memoizedHostResult = '';
	    }

	    return memoizedHostResult;
	  };

	  /**
	   * Returns a url decorated with the host of the Turbine embed code. If Dynamic host
	   * is disabled, the original sourceUrl is returned unmodified.
	   * @param sourceUrl
	   * @returns {string|*}
	   */
	  var decorateWithDynamicHost = function (sourceUrl) {
	    if (shouldAugment && typeof sourceUrl === 'string') {
	      var urlParts = [
	        getTurbineHost(),
	        sourceUrl.charAt(0) === '/' ? sourceUrl.slice(1) : sourceUrl
	      ];

	      return urlParts.join('/');
	    }

	    return sourceUrl;
	  };

	  var dynamicHostResolver = {
	    getTurbineHost: getTurbineHost,
	    decorateWithDynamicHost: decorateWithDynamicHost,
	    get isDynamicEnforced() {
	      return isDynamicEnforced;
	    }
	  };

	  if (reactorWindow) {
	    debugController.onDebugChanged(function (isEnabled) {
	      if (isEnabled) {
	        reactorWindow.dynamicHostResolver = dynamicHostResolver;
	      } else {
	        delete reactorWindow.dynamicHostResolver;
	      }
	    });
	  }

	  return dynamicHostResolver;
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * Rules can be ordered by users at the event type level. For example, assume both Rule A and Rule B
	 * use the Library Loaded and Window Loaded event types. Rule A can be ordered to come before Rule B
	 * on Library Loaded but after Rule B on Window Loaded.
	 *
	 * Order values are integers and act more as a priority. In other words, multiple rules can have the
	 * same order value. If they have the same order value, their order of execution should be
	 * considered nondetermistic.
	 *
	 * @param {Array} rules
	 * @returns {Array} An ordered array of rule-event pair objects.
	 */
	var buildRuleExecutionOrder = function (rules) {
	  var ruleEventPairs = [];

	  rules.forEach(function (rule) {
	    if (rule.events) {
	      rule.events.forEach(function (event) {
	        ruleEventPairs.push({
	          rule: rule,
	          event: event
	        });
	      });
	    }
	  });

	  return ruleEventPairs.sort(function (ruleEventPairA, ruleEventPairB) {
	    return ruleEventPairA.event.ruleOrder - ruleEventPairB.event.ruleOrder;
	  });
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var DEBUG_LOCAL_STORAGE_NAME = 'debug';

	var createDebugController = function (localStorage, logger) {
	  var getPersistedDebugEnabled = function () {
	    return localStorage.getItem(DEBUG_LOCAL_STORAGE_NAME) === 'true';
	  };

	  var setPersistedDebugEnabled = function (enabled) {
	    localStorage.setItem(DEBUG_LOCAL_STORAGE_NAME, enabled);
	  };

	  var debugChangedCallbacks = [];
	  var onDebugChanged = function (callback) {
	    debugChangedCallbacks.push(callback);
	  };

	  logger.outputEnabled = getPersistedDebugEnabled();

	  return {
	    onDebugChanged: onDebugChanged,
	    getDebugEnabled: getPersistedDebugEnabled,
	    setDebugEnabled: function (enabled) {
	      if (getPersistedDebugEnabled() !== enabled) {
	        setPersistedDebugEnabled(enabled);
	        logger.outputEnabled = enabled;
	        debugChangedCallbacks.forEach(function (callback) {
	          callback(enabled);
	        });
	      }
	    }
	  };
	};

	/***************************************************************************************
	 * (c) 2018 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	var MODULE_NOT_FUNCTION_ERROR = 'Module did not export a function.';

	var createExecuteDelegateModule = function (
	  moduleProvider,
	  replaceTokens,
	  settingsFileTransformer
	) {
	  return function (moduleDescriptor, syntheticEvent, moduleCallParameters) {
	    moduleCallParameters = moduleCallParameters || [];
	    var moduleExports = moduleProvider.getModuleExports(
	      moduleDescriptor.modulePath
	    );

	    if (typeof moduleExports !== 'function') {
	      throw new Error(MODULE_NOT_FUNCTION_ERROR);
	    }

	    // dynamically replace the host on the module settings
	    var moduleDefinition = moduleProvider.getModuleDefinition(
	      moduleDescriptor.modulePath
	    );

	    // We're transforming URLs in-place to ensure that the developer's settings object reference
	    // is the same object reference as moduleDescriptor.settings. Therefore, we must only transform
	    // the settings one time and save a reference saying that we've done that. We're saving this in
	    // the module descriptor of each event, condition, and action so that we aren't modifying the
	    // settings object.
	    var moduleSettings = moduleDescriptor.settings || {};
	    if (
	      !moduleDescriptor.hasTransformedFilePaths &&
	      moduleDefinition.filePaths
	    ) {
	      settingsFileTransformer(
	        moduleSettings,
	        moduleDefinition.filePaths,
	        moduleDescriptor.modulePath
	      );
	      moduleDescriptor.hasTransformedFilePaths = true;
	    }

	    // replace tokens
	    var moduleDescriptorSettings = replaceTokens(
	      moduleSettings,
	      syntheticEvent
	    );
	    return moduleExports
	      .bind(null, moduleDescriptorSettings)
	      .apply(null, moduleCallParameters);
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * "Cleans" text by trimming the string and removing spaces and newlines.
	 * @param {string} str The string to clean.
	 * @returns {string}
	 */
	var cleanText = function (str) {
	  return typeof str === 'string' ? str.replace(/\s+/g, ' ').trim() : str;
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * Log levels.
	 * @readonly
	 * @enum {string}
	 * @private
	 */
	var levels = {
	  LOG: 'log',
	  INFO: 'info',
	  DEBUG: 'debug',
	  WARN: 'warn',
	  ERROR: 'error'
	};

	/**
	 * Rocket unicode surrogate pair.
	 * @type {string}
	 */
	var ROCKET = '\uD83D\uDE80';

	/**
	 * The user's internet explorer version. If they're not running internet explorer, then it should
	 * be NaN.
	 * @type {Number}
	 */
	var ieVersion = parseInt(
	  (/msie (\d+)/.exec(navigator.userAgent.toLowerCase()) || [])[1]
	);

	/**
	 * Prefix to use on all messages. The rocket unicode doesn't work on IE 10.
	 * @type {string}
	 */
	var launchPrefix = ieVersion === 10 ? '[Launch]' : ROCKET;

	/**
	 * Whether logged messages should be output to the console.
	 * @type {boolean}
	 */
	var outputEnabled = false;

	/**
	 * Processes a log message.
	 * @param {string} level The level of message to log.
	 * @param {...*} arg Any argument to be logged.
	 * @private
	 */
	var process = function (level) {
	  if (outputEnabled && window.console) {
	    var logArguments = Array.prototype.slice.call(arguments, 1);
	    logArguments.unshift(launchPrefix);
	    // window.debug is unsupported in IE 10
	    if (level === levels.DEBUG && !window.console[level]) {
	      level = levels.INFO;
	    }
	    window.console[level].apply(window.console, logArguments);
	  }
	};

	/**
	 * Outputs a message to the web console.
	 * @param {...*} arg Any argument to be logged.
	 */
	var log = process.bind(null, levels.LOG);

	/**
	 * Outputs informational message to the web console. In some browsers a small "i" icon is
	 * displayed next to these items in the web console's log.
	 * @param {...*} arg Any argument to be logged.
	 */
	var info = process.bind(null, levels.INFO);

	/**
	 * Outputs debug message to the web console. In browsers that do not support
	 * console.debug, console.info is used instead.
	 * @param {...*} arg Any argument to be logged.
	 */
	var debug = process.bind(null, levels.DEBUG);

	/**
	 * Outputs a warning message to the web console.
	 * @param {...*} arg Any argument to be logged.
	 */
	var warn = process.bind(null, levels.WARN);

	/**
	 * Outputs an error message to the web console.
	 * @param {...*} arg Any argument to be logged.
	 */
	var error = process.bind(null, levels.ERROR);

	/**
	 * Outputs a warning message to the web console.
	 * @param {...*} arg Any argument to be logged.
	 */
	var logDeprecation = function () {
	  var wasEnabled = outputEnabled;
	  outputEnabled = true;

	  process.apply(
	    null,
	    Array.prototype.concat(levels.WARN, Array.prototype.slice.call(arguments))
	  );

	  if (!wasEnabled) {
	    outputEnabled = false;
	  }
	};

	var logger = {
	  log: log,
	  info: info,
	  debug: debug,
	  warn: warn,
	  error: error,
	  deprecation: logDeprecation,
	  /**
	   * Whether logged messages should be output to the console.
	   * @type {boolean}
	   */
	  get outputEnabled() {
	    return outputEnabled;
	  },
	  set outputEnabled(value) {
	    outputEnabled = value;
	  },
	  /**
	   * Creates a logging utility that only exposes logging functionality and prefixes all messages
	   * with an identifier.
	   */
	  createPrefixedLogger: function (identifier) {
	    var loggerSpecificPrefix = '[' + identifier + ']';

	    return {
	      log: log.bind(null, loggerSpecificPrefix),
	      info: info.bind(null, loggerSpecificPrefix),
	      debug: debug.bind(null, loggerSpecificPrefix),
	      warn: warn.bind(null, loggerSpecificPrefix),
	      error: error.bind(null, loggerSpecificPrefix)
	    };
	  }
	};

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	/*!
	 * JavaScript Cookie v2.2.1
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */

	var js_cookie = createCommonjsModule(function (module, exports) {
	(function (factory) {
		var registeredInModuleLoader;
		{
			module.exports = factory();
			registeredInModuleLoader = true;
		}
		if (!registeredInModuleLoader) {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	}(function () {
		function extend () {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[ i ];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}

		function decode (s) {
			return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
		}

		function init (converter) {
			function api() {}

			function set (key, value, attributes) {
				if (typeof document === 'undefined') {
					return;
				}

				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
				}

				// We're using "expires" because "max-age" is not supported by IE
				attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

				try {
					var result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				value = converter.write ?
					converter.write(value, key) :
					encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

				key = encodeURIComponent(String(key))
					.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
					.replace(/[\(\)]/g, escape);

				var stringifiedAttributes = '';
				for (var attributeName in attributes) {
					if (!attributes[attributeName]) {
						continue;
					}
					stringifiedAttributes += '; ' + attributeName;
					if (attributes[attributeName] === true) {
						continue;
					}

					// Considers RFC 6265 section 5.2:
					// ...
					// 3.  If the remaining unparsed-attributes contains a %x3B (";")
					//     character:
					// Consume the characters of the unparsed-attributes up to,
					// not including, the first %x3B (";") character.
					// ...
					stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
				}

				return (document.cookie = key + '=' + value + stringifiedAttributes);
			}

			function get (key, json) {
				if (typeof document === 'undefined') {
					return;
				}

				var jar = {};
				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all.
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var i = 0;

				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var cookie = parts.slice(1).join('=');

					if (!json && cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}

					try {
						var name = decode(parts[0]);
						cookie = (converter.read || converter)(cookie, name) ||
							decode(cookie);

						if (json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) {}
						}

						jar[name] = cookie;

						if (key === name) {
							break;
						}
					} catch (e) {}
				}

				return key ? jar[key] : jar;
			}

			api.set = set;
			api.get = function (key) {
				return get(key, false /* read as raw */);
			};
			api.getJSON = function (key) {
				return get(key, true /* read as json */);
			};
			api.remove = function (key, attributes) {
				set(key, '', extend(attributes, {
					expires: -1
				}));
			};

			api.defaults = {};

			api.withConverter = init;

			return api;
		}

		return init(function () {});
	}));
	});

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/



	// js-cookie has other methods that we haven't exposed here. By limiting the exposed API,
	// we have a little more flexibility to change the underlying implementation later. If clear
	// use cases come up for needing the other methods js-cookie exposes, we can re-evaluate whether
	// we want to expose them here.
	var reactorCookie = {
	  get: js_cookie.get,
	  set: js_cookie.set,
	  remove: js_cookie.remove
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var NAMESPACE = 'com.adobe.reactor.';

	var getNamespacedStorage = function (storageType, additionalNamespace) {
	  var finalNamespace = NAMESPACE + (additionalNamespace || '');

	  // When storage is disabled on Safari, the mere act of referencing window.localStorage
	  // or window.sessionStorage throws an error. For this reason, we wrap in a try-catch.
	  return {
	    /**
	     * Reads a value from storage.
	     * @param {string} name The name of the item to be read.
	     * @returns {string}
	     */
	    getItem: function (name) {
	      try {
	        return reactorWindow[storageType].getItem(finalNamespace + name);
	      } catch (e) {
	        return null;
	      }
	    },
	    /**
	     * Saves a value to storage.
	     * @param {string} name The name of the item to be saved.
	     * @param {string} value The value of the item to be saved.
	     * @returns {boolean} Whether the item was successfully saved to storage.
	     */
	    setItem: function (name, value) {
	      try {
	        reactorWindow[storageType].setItem(finalNamespace + name, value);
	        return true;
	      } catch (e) {
	        return false;
	      }
	    }
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var COOKIE_PREFIX = '_sdsat_';

	var DATA_ELEMENTS_NAMESPACE = 'dataElements.';
	var MIGRATED_KEY = 'dataElementCookiesMigrated';

	var reactorLocalStorage = getNamespacedStorage('localStorage');
	var dataElementSessionStorage = getNamespacedStorage(
	  'sessionStorage',
	  DATA_ELEMENTS_NAMESPACE
	);
	var dataElementLocalStorage = getNamespacedStorage(
	  'localStorage',
	  DATA_ELEMENTS_NAMESPACE
	);

	var storageDurations = {
	  PAGEVIEW: 'pageview',
	  SESSION: 'session',
	  VISITOR: 'visitor'
	};

	var pageviewCache = {};

	var serialize = function (value) {
	  var serialized;

	  try {
	    // On some browsers, with some objects, errors will be thrown during serialization. For example,
	    // in Chrome with the window object, it will throw "TypeError: Converting circular structure
	    // to JSON"
	    serialized = JSON.stringify(value);
	  } catch (e) {}

	  return serialized;
	};

	var setValue = function (key, storageDuration, value) {
	  var serializedValue;

	  switch (storageDuration) {
	    case storageDurations.PAGEVIEW:
	      pageviewCache[key] = value;
	      return;
	    case storageDurations.SESSION:
	      serializedValue = serialize(value);
	      if (serializedValue) {
	        dataElementSessionStorage.setItem(key, serializedValue);
	      }
	      return;
	    case storageDurations.VISITOR:
	      serializedValue = serialize(value);
	      if (serializedValue) {
	        dataElementLocalStorage.setItem(key, serializedValue);
	      }
	      return;
	  }
	};

	var getValue = function (key, storageDuration) {
	  var value;

	  // It should consistently return the same value if no stored item was found. We chose null,
	  // though undefined could be a reasonable value as well.
	  switch (storageDuration) {
	    case storageDurations.PAGEVIEW:
	      return pageviewCache.hasOwnProperty(key) ? pageviewCache[key] : null;
	    case storageDurations.SESSION:
	      value = dataElementSessionStorage.getItem(key);
	      return value === null ? value : JSON.parse(value);
	    case storageDurations.VISITOR:
	      value = dataElementLocalStorage.getItem(key);
	      return value === null ? value : JSON.parse(value);
	  }
	};

	// Remove when migration period has ended. We intentionally leave cookies as they are so that if
	// DTM is running on the same domain it can still use the persisted values. Our migration strategy
	// is essentially copying data from cookies and then diverging the storage mechanism between
	// DTM and Launch (DTM uses cookies and Launch uses session and local storage).
	var migrateDataElement = function (dataElementName, storageDuration) {
	  var storedValue = reactorCookie.get(COOKIE_PREFIX + dataElementName);

	  if (storedValue !== undefined) {
	    setValue(dataElementName, storageDuration, storedValue);
	  }
	};

	var migrateCookieData = function (dataElements) {
	  if (!reactorLocalStorage.getItem(MIGRATED_KEY)) {
	    Object.keys(dataElements).forEach(function (dataElementName) {
	      migrateDataElement(
	        dataElementName,
	        dataElements[dataElementName].storageDuration
	      );
	    });

	    reactorLocalStorage.setItem(MIGRATED_KEY, true);
	  }
	};

	var dataElementSafe = {
	  setValue: setValue,
	  getValue: getValue,
	  migrateCookieData: migrateCookieData
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var getErrorMessage = function (
	  dataDef,
	  dataElementName,
	  errorMessage,
	  errorStack
	) {
	  return (
	    'Failed to execute data element module ' +
	    dataDef.modulePath +
	    ' for data element ' +
	    dataElementName +
	    '. ' +
	    errorMessage +
	    (errorStack ? '\n' + errorStack : '')
	  );
	};

	var createGetDataElementValue = function (
	  moduleProvider,
	  getDataElementDefinition,
	  replaceTokens,
	  undefinedVarsReturnEmpty,
	  settingsFileTransformer
	) {
	  return function (name, syntheticEvent) {
	    var dataDef = getDataElementDefinition(name);

	    if (!dataDef) {
	      return undefinedVarsReturnEmpty ? '' : undefined;
	    }

	    var storageDuration = dataDef.storageDuration;
	    var moduleExports;
	    var moduleDefinition;

	    try {
	      moduleExports = moduleProvider.getModuleExports(dataDef.modulePath);
	      moduleDefinition = moduleProvider.getModuleDefinition(dataDef.modulePath);
	    } catch (e) {
	      logger.error(getErrorMessage(dataDef, name, e.message, e.stack));
	      return;
	    }

	    if (typeof moduleExports !== 'function') {
	      logger.error(
	        getErrorMessage(dataDef, name, 'Module did not export a function.')
	      );
	      return;
	    }

	    var value;

	    var dataElementSettings = dataDef.settings || {};
	    if (!dataDef.hasTransformedFilePaths && moduleDefinition.filePaths) {
	      settingsFileTransformer(
	        dataElementSettings,
	        moduleDefinition.filePaths,
	        dataDef.modulePath
	      );
	      dataDef.hasTransformedFilePaths = true;
	    }

	    try {
	      value = moduleExports(
	        replaceTokens(dataElementSettings, syntheticEvent),
	        syntheticEvent
	      );
	    } catch (e) {
	      logger.error(getErrorMessage(dataDef, name, e.message, e.stack));
	      return;
	    }

	    if (storageDuration) {
	      if (value != null) {
	        dataElementSafe.setValue(name, storageDuration, value);
	      } else {
	        value = dataElementSafe.getValue(name, storageDuration);
	      }
	    }

	    if (value == null && dataDef.defaultValue != null) {
	      value = dataDef.defaultValue;
	    }

	    if (typeof value === 'string') {
	      if (dataDef.cleanText) {
	        value = cleanText(value);
	      }

	      if (dataDef.forceLowerCase) {
	        value = value.toLowerCase();
	      }
	    }

	    return value;
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var specialPropertyAccessors = {
	  text: function (obj) {
	    return obj.textContent;
	  },
	  cleanText: function (obj) {
	    return cleanText(obj.textContent);
	  }
	};

	/**
	 * This returns the value of a property at a given path. For example, a <code>path<code> of
	 * <code>foo.bar</code> will return the value of <code>obj.foo.bar</code>.
	 *
	 * In addition, if <code>path</code> is <code>foo.bar.getAttribute(unicorn)</code> and
	 * <code>obj.foo.bar</code> has a method named <code>getAttribute</code>, the method will be
	 * called with a value of <code>"unicorn"</code> and the value will be returned.
	 *
	 * Also, if <code>path</code> is <code>foo.bar.@text</code> or other supported properties
	 * beginning with <code>@</code>, a special accessor will be used.
	 *
	 * @param host
	 * @param path
	 * @param supportSpecial
	 * @returns {*}
	 */
	var getObjectProperty = function (host, propChain, supportSpecial) {
	  var value = host;
	  var attrMatch;
	  for (var i = 0, len = propChain.length; i < len; i++) {
	    if (value == null) {
	      return undefined;
	    }
	    var prop = propChain[i];
	    if (supportSpecial && prop.charAt(0) === '@') {
	      var specialProp = prop.slice(1);
	      value = specialPropertyAccessors[specialProp](value);
	      continue;
	    }
	    if (
	      value.getAttribute &&
	      (attrMatch = prop.match(/^getAttribute\((.+)\)$/))
	    ) {
	      var attr = attrMatch[1];
	      value = value.getAttribute(attr);
	      continue;
	    }
	    value = value[prop];
	  }
	  return value;
	};

	/**
	 * Returns the value of a variable.
	 * @param {string} variable
	 * @param {Object} [syntheticEvent] A synthetic event. Only required when using %event... %this...
	 * or %target...
	 * @returns {*}
	 */
	var createGetVar = function (
	  customVars,
	  getDataElementDefinition,
	  getDataElementValue
	) {
	  return function (variable, syntheticEvent) {
	    var value;

	    if (getDataElementDefinition(variable)) {
	      // Accessing nested properties of a data element using dot-notation is unsupported because
	      // users can currently create data elements with periods in the name.
	      value = getDataElementValue(variable, syntheticEvent);
	    } else {
	      var propChain = variable.split('.');
	      var variableHostName = propChain.shift();

	      if (variableHostName === 'this') {
	        if (syntheticEvent) {
	          // I don't know why this is the only one that supports special properties, but that's the
	          // way it was in Satellite.
	          value = getObjectProperty(syntheticEvent.element, propChain, true);
	        }
	      } else if (variableHostName === 'event') {
	        if (syntheticEvent) {
	          value = getObjectProperty(syntheticEvent, propChain);
	        }
	      } else if (variableHostName === 'target') {
	        if (syntheticEvent) {
	          value = getObjectProperty(syntheticEvent.target, propChain);
	        }
	      } else {
	        value = getObjectProperty(customVars[variableHostName], propChain);
	      }
	    }

	    return value;
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * Determines if the provided name is a valid variable, where the variable
	 * can be a data element, element, event, target, or custom var.
	 * @param variableName
	 * @returns {boolean}
	 */
	var createIsVar = function (customVars, getDataElementDefinition) {
	  return function (variableName) {
	    var nameBeforeDot = variableName.split('.')[0];

	    return Boolean(
	      getDataElementDefinition(variableName) ||
	        nameBeforeDot === 'this' ||
	        nameBeforeDot === 'event' ||
	        nameBeforeDot === 'target' ||
	        customVars.hasOwnProperty(nameBeforeDot)
	    );
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	var extractModuleExports = function (script, require, turbine) {
	  var module = {
	    exports: {}
	  };

	  script.call(module.exports, module, module.exports, require, turbine);

	  return module.exports;
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var createModuleProvider = function () {
	  var moduleByReferencePath = {};

	  var getModule = function (referencePath) {
	    var module = moduleByReferencePath[referencePath];

	    if (!module) {
	      throw new Error('Module ' + referencePath + ' not found.');
	    }

	    return module;
	  };

	  var registerModule = function (
	    referencePath,
	    moduleDefinition,
	    extensionName,
	    require,
	    turbine
	  ) {
	    var module = {
	      definition: moduleDefinition,
	      extensionName: extensionName,
	      require: require,
	      turbine: turbine
	    };
	    module.require = require;
	    moduleByReferencePath[referencePath] = module;
	  };

	  var hydrateCache = function () {
	    Object.keys(moduleByReferencePath).forEach(function (referencePath) {
	      try {
	        getModuleExports(referencePath);
	      } catch (e) {
	        var errorMessage =
	          'Error initializing module ' +
	          referencePath +
	          '. ' +
	          e.message +
	          (e.stack ? '\n' + e.stack : '');
	        logger.error(errorMessage);
	      }
	    });
	  };

	  var getModuleExports = function (referencePath) {
	    var module = getModule(referencePath);

	    // Using hasOwnProperty instead of a falsey check because the module could export undefined
	    // in which case we don't want to execute the module each time the exports is requested.
	    if (!module.hasOwnProperty('exports')) {
	      module.exports = extractModuleExports(
	        module.definition.script,
	        module.require,
	        module.turbine
	      );
	    }

	    return module.exports;
	  };

	  var getModuleDefinition = function (referencePath) {
	    return getModule(referencePath).definition;
	  };

	  var getModuleExtensionName = function (referencePath) {
	    return getModule(referencePath).extensionName;
	  };

	  return {
	    registerModule: registerModule,
	    hydrateCache: hydrateCache,
	    getModuleExports: getModuleExports,
	    getModuleDefinition: getModuleDefinition,
	    getModuleExtensionName: getModuleExtensionName
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var warningLogged = false;

	var createNotifyMonitors = function (_satellite) {
	  return function (type, event) {
	    var monitors = _satellite._monitors;

	    if (monitors) {
	      if (!warningLogged) {
	        logger.warn(
	          'The _satellite._monitors API may change at any time and should only ' +
	            'be used for debugging.'
	        );
	        warningLogged = true;
	      }

	      monitors.forEach(function (monitor) {
	        if (monitor[type]) {
	          monitor[type](event);
	        }
	      });
	    }
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	/**
	 * Replacing any variable tokens (%myDataElement%, %this.foo%, etc.) with their associated values.
	 * A new string, object, or array will be created; the thing being processed will never be
	 * modified.
	 * @param {*} thing Thing potentially containing variable tokens. Objects and arrays will be
	 * deeply processed.
	 * @param {HTMLElement} [element] Associated HTML element. Used for special tokens
	 * (%this.something%).
	 * @param {Object} [event] Associated event. Used for special tokens (%event.something%,
	 * %target.something%)
	 * @returns {*} A processed value.
	 */
	var createReplaceTokens = function (isVar, getVar, undefinedVarsReturnEmpty) {
	  var replaceTokensInString;
	  var replaceTokensInObject;
	  var replaceTokensInArray;
	  var replaceTokens;
	  var variablesBeingRetrieved = [];

	  var getVarValue = function (token, variableName, syntheticEvent) {
	    if (!isVar(variableName)) {
	      return token;
	    }

	    variablesBeingRetrieved.push(variableName);
	    var val = getVar(variableName, syntheticEvent);
	    variablesBeingRetrieved.pop();
	    return val == null && undefinedVarsReturnEmpty ? '' : val;
	  };

	  /**
	   * Perform variable substitutions to a string where tokens are specified in the form %foo%.
	   * If the only content of the string is a single data element token, then the raw data element
	   * value will be returned instead.
	   *
	   * @param str {string} The string potentially containing data element tokens.
	   * @param element {HTMLElement} The element to use for tokens in the form of %this.property%.
	   * @param event {Object} The event object to use for tokens in the form of %target.property%.
	   * @returns {*}
	   */
	  replaceTokensInString = function (str, syntheticEvent) {
	    // Is the string a single data element token and nothing else?
	    var result = /^%([^%]+)%$/.exec(str);

	    if (result) {
	      return getVarValue(str, result[1], syntheticEvent);
	    } else {
	      return str.replace(/%(.+?)%/g, function (token, variableName) {
	        return getVarValue(token, variableName, syntheticEvent);
	      });
	    }
	  };

	  replaceTokensInObject = function (obj, syntheticEvent) {
	    var ret = {};
	    var keys = Object.keys(obj);
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      ret[key] = replaceTokens(value, syntheticEvent);
	    }
	    return ret;
	  };

	  replaceTokensInArray = function (arr, syntheticEvent) {
	    var ret = [];
	    for (var i = 0, len = arr.length; i < len; i++) {
	      ret.push(replaceTokens(arr[i], syntheticEvent));
	    }
	    return ret;
	  };

	  replaceTokens = function (thing, syntheticEvent) {
	    if (typeof thing === 'string') {
	      return replaceTokensInString(thing, syntheticEvent);
	    } else if (Array.isArray(thing)) {
	      return replaceTokensInArray(thing, syntheticEvent);
	    } else if (typeof thing === 'object' && thing !== null) {
	      return replaceTokensInObject(thing, syntheticEvent);
	    }

	    return thing;
	  };

	  return function (thing, syntheticEvent) {
	    // It's possible for a data element to reference another data element. Because of this,
	    // we need to prevent circular dependencies from causing an infinite loop.
	    if (variablesBeingRetrieved.length > 10) {
	      logger.error(
	        'Data element circular reference detected: ' +
	          variablesBeingRetrieved.join(' -> ')
	      );
	      return thing;
	    }

	    return replaceTokens(thing, syntheticEvent);
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	var createSetCustomVar = function (customVars) {
	  return function () {
	    if (typeof arguments[0] === 'string') {
	      customVars[arguments[0]] = arguments[1];
	    } else if (arguments[0]) {
	      // assume an object literal
	      var mapping = arguments[0];
	      for (var key in mapping) {
	        customVars[key] = mapping[key];
	      }
	    }
	  };
	};

	/**
	 * @this {Promise}
	 */
	function finallyConstructor(callback) {
	  var constructor = this.constructor;
	  return this.then(
	    function(value) {
	      // @ts-ignore
	      return constructor.resolve(callback()).then(function() {
	        return value;
	      });
	    },
	    function(reason) {
	      // @ts-ignore
	      return constructor.resolve(callback()).then(function() {
	        // @ts-ignore
	        return constructor.reject(reason);
	      });
	    }
	  );
	}

	// Store setTimeout reference so promise-polyfill will be unaffected by
	// other code modifying setTimeout (like sinon.useFakeTimers())
	var setTimeoutFunc = setTimeout;

	function isArray(x) {
	  return Boolean(x && typeof x.length !== 'undefined');
	}

	function noop() {}

	// Polyfill for Function.prototype.bind
	function bind(fn, thisArg) {
	  return function() {
	    fn.apply(thisArg, arguments);
	  };
	}

	/**
	 * @constructor
	 * @param {Function} fn
	 */
	function Promise(fn) {
	  if (!(this instanceof Promise))
	    throw new TypeError('Promises must be constructed via new');
	  if (typeof fn !== 'function') throw new TypeError('not a function');
	  /** @type {!number} */
	  this._state = 0;
	  /** @type {!boolean} */
	  this._handled = false;
	  /** @type {Promise|undefined} */
	  this._value = undefined;
	  /** @type {!Array<!Function>} */
	  this._deferreds = [];

	  doResolve(fn, this);
	}

	function handle(self, deferred) {
	  while (self._state === 3) {
	    self = self._value;
	  }
	  if (self._state === 0) {
	    self._deferreds.push(deferred);
	    return;
	  }
	  self._handled = true;
	  Promise._immediateFn(function() {
	    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	      return;
	    }
	    var ret;
	    try {
	      ret = cb(self._value);
	    } catch (e) {
	      reject(deferred.promise, e);
	      return;
	    }
	    resolve(deferred.promise, ret);
	  });
	}

	function resolve(self, newValue) {
	  try {
	    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	    if (newValue === self)
	      throw new TypeError('A promise cannot be resolved with itself.');
	    if (
	      newValue &&
	      (typeof newValue === 'object' || typeof newValue === 'function')
	    ) {
	      var then = newValue.then;
	      if (newValue instanceof Promise) {
	        self._state = 3;
	        self._value = newValue;
	        finale(self);
	        return;
	      } else if (typeof then === 'function') {
	        doResolve(bind(then, newValue), self);
	        return;
	      }
	    }
	    self._state = 1;
	    self._value = newValue;
	    finale(self);
	  } catch (e) {
	    reject(self, e);
	  }
	}

	function reject(self, newValue) {
	  self._state = 2;
	  self._value = newValue;
	  finale(self);
	}

	function finale(self) {
	  if (self._state === 2 && self._deferreds.length === 0) {
	    Promise._immediateFn(function() {
	      if (!self._handled) {
	        Promise._unhandledRejectionFn(self._value);
	      }
	    });
	  }

	  for (var i = 0, len = self._deferreds.length; i < len; i++) {
	    handle(self, self._deferreds[i]);
	  }
	  self._deferreds = null;
	}

	/**
	 * @constructor
	 */
	function Handler(onFulfilled, onRejected, promise) {
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, self) {
	  var done = false;
	  try {
	    fn(
	      function(value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      },
	      function(reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      }
	    );
	  } catch (ex) {
	    if (done) return;
	    done = true;
	    reject(self, ex);
	  }
	}

	Promise.prototype['catch'] = function(onRejected) {
	  return this.then(null, onRejected);
	};

	Promise.prototype.then = function(onFulfilled, onRejected) {
	  // @ts-ignore
	  var prom = new this.constructor(noop);

	  handle(this, new Handler(onFulfilled, onRejected, prom));
	  return prom;
	};

	Promise.prototype['finally'] = finallyConstructor;

	Promise.all = function(arr) {
	  return new Promise(function(resolve, reject) {
	    if (!isArray(arr)) {
	      return reject(new TypeError('Promise.all accepts an array'));
	    }

	    var args = Array.prototype.slice.call(arr);
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;

	    function res(i, val) {
	      try {
	        if (val && (typeof val === 'object' || typeof val === 'function')) {
	          var then = val.then;
	          if (typeof then === 'function') {
	            then.call(
	              val,
	              function(val) {
	                res(i, val);
	              },
	              reject
	            );
	            return;
	          }
	        }
	        args[i] = val;
	        if (--remaining === 0) {
	          resolve(args);
	        }
	      } catch (ex) {
	        reject(ex);
	      }
	    }

	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};

	Promise.resolve = function(value) {
	  if (value && typeof value === 'object' && value.constructor === Promise) {
	    return value;
	  }

	  return new Promise(function(resolve) {
	    resolve(value);
	  });
	};

	Promise.reject = function(value) {
	  return new Promise(function(resolve, reject) {
	    reject(value);
	  });
	};

	Promise.race = function(arr) {
	  return new Promise(function(resolve, reject) {
	    if (!isArray(arr)) {
	      return reject(new TypeError('Promise.race accepts an array'));
	    }

	    for (var i = 0, len = arr.length; i < len; i++) {
	      Promise.resolve(arr[i]).then(resolve, reject);
	    }
	  });
	};

	// Use polyfill for setImmediate for performance gains
	Promise._immediateFn =
	  // @ts-ignore
	  (typeof setImmediate === 'function' &&
	    function(fn) {
	      // @ts-ignore
	      setImmediate(fn);
	    }) ||
	  function(fn) {
	    setTimeoutFunc(fn, 0);
	  };

	Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	  if (typeof console !== 'undefined' && console) {
	    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	  }
	};

	var src = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': Promise
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(src);

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	// For building Turbine we are using Rollup. For running the turbine tests we are using
	// Karma + Webpack. You need to specify the default import when using promise-polyfill`
	// with Webpack 2+. We need `require('promise-polyfill').default` for running the tests
	// and `require('promise-polyfill')` for building Turbine.
	var reactorPromise =
	  (typeof window !== 'undefined' && window.Promise) ||
	  (typeof commonjsGlobal !== 'undefined' && commonjsGlobal.Promise) ||
	  require$$0.default ||
	  require$$0;

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/

	var createAddActionToQueue = function (
	  executeDelegateModule,
	  normalizeRuleComponentError,
	  logActionError
	) {
	  return function (action, rule, syntheticEvent, lastPromiseInQueue) {
	    return lastPromiseInQueue.then(function () {
	      // This module is used when ruleComponentSequencing is enabled.
	      // action.timeout is always supplied to this module as >= 0 when delayNext is true.

	      var delayNextAction = action.delayNext;
	      var actionTimeoutId;

	      return new reactorPromise(function (resolve, reject) {
	        var moduleResult = executeDelegateModule(action, syntheticEvent, [
	          syntheticEvent
	        ]);

	        if (!delayNextAction) {
	          return resolve();
	        }

	        var promiseTimeoutMs = action.timeout;
	        var timeoutPromise = new reactorPromise(function (resolve, reject) {
	          actionTimeoutId = setTimeout(function () {
	            reject(
	              new Error(
	                'A timeout occurred because the action took longer than ' +
	                  promiseTimeoutMs / 1000 +
	                  ' seconds to complete. '
	              )
	            );
	          }, promiseTimeoutMs);
	        });

	        reactorPromise.race([moduleResult, timeoutPromise]).then(resolve, reject);
	      })
	        .catch(function (e) {
	          clearTimeout(actionTimeoutId);
	          e = normalizeRuleComponentError(e);
	          logActionError(action, rule, e);
	          return reactorPromise.reject(e);
	        })
	        .then(function () {
	          clearTimeout(actionTimeoutId);
	        });
	    });
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/

	var createAddConditionToQueue = function (
	  executeDelegateModule,
	  normalizeRuleComponentError,
	  isConditionMet,
	  logConditionError,
	  logConditionNotMet
	) {
	  return function (condition, rule, syntheticEvent, lastPromiseInQueue) {
	    return lastPromiseInQueue.then(function () {
	      // This module is used when ruleComponentSequencing is enabled.
	      // condition.timeout is always supplied to this module as >= 0.
	      // Conditions always assume delayNext = true because we have to know the
	      // condition result before moving on.
	      var conditionTimeoutId;

	      return new reactorPromise(function (resolve, reject) {
	        var moduleResult = executeDelegateModule(condition, syntheticEvent, [
	          syntheticEvent
	        ]);

	        var promiseTimeoutMs = condition.timeout;
	        var timeoutPromise = new reactorPromise(function (resolve, reject) {
	          conditionTimeoutId = setTimeout(function () {
	            reject(
	              new Error(
	                'A timeout occurred because the condition took longer than ' +
	                  promiseTimeoutMs / 1000 +
	                  ' seconds to complete. '
	              )
	            );
	          }, promiseTimeoutMs);
	        });

	        reactorPromise.race([moduleResult, timeoutPromise]).then(resolve, reject);
	      })
	        .catch(function (e) {
	          clearTimeout(conditionTimeoutId);
	          e = normalizeRuleComponentError(e);
	          logConditionError(condition, rule, e);
	          return reactorPromise.reject(e);
	        })
	        .then(function (result) {
	          clearTimeout(conditionTimeoutId);
	          if (!isConditionMet(condition, result)) {
	            logConditionNotMet(condition, rule);
	            return reactorPromise.reject();
	          }
	        });
	    });
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/

	var lastPromiseInQueue = reactorPromise.resolve();

	var createAddRuleToQueue = function (
	  addConditionToQueue,
	  addActionToQueue,
	  logRuleCompleted
	) {
	  return function (rule, syntheticEvent) {
	    if (rule.conditions) {
	      rule.conditions.forEach(function (condition) {
	        lastPromiseInQueue = addConditionToQueue(
	          condition,
	          rule,
	          syntheticEvent,
	          lastPromiseInQueue
	        );
	      });
	    }

	    if (rule.actions) {
	      rule.actions.forEach(function (action) {
	        lastPromiseInQueue = addActionToQueue(
	          action,
	          rule,
	          syntheticEvent,
	          lastPromiseInQueue
	        );
	      });
	    }

	    lastPromiseInQueue = lastPromiseInQueue.then(function () {
	      logRuleCompleted(rule);
	    });

	    // Allows later rules to keep running when an error occurs within this rule.
	    lastPromiseInQueue = lastPromiseInQueue.catch(function () {});

	    return lastPromiseInQueue;
	  };
	};

	var isPromiseLike = function (value) {
	  return Boolean(
	    value && typeof value === 'object' && typeof value.then === 'function'
	  );
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/

	var createEvaluateConditions = function (
	  executeDelegateModule,
	  isConditionMet,
	  logConditionNotMet,
	  logConditionError
	) {
	  return function (rule, syntheticEvent) {
	    var condition;

	    if (rule.conditions) {
	      for (var i = 0; i < rule.conditions.length; i++) {
	        condition = rule.conditions[i];

	        try {
	          var result = executeDelegateModule(condition, syntheticEvent, [
	            syntheticEvent
	          ]);

	          // If the result is promise-like, the extension needs to do something asynchronously,
	          // but the customer does not have rule component sequencing enabled on the property.
	          // If we didn't do this, the condition would always pass because the promise is
	          // considered "truthy".
	          if (isPromiseLike(result)) {
	            throw new Error(
	              'Rule component sequencing must be enabled on the property ' +
	                'for this condition to function properly.'
	            );
	          }

	          if (!isConditionMet(condition, result)) {
	            logConditionNotMet(condition, rule);
	            return false;
	          }
	        } catch (e) {
	          logConditionError(condition, rule, e);
	          return false;
	        }
	      }
	    }

	    return true;
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createExecuteRule = function (evaluateConditions, runActions) {
	  return function (rule, normalizedSyntheticEvent) {
	    if (evaluateConditions(rule, normalizedSyntheticEvent)) {
	      runActions(rule, normalizedSyntheticEvent);
	    }
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createGetModuleDisplayNameByRuleComponent = function (moduleProvider) {
	  return function (ruleComponent) {
	    var moduleDefinition = moduleProvider.getModuleDefinition(
	      ruleComponent.modulePath
	    );
	    return (
	      (moduleDefinition && moduleDefinition.displayName) ||
	      ruleComponent.modulePath
	    );
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createGetSyntheticEventMeta = function (moduleProvider) {
	  return function (ruleEventPair) {
	    var rule = ruleEventPair.rule;
	    var event = ruleEventPair.event;

	    var moduleName = moduleProvider.getModuleDefinition(event.modulePath).name;
	    var extensionName = moduleProvider.getModuleExtensionName(event.modulePath);

	    return {
	      $type: extensionName + '.' + moduleName,
	      $rule: {
	        id: rule.id,
	        name: rule.name
	      }
	    };
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createInitEventModule = function (
	  triggerRule,
	  executeDelegateModule,
	  normalizeSyntheticEvent,
	  getErrorMessage,
	  getSyntheticEventMeta,
	  logger
	) {
	  return function (guardUntilAllInitialized, ruleEventPair) {
	    var rule = ruleEventPair.rule;
	    var event = ruleEventPair.event;
	    event.settings = event.settings || {};

	    try {
	      var syntheticEventMeta = getSyntheticEventMeta(ruleEventPair);

	      executeDelegateModule(event, null, [
	        /**
	         * This is the callback that executes a particular rule when an event has occurred.
	         * @param {Object} [syntheticEvent] An object that contains detail regarding the event
	         * that occurred.
	         */
	        function trigger(syntheticEvent) {
	          // DTM-11871
	          // If we're still in the process of initializing event modules,
	          // we need to queue up any calls to trigger, otherwise if the triggered
	          // rule does something that triggers a different rule whose event module
	          // has not been initialized, that secondary rule will never get executed.
	          // This can be removed if we decide to always use the rule queue, since
	          // conditions and actions will be processed asynchronously, which
	          // would give time for all event modules to be initialized.

	          var normalizedSyntheticEvent = normalizeSyntheticEvent(
	            syntheticEventMeta,
	            syntheticEvent
	          );

	          guardUntilAllInitialized(function () {
	            triggerRule(normalizedSyntheticEvent, rule);
	          });
	        }
	      ]);
	    } catch (e) {
	      logger.error(getErrorMessage(event, rule, e));
	    }
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createLogActionError = function (
	  getRuleComponentErrorMessage,
	  getModuleDisplayNameByRuleComponent,
	  logger,
	  notifyMonitors
	) {
	  return function (action, rule, e) {
	    var actionDisplayName = getModuleDisplayNameByRuleComponent(action);

	    logger.error(getRuleComponentErrorMessage(actionDisplayName, rule.name, e));

	    notifyMonitors('ruleActionFailed', {
	      rule: rule,
	      action: action
	    });
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createLogConditionError = function (
	  getRuleComponentErrorMessage,
	  getModuleDisplayNameByRuleComponent,
	  logger,
	  notifyMonitors
	) {
	  return function (condition, rule, e) {
	    var conditionDisplayName = getModuleDisplayNameByRuleComponent(condition);

	    logger.error(
	      getRuleComponentErrorMessage(conditionDisplayName, rule.name, e)
	    );

	    notifyMonitors('ruleConditionFailed', {
	      rule: rule,
	      condition: condition
	    });
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createLogConditionNotMet = function (
	  getModuleDisplayNameByRuleComponent,
	  logger,
	  notifyMonitors
	) {
	  return function (condition, rule) {
	    var conditionDisplayName = getModuleDisplayNameByRuleComponent(condition);

	    logger.log(
	      'Condition "' +
	        conditionDisplayName +
	        '" for rule "' +
	        rule.name +
	        '" was not met.'
	    );

	    notifyMonitors('ruleConditionFailed', {
	      rule: rule,
	      condition: condition
	    });
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createLogRuleCompleted = function (logger, notifyMonitors) {
	  return function (rule) {
	    logger.log('Rule "' + rule.name + '" fired.');
	    notifyMonitors('ruleCompleted', {
	      rule: rule
	    });
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createRunActions = function (
	  executeDelegateModule,
	  logActionError,
	  logRuleCompleted
	) {
	  return function (rule, syntheticEvent) {
	    var action;

	    if (rule.actions) {
	      for (var i = 0; i < rule.actions.length; i++) {
	        action = rule.actions[i];
	        try {
	          executeDelegateModule(action, syntheticEvent, [syntheticEvent]);
	        } catch (e) {
	          logActionError(action, rule, e);
	          return;
	        }
	      }
	    }

	    logRuleCompleted(rule);
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var createTriggerRule = function (
	  ruleComponentSequencingEnabled,
	  executeRule,
	  addRuleToQueue,
	  notifyMonitors
	) {
	  return function (normalizedSyntheticEvent, rule) {
	    notifyMonitors('ruleTriggered', {
	      rule: rule
	    });

	    if (ruleComponentSequencingEnabled) {
	      addRuleToQueue(rule, normalizedSyntheticEvent);
	    } else {
	      executeRule(rule, normalizedSyntheticEvent);
	    }
	  };
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var getRuleComponentErrorMessage = function (ruleComponentName, ruleName, error) {
	  return (
	    'Failed to execute "' +
	    ruleComponentName +
	    '" for "' +
	    ruleName +
	    '" rule. ' +
	    error.message +
	    (error.stack ? '\n' + error.stack : '')
	  );
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var isConditionMet = function (condition, result) {
	  return (result && !condition.negate) || (!result && condition.negate);
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var triggerCallQueue = [];
	var eventModulesInitialized = false;

	var guardUntilAllInitialized = function (callback) {
	  if (!eventModulesInitialized) {
	    triggerCallQueue.push(callback);
	  } else {
	    callback();
	  }
	};

	var initRules = function (buildRuleExecutionOrder, rules, initEventModule) {
	  buildRuleExecutionOrder(rules).forEach(function (ruleEventPair) {
	    initEventModule(guardUntilAllInitialized, ruleEventPair);
	  });

	  eventModulesInitialized = true;
	  triggerCallQueue.forEach(function (triggerCall) {
	    triggerCall();
	  });

	  triggerCallQueue = [];
	};

	/*
	Copyright 2020 Adobe. All rights reserved.
	This file is licensed to you under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License. You may obtain a copy
	of the License at http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed under
	the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	OF ANY KIND, either express or implied. See the License for the specific language
	governing permissions and limitations under the License.
	*/
	var normalizeRuleComponentError = function (e) {
	  if (!e) {
	    e = new Error(
	      'The extension triggered an error, but no error information was provided.'
	    );
	  }

	  if (!(e instanceof Error)) {
	    var stringifiedError =
	      typeof e === 'object' ? JSON.stringify(e) : String(e);
	    e = new Error(stringifiedError);
	  }

	  return e;
	};

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */

	var isobject = function isObject(val) {
	  return val != null && typeof val === 'object' && Array.isArray(val) === false;
	};

	/*!
	 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */



	function isObjectObject(o) {
	  return isobject(o) === true
	    && Object.prototype.toString.call(o) === '[object Object]';
	}

	var isPlainObject = function isPlainObject(o) {
	  var ctor,prot;

	  if (isObjectObject(o) === false) return false;

	  // If has modified constructor
	  ctor = o.constructor;
	  if (typeof ctor !== 'function') return false;

	  // If has modified prototype
	  prot = ctor.prototype;
	  if (isObjectObject(prot) === false) return false;

	  // If constructor does not have an Object-specific method
	  if (prot.hasOwnProperty('isPrototypeOf') === false) {
	    return false;
	  }

	  // Most likely a plain Object
	  return true;
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	/**
	 * Normalizes a synthetic event so that it exists and has at least meta.
	 * @param {Object} syntheticEventMeta
	 * @param {Object} [syntheticEvent]
	 * @returns {Object}
	 */
	var normalizeSyntheticEvent = function (syntheticEventMeta, syntheticEvent) {
	  syntheticEvent = syntheticEvent || {};

	  // This ensures that as the user hands us a synthetic event for multiple rules,
	  // we aren't overwriting a new meta into the same object reference.
	  if (isPlainObject(syntheticEvent)) {
	    syntheticEvent = reactorObjectAssign({}, syntheticEvent, syntheticEventMeta);
	  } else {
	    // When syntheticEvent is not an object, there's nothing we can guarantee
	    // about the ability to "copy". Leave it alone.
	    reactorObjectAssign(syntheticEvent, syntheticEventMeta);
	  }

	  // Remove after some arbitrary time period when we think users have had sufficient chance
	  // to move away from event.type
	  if (!syntheticEvent.hasOwnProperty('type')) {
	    Object.defineProperty(syntheticEvent, 'type', {
	      get: function () {
	        logger.deprecation(
	          'Accessing event.type in Adobe Launch has been deprecated and will be ' +
	            'removed soon. Please use event.$type instead.'
	        );
	        return syntheticEvent.$type;
	      }
	    });
	  }

	  return syntheticEvent;
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * Creates a function that, when called with an extension name and module name, will return the
	 * exports of the respective shared module.
	 *
	 * @param {Object} extensions
	 * @param {Object} moduleProvider
	 * @returns {Function}
	 */
	var createGetSharedModuleExports = function (extensions, moduleProvider) {
	  return function (extensionName, moduleName) {
	    var extension = extensions[extensionName];

	    if (extension) {
	      var modules = extension.modules;
	      if (modules) {
	        var referencePaths = Object.keys(modules);
	        for (var i = 0; i < referencePaths.length; i++) {
	          var referencePath = referencePaths[i];
	          var module = modules[referencePath];
	          if (module.shared && module.name === moduleName) {
	            return moduleProvider.getModuleExports(referencePath);
	          }
	        }
	      }
	    }
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * Creates a function that, when called, will return a configuration object with data element
	 * tokens replaced.
	 *
	 * @param {Object} settings
	 * @returns {Function}
	 */
	var createGetExtensionSettings = function (replaceTokens, settings) {
	  return function () {
	    return settings ? replaceTokens(settings) : {};
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	/**
	 * Creates a function that, when called, will return the full hosted lib file URL.
	 *
	 * @param {string} hostedLibFilesBaseUrl
	 * @returns {Function}
	 */

	var createGetHostedLibFileUrl = function (
	  decorateWithDynamicHost,
	  hostedLibFilesBaseUrl,
	  minified
	) {
	  return function (file) {
	    if (minified) {
	      var fileParts = file.split('.');
	      fileParts.splice(fileParts.length - 1 || 1, 0, 'min');
	      file = fileParts.join('.');
	    }

	    return decorateWithDynamicHost(hostedLibFilesBaseUrl) + file;
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/
	var JS_EXTENSION = '.js';

	/**
	 * @private
	 * Returns the directory of a path. A limited version of path.dirname in nodejs.
	 *
	 * To keep it simple, it makes the following assumptions:
	 * path has a least one slash
	 * path does not end with a slash
	 * path does not have empty segments (e.g., /src/lib//foo.bar)
	 *
	 * @param {string} path
	 * @returns {string}
	 */
	var dirname = function (path) {
	  return path.substr(0, path.lastIndexOf('/'));
	};

	/**
	 * Determines if a string ends with a certain string.
	 * @param {string} str The string to test.
	 * @param {string} suffix The suffix to look for at the end of str.
	 * @returns {boolean} Whether str ends in suffix.
	 */
	var endsWith = function (str, suffix) {
	  return str.indexOf(suffix, str.length - suffix.length) !== -1;
	};

	/**
	 * Given a starting path and a path relative to the starting path, returns the final path. A
	 * limited version of path.resolve in nodejs.
	 *
	 * To keep it simple, it makes the following assumptions:
	 * fromPath has at least one slash
	 * fromPath does not end with a slash.
	 * fromPath does not have empty segments (e.g., /src/lib//foo.bar)
	 * relativePath starts with ./ or ../
	 *
	 * @param {string} fromPath
	 * @param {string} relativePath
	 * @returns {string}
	 */
	var resolveRelativePath = function (fromPath, relativePath) {
	  // Handle the case where the relative path does not end in the .js extension. We auto-append it.
	  if (!endsWith(relativePath, JS_EXTENSION)) {
	    relativePath = relativePath + JS_EXTENSION;
	  }

	  var relativePathSegments = relativePath.split('/');
	  var resolvedPathSegments = dirname(fromPath).split('/');

	  relativePathSegments.forEach(function (relativePathSegment) {
	    if (!relativePathSegment || relativePathSegment === '.') {
	      return;
	    } else if (relativePathSegment === '..') {
	      if (resolvedPathSegments.length) {
	        resolvedPathSegments.pop();
	      }
	    } else {
	      resolvedPathSegments.push(relativePathSegment);
	    }
	  });

	  return resolvedPathSegments.join('/');
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/



	var getPromise = function(url, script) {
	  return new reactorPromise(function(resolve, reject) {
	    script.onload = function() {
	      resolve(script);
	    };

	    script.onerror = function() {
	      reject(new Error('Failed to load script ' + url));
	    };
	  });
	};

	var reactorLoadScript = function(url) {
	  var script = document.createElement('script');
	  script.src = url;
	  script.async = true;

	  var promise = getPromise(url, script);

	  document.getElementsByTagName('head')[0].appendChild(script);
	  return promise;
	};

	// Copyright Joyent, Inc. and other Node contributors.

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty$1(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var decode = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty$1(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};

	// Copyright Joyent, Inc. and other Node contributors.

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	var encode = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};

	var querystring = createCommonjsModule(function (module, exports) {

	exports.decode = exports.parse = decode;
	exports.encode = exports.stringify = encode;
	});

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/



	// We proxy the underlying querystring module so we can limit the API we expose.
	// This allows us to more easily make changes to the underlying implementation later without
	// having to worry about breaking extensions. If extensions demand additional functionality, we
	// can make adjustments as needed.
	var reactorQueryString = {
	  parse: function(string) {
	    //
	    if (typeof string === 'string') {
	      // Remove leading ?, #, & for some leniency so you can pass in location.search or
	      // location.hash directly.
	      string = string.trim().replace(/^[?#&]/, '');
	    }
	    return querystring.parse(string);
	  },
	  stringify: function(object) {
	    return querystring.stringify(object);
	  }
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var CORE_MODULE_PREFIX = '@adobe/reactor-';

	var modules = {
	  cookie: reactorCookie,
	  document: reactorDocument,
	  'load-script': reactorLoadScript,
	  'object-assign': reactorObjectAssign,
	  promise: reactorPromise,
	  'query-string': reactorQueryString,
	  window: reactorWindow
	};

	/**
	 * Creates a function which can be passed as a "require" function to extension modules.
	 *
	 * @param {Function} getModuleExportsByRelativePath
	 * @returns {Function}
	 */
	var createPublicRequire = function (getModuleExportsByRelativePath) {
	  return function (key) {
	    if (key.indexOf(CORE_MODULE_PREFIX) === 0) {
	      var keyWithoutScope = key.substr(CORE_MODULE_PREFIX.length);
	      var module = modules[keyWithoutScope];

	      if (module) {
	        return module;
	      }
	    }

	    if (key.indexOf('./') === 0 || key.indexOf('../') === 0) {
	      return getModuleExportsByRelativePath(key);
	    }

	    throw new Error('Cannot resolve module "' + key + '".');
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var hydrateModuleProvider = function (
	  container,
	  moduleProvider,
	  debugController,
	  replaceTokens,
	  getDataElementValue,
	  settingsFileTransformer,
	  decorateWithDynamicHost
	) {
	  var extensions = container.extensions;
	  var buildInfo = container.buildInfo;
	  var environment = container.environment;
	  var propertySettings = container.property.settings;

	  if (extensions) {
	    var getSharedModuleExports = createGetSharedModuleExports(
	      extensions,
	      moduleProvider
	    );

	    Object.keys(extensions).forEach(function (extensionName) {
	      var extension = extensions[extensionName];
	      var extensionSettings = extension.settings;
	      if (Array.isArray(extension.filePaths)) {
	        extensionSettings = settingsFileTransformer(
	          extensionSettings,
	          extension.filePaths
	        );
	      }
	      var getExtensionSettings = createGetExtensionSettings(
	        replaceTokens,
	        extensionSettings
	      );

	      if (extension.modules) {
	        var prefixedLogger = logger.createPrefixedLogger(extension.displayName);
	        var getHostedLibFileUrl = createGetHostedLibFileUrl(
	          decorateWithDynamicHost,
	          extension.hostedLibFilesBaseUrl,
	          buildInfo.minified
	        );
	        var turbine = {
	          buildInfo: buildInfo,
	          environment: environment,
	          property: {
	            name: container.property.name,
	            id: container.property.id
	          },
	          getDataElementValue: getDataElementValue,
	          getExtensionSettings: getExtensionSettings,
	          getHostedLibFileUrl: getHostedLibFileUrl,
	          getSharedModule: getSharedModuleExports,
	          logger: prefixedLogger,
	          propertySettings: propertySettings,
	          replaceTokens: replaceTokens,
	          onDebugChanged: debugController.onDebugChanged,
	          get debugEnabled() {
	            return debugController.getDebugEnabled();
	          }
	        };

	        Object.keys(extension.modules).forEach(function (referencePath) {
	          var module = extension.modules[referencePath];
	          var getModuleExportsByRelativePath = function (relativePath) {
	            var resolvedReferencePath = resolveRelativePath(
	              referencePath,
	              relativePath
	            );
	            return moduleProvider.getModuleExports(resolvedReferencePath);
	          };
	          var publicRequire = createPublicRequire(
	            getModuleExportsByRelativePath
	          );

	          moduleProvider.registerModule(
	            referencePath,
	            module,
	            extensionName,
	            publicRequire,
	            turbine
	          );
	        });
	      }
	    });

	    // We want to extract the module exports immediately to allow the modules
	    // to run some logic immediately.
	    // We need to do the extraction here in order for the moduleProvider to
	    // have all the modules previously registered. (eg. when moduleA needs moduleB, both modules
	    // must exist inside moduleProvider).
	    moduleProvider.hydrateCache();
	  }
	  return moduleProvider;
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	var hydrateSatelliteObject = function (
	  _satellite,
	  container,
	  setDebugEnabled,
	  getVar,
	  setCustomVar
	) {
	  var customScriptPrefixedLogger = logger.createPrefixedLogger('Custom Script');

	  // Will get replaced by the directCall event delegate from the Core extension. Exists here in
	  // case there are no direct call rules (and therefore the directCall event delegate won't get
	  // included) and our customers are still calling the method. In this case, we don't want an error
	  // to be thrown. This method existed before Reactor.
	  _satellite.track = function (identifier) {
	    logger.log(
	      '"' + identifier + '" does not match any direct call identifiers.'
	    );
	  };

	  // Will get replaced by the Marketing Cloud ID extension if installed. Exists here in case
	  // the extension is not installed and our customers are still calling the method. In this case,
	  // we don't want an error to be thrown. This method existed before Reactor.
	  _satellite.getVisitorId = function () {
	    return null;
	  };

	  // container.property also has property settings, but it shouldn't concern the user.
	  // By limiting our API exposure to necessities, we provide more flexibility in the future.
	  _satellite.property = {
	    name: container.property.name,
	    id: container.property.id
	  };

	  _satellite.company = container.company;

	  _satellite.buildInfo = container.buildInfo;

	  _satellite.environment = container.environment;

	  _satellite.logger = customScriptPrefixedLogger;

	  /**
	   * Log a message. We keep this due to legacy baggage.
	   * @param {string} message The message to log.
	   * @param {number} [level] A number that represents the level of logging.
	   * 3=info, 4=warn, 5=error, anything else=log
	   */
	  _satellite.notify = function (message, level) {
	    logger.deprecation(
	      '_satellite.notify is deprecated. Please use the `_satellite.logger` API.'
	    );

	    switch (level) {
	      case 3:
	        customScriptPrefixedLogger.info(message);
	        break;
	      case 4:
	        customScriptPrefixedLogger.warn(message);
	        break;
	      case 5:
	        customScriptPrefixedLogger.error(message);
	        break;
	      default:
	        customScriptPrefixedLogger.log(message);
	    }
	  };

	  _satellite.getVar = getVar;
	  _satellite.setVar = setCustomVar;

	  /**
	   * Writes a cookie.
	   * @param {string} name The name of the cookie to save.
	   * @param {string} value The value of the cookie to save.
	   * @param {number} [days] The number of days to store the cookie. If not specified, the cookie
	   * will be stored for the session only.
	   */
	  _satellite.setCookie = function (name, value, days) {
	    var optionsStr = '';
	    var options = {};

	    if (days) {
	      optionsStr = ', { expires: ' + days + ' }';
	      options.expires = days;
	    }

	    var msg =
	      '_satellite.setCookie is deprecated. Please use ' +
	      '_satellite.cookie.set("' +
	      name +
	      '", "' +
	      value +
	      '"' +
	      optionsStr +
	      ').';

	    logger.deprecation(msg);
	    reactorCookie.set(name, value, options);
	  };

	  /**
	   * Reads a cookie value.
	   * @param {string} name The name of the cookie to read.
	   * @returns {string}
	   */
	  _satellite.readCookie = function (name) {
	    logger.deprecation(
	      '_satellite.readCookie is deprecated. ' +
	        'Please use _satellite.cookie.get("' +
	        name +
	        '").'
	    );
	    return reactorCookie.get(name);
	  };

	  /**
	   * Removes a cookie value.
	   * @param name
	   */
	  _satellite.removeCookie = function (name) {
	    logger.deprecation(
	      '_satellite.removeCookie is deprecated. ' +
	        'Please use _satellite.cookie.remove("' +
	        name +
	        '").'
	    );
	    reactorCookie.remove(name);
	  };

	  _satellite.cookie = reactorCookie;

	  // Will get replaced by the pageBottom event delegate from the Core extension. Exists here in
	  // case the customers are not using core (and therefore the pageBottom event delegate won't get
	  // included) and they are still calling the method. In this case, we don't want an error
	  // to be thrown. This method existed before Reactor.
	  _satellite.pageBottom = function () {};

	  _satellite.setDebug = setDebugEnabled;

	  var warningLogged = false;

	  Object.defineProperty(_satellite, '_container', {
	    get: function () {
	      if (!warningLogged) {
	        logger.warn(
	          '_satellite._container may change at any time and should only ' +
	            'be used for debugging.'
	        );
	        warningLogged = true;
	      }

	      return container;
	    }
	  });
	};

	/***************************************************************************************
	 * Copyright 2021 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/



	var byRegexPattern = function (regexScriptSrcPattern) {
	  var scripts = reactorDocument.querySelectorAll('script');

	  for (var i = 0; i < scripts.length; i++) {
	    var script = scripts[i];
	    // Find the script that loaded our library. Take into account embed scripts migrated
	    // from DTM. We'll also consider that they may have added a querystring for cache-busting
	    // or whatever.
	    if (regexScriptSrcPattern.test(script.src)) {
	      return script;
	    }
	  }
	};

	var getTurbine = function () {
	  return byRegexPattern(new RegExp(/(launch|satelliteLib)-[^\/]+.js(\?.*)?$/));
	};

	// NOTE: this entire module can be dropped when IE 10/11 support is dropped.
	var findPageScript = {
	  getTurbine: getTurbine,
	  byRegexPattern: byRegexPattern
	};

	/***************************************************************************************
	 * (c) 2021 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	function isArrayReference(str) {
	  return (
	    typeof str === 'string' &&
	    str.indexOf('[') !== -1 &&
	    str.indexOf(']') !== -1
	  );
	}
	function sanitizeArrayKey(pathStrSegment) {
	  return pathStrSegment.substr(
	    0,
	    // the name goes up to the start of the array bracket: 'someArrayName[]'
	    pathStrSegment.indexOf('[')
	  );
	}

	/**
	 * Recursive function to loop through settings and look for the setting to transform,
	 * which is the final entry within the pathSegments array. Alters settings in-place.
	 * @param {Array} pathSegments
	 * @param {Object} settings
	 * @param {Function} decorateWithDynamicHost
	 */
	function traverseIntoSettings(pathSegments, settings, decorateWithDynamicHost) {
	  // nothing to do
	  if (!pathSegments.length || !isPlainObject(settings)) {
	    return;
	  }

	  var currentKey = pathSegments[0];

	  // base case
	  if (pathSegments.length === 1) {
	    if (
	      settings.hasOwnProperty(currentKey) &&
	      typeof settings[currentKey] === 'string'
	    ) {
	      settings[currentKey] = decorateWithDynamicHost(settings[currentKey]);
	    }
	    return;
	  }

	  // still more work to do
	  var remainingPathSegments = pathSegments.slice(1);
	  if (isArrayReference(currentKey)) {
	    // 'someArrayReference[]' --> 'someArrayReference'
	    currentKey = sanitizeArrayKey(currentKey);
	    var settingsValue = settings[currentKey];
	    if (Array.isArray(settingsValue)) {
	      settingsValue.forEach(function (arrayEntryObject) {
	        return traverseIntoSettings(
	          remainingPathSegments,
	          arrayEntryObject,
	          decorateWithDynamicHost
	        );
	      });
	    }
	  } else {
	    // object case
	    return traverseIntoSettings(
	      remainingPathSegments,
	      settings[currentKey],
	      decorateWithDynamicHost
	    );
	  }
	}

	/**
	 * Returns a function that when called will attempt to traverse the passed in
	 * settings object to each file path and transform a relative URL to an absolute
	 * URL.
	 *
	 * @param isDynamicEnforced
	 * @param decorateWithDynamicHost
	 * @returns {(function(*=, *=, *=): (*))|*}
	 */
	var createSettingsFileTransformer = function (isDynamicEnforced, decorateWithDynamicHost) {
	  return function (settings, filePaths, moduleReferencePath) {
	    if (
	      !isDynamicEnforced ||
	      !isPlainObject(settings) ||
	      !Object.keys(settings).length ||
	      !Array.isArray(filePaths) ||
	      !filePaths.length
	    ) {
	      return settings;
	    }

	    // pull out the file paths by the module's reference path and loop over each urlPath
	    filePaths.forEach(function (filePathString) {
	      // The custom code action provides the ability to have the source code in the 'source'
	      // variable or to have an external file. Therefore, this module has 2 behaviors.
	      // It also does not provide a value of false for isExternal just as all other extensions
	      // that use fileTransform do not provide an isExternal variable check. Therefore, we need
	      // to treat Adobe's custom code action special, and don't augment the 'source' variable
	      // if isExternal is not also present.
	      var isAdobeCustomCodeAction = Boolean(
	        moduleReferencePath != null &&
	          /^core\/.*actions.*\/customCode\.js$/.test(moduleReferencePath)
	      );
	      if (
	        isAdobeCustomCodeAction &&
	        filePathString === 'source' &&
	        !settings.isExternal
	      ) {
	        return;
	      }

	      // modify the object in place
	      traverseIntoSettings(
	        filePathString.split('.'),
	        settings,
	        decorateWithDynamicHost
	      );
	    });

	    return settings;
	  };
	};

	/***************************************************************************************
	 * (c) 2017 Adobe. All rights reserved.
	 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License. You may obtain a copy
	 * of the License at http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
	 * OF ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 ****************************************************************************************/

	// DYNAMIC URL









































	var IEGetTurbineScript = findPageScript
	  .getTurbine;





	var _satellite = window._satellite;

	if (_satellite && !window.__satelliteLoaded) {
	  // If a consumer loads the library multiple times, make sure only the first time is effective.
	  window.__satelliteLoaded = true;

	  var container = _satellite.container;

	  // Remove container in public scope ASAP so it can't be manipulated by extension or user code.
	  delete _satellite.container;

	  /*
	    get rid of container.buildInfo decoration once deprecation is finished of 
	    buildInfo.environment string
	   */
	  var buildInfo = reactorObjectAssign({}, container.buildInfo);
	  Object.defineProperty(buildInfo, 'environment', {
	    get: function () {
	      logger.deprecation(
	        'container.buildInfo.environment is deprecated.' +
	          'Please use `container.environment.stage` instead'
	      );
	      return container.environment.stage;
	    }
	  });
	  container.buildInfo = buildInfo;

	  var localStorage = getNamespacedStorage('localStorage');
	  var debugController = createDebugController(localStorage, logger);

	  var currentScriptSource = '';
	  if (reactorDocument.currentScript && reactorDocument.currentScript.getAttribute('src')) {
	    currentScriptSource = reactorDocument.currentScript.getAttribute('src');
	  } else if (IEGetTurbineScript()) {
	    currentScriptSource = IEGetTurbineScript().getAttribute('src');
	  }
	  var dynamicHostResolver;
	  try {
	    dynamicHostResolver = createDynamicHostResolver(
	      currentScriptSource,
	      container.company.cdnAllowList,
	      debugController
	    );
	  } catch (e) {
	    logger.warn('Please review the following error:');
	    throw e; // We don't want to continue allowing Turbine to start up if we detect an error in here
	  }

	  var settingsFileTransformer = createSettingsFileTransformer(
	    dynamicHostResolver.isDynamicEnforced,
	    dynamicHostResolver.decorateWithDynamicHost
	  );

	  var moduleProvider = createModuleProvider();

	  var replaceTokens;

	  var undefinedVarsReturnEmpty =
	    container.property.settings.undefinedVarsReturnEmpty;
	  var ruleComponentSequencingEnabled =
	    container.property.settings.ruleComponentSequencingEnabled;

	  var dataElements = container.dataElements || {};

	  // Remove when migration period has ended.
	  dataElementSafe.migrateCookieData(dataElements);

	  var getDataElementDefinition = function (name) {
	    return dataElements[name];
	  };

	  // We support data elements referencing other data elements. In order to be able to retrieve a
	  // data element value, we need to be able to replace data element tokens inside its settings
	  // object (which is what replaceTokens is for). In order to be able to replace data element
	  // tokens inside a settings object, we need to be able to retrieve data element
	  // values (which is what getDataElementValue is for). This proxy replaceTokens function solves the
	  // chicken-or-the-egg problem by allowing us to provide a replaceTokens function to
	  // getDataElementValue that will stand in place of the real replaceTokens function until it
	  // can be created. This also means that createDataElementValue should not call the proxy
	  // replaceTokens function until after the real replaceTokens has been created.
	  var proxyReplaceTokens = function () {
	    return replaceTokens.apply(null, arguments);
	  };

	  var getDataElementValue = createGetDataElementValue(
	    moduleProvider,
	    getDataElementDefinition,
	    proxyReplaceTokens,
	    undefinedVarsReturnEmpty,
	    settingsFileTransformer
	  );

	  var customVars = {};
	  var setCustomVar = createSetCustomVar(customVars);

	  var isVar = createIsVar(customVars, getDataElementDefinition);

	  var getVar = createGetVar(
	    customVars,
	    getDataElementDefinition,
	    getDataElementValue
	  );

	  replaceTokens = createReplaceTokens(isVar, getVar, undefinedVarsReturnEmpty);

	  // Important to hydrate satellite object before we hydrate the module provider or init rules.
	  // When we hydrate module provider, we also execute extension code which may be
	  // accessing _satellite.
	  hydrateSatelliteObject(
	    _satellite,
	    container,
	    debugController.setDebugEnabled,
	    getVar,
	    setCustomVar
	  );

	  hydrateModuleProvider(
	    container,
	    moduleProvider,
	    debugController,
	    replaceTokens,
	    getDataElementValue,
	    settingsFileTransformer,
	    dynamicHostResolver.decorateWithDynamicHost
	  );

	  var notifyMonitors = createNotifyMonitors(_satellite);
	  var executeDelegateModule = createExecuteDelegateModule(
	    moduleProvider,
	    replaceTokens,
	    settingsFileTransformer
	  );

	  var getModuleDisplayNameByRuleComponent = createGetModuleDisplayNameByRuleComponent(
	    moduleProvider
	  );
	  var logConditionNotMet = createLogConditionNotMet(
	    getModuleDisplayNameByRuleComponent,
	    logger,
	    notifyMonitors
	  );
	  var logConditionError = createLogConditionError(
	    getRuleComponentErrorMessage,
	    getModuleDisplayNameByRuleComponent,
	    logger,
	    notifyMonitors
	  );
	  var logActionError = createLogActionError(
	    getRuleComponentErrorMessage,
	    getModuleDisplayNameByRuleComponent,
	    logger,
	    notifyMonitors
	  );
	  var logRuleCompleted = createLogRuleCompleted(logger, notifyMonitors);

	  var evaluateConditions = createEvaluateConditions(
	    executeDelegateModule,
	    isConditionMet,
	    logConditionNotMet,
	    logConditionError
	  );
	  var runActions = createRunActions(
	    executeDelegateModule,
	    logActionError,
	    logRuleCompleted
	  );
	  var executeRule = createExecuteRule(evaluateConditions, runActions);

	  var addConditionToQueue = createAddConditionToQueue(
	    executeDelegateModule,
	    normalizeRuleComponentError,
	    isConditionMet,
	    logConditionError,
	    logConditionNotMet
	  );
	  var addActionToQueue = createAddActionToQueue(
	    executeDelegateModule,
	    normalizeRuleComponentError,
	    logActionError
	  );
	  var addRuleToQueue = createAddRuleToQueue(
	    addConditionToQueue,
	    addActionToQueue,
	    logRuleCompleted
	  );

	  var triggerRule = createTriggerRule(
	    ruleComponentSequencingEnabled,
	    executeRule,
	    addRuleToQueue,
	    notifyMonitors
	  );

	  var getSyntheticEventMeta = createGetSyntheticEventMeta(moduleProvider);

	  var initEventModule = createInitEventModule(
	    triggerRule,
	    executeDelegateModule,
	    normalizeSyntheticEvent,
	    getRuleComponentErrorMessage,
	    getSyntheticEventMeta,
	    logger
	  );

	  initRules(buildRuleExecutionOrder, container.rules || [], initEventModule);
	}

	// Rollup's iife option always sets a global with whatever is exported, so we'll set the
	// _satellite global with the same object it already is (we've only modified it).
	var src$1 = _satellite;

	return src$1;

}());


